<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mactql的博客</title>
  
  
  <link href="https://mactql.github.io/atom.xml" rel="self"/>
  
  <link href="https://mactql.github.io/"/>
  <updated>2021-08-06T13:27:20.503Z</updated>
  <id>https://mactql.github.io/</id>
  
  <author>
    <name>mactql</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第3章 MySQL日志</title>
    <link href="https://mactql.github.io/posts/4156801793.html"/>
    <id>https://mactql.github.io/posts/4156801793.html</id>
    <published>2021-08-06T13:25:00.000Z</published>
    <updated>2021-08-06T13:27:20.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL常用的日志类型有哪些？"><a href="#MySQL常用的日志类型有哪些？" class="headerlink" title="MySQL常用的日志类型有哪些？"></a>MySQL常用的日志类型有哪些？</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0MySQL%E6%97%A5%E5%BF%97/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p><strong>错误日志记录mysql在启动、运行、关闭过程中出现的问题，并会记录在错误文件中。用户可以通过<code>SHOW VARIABLES LLKE &#39;log_error‘</code>来定位错误日志文件。默认情况下文件名为主机名，查看错误文件并进行优化</strong></p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p><strong>慢查询日志可以定位可能存在问题的SQL语句，从而进行SQL语句层面的优化</strong><br><strong>例如可以在MySQL启动时设一个阈值，若运行时间超过该值的SQL语句就记录到慢查日志文件中</strong><br><strong>用户可以通过<code>SHOW VARIABLES LIKE &#39;log_slow_queries&#39;</code></strong></p><h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p><strong>二进制日志记录了对MySQL数据库执行更改的所有操作，即不包括SHOW和SELECT这类语句</strong><br><strong>二进制日志的作用为基于时间点恢复数据、主从复制数据、审计数据（判断是否有注入攻击）</strong><br><strong>默认文件名为主机名.日志序列号，如host.00001。二进制日志默认关闭，需要手动开启</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL常用的日志类型有哪些？&quot;&gt;&lt;a href=&quot;#MySQL常用的日志类型有哪些？&quot; class=&quot;headerlink&quot; title=&quot;MySQL常用的日志类型有哪些？&quot;&gt;&lt;/a&gt;MySQL常用的日志类型有哪些？&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=</summary>
      
    
    
    
    <category term="《MySQL技术内幕》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MySQL" scheme="https://mactql.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第1章 MySQL和存储引擎</title>
    <link href="https://mactql.github.io/posts/925095689.html"/>
    <id>https://mactql.github.io/posts/925095689.html</id>
    <published>2021-08-06T06:59:00.000Z</published>
    <updated>2021-08-06T06:59:36.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL存储引擎是什么？"><a href="#MySQL存储引擎是什么？" class="headerlink" title="MySQL存储引擎是什么？"></a>MySQL存储引擎是什么？</h2><ul><li><strong>MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现</strong></li></ul><hr><h2 id="MySQL存储引擎的选择"><a href="#MySQL存储引擎的选择" class="headerlink" title="MySQL存储引擎的选择"></a>MySQL存储引擎的选择</h2><ul><li><strong>5.5之前默认存储引擎是MyISAM,5.5之后默认存储引擎是Innodb</strong></li></ul><hr><h2 id="具体说说MyISAM"><a href="#具体说说MyISAM" class="headerlink" title="具体说说MyISAM"></a>具体说说MyISAM</h2><p><strong>首先MyISAM支持全文检索，不支持事务和行级锁，只有表级别锁，它适用于 OLAP 场景，也就是分析类的，基本上都是读取，不会有什么写入动作的场景</strong><br><strong>其次它的数据和索引是分离存储的，也就是不在一个文件上，并且数据库只会缓存索引文件，数据文件的缓存直接交给操作系统搞定</strong><br><strong>然后MyISAM 的索引也是 B+ 树，只是不像 InnoDB 那种叶子节点会存储完整的数据，MyISAM 的数据是独立于索引单独存储的，所以主键和非主键索引差别不大</strong><br><strong>还有一个情况就是 MyISAM 不支持崩溃后的安全恢复，而 InnoDB 有个 redolog 可以支持安全恢复</strong><br><strong>再有一点就是 MyISAM 写入性能差。因为锁的粒度太粗了，不支持行锁，只有表锁，所以写入的时候会对整张表加锁</strong></p><h2 id="具体说说Innodb"><a href="#具体说说Innodb" class="headerlink" title="具体说说Innodb"></a>具体说说Innodb</h2><p><strong>InnoDB 支持事务，实现了四种标准的隔离级别，利用 MVCC 来支持高并发，默认事务隔离级别为可重复读，支持行锁，利用行锁+间隙锁提供可重复读级别下防止幻读的能力，支持崩溃后的数据安全恢复</strong><br><strong>另外还支持外键</strong><br><strong>InnoDB 的主键索引称为聚簇索引，也就是数据和索引是放在一起的，这与 MyISAM 有所不同，并且它的辅助索引(非主键索引)只存储索引值与主键，因此当辅助索引不能覆盖查询的列时，需要通过找到的主键再去聚簇索引查询数据，这个过程称之为****回表</strong><br><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC1%E7%AB%A0MySQL%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><br><strong>它之所以能取代 MyISAM 成为默认引擎就是因为事务的支持、 Innodb的关键特性、崩溃后的数据安全恢复例如MVCC</strong></p><hr><h2 id="Innodb和MyISAM的区别"><a href="#Innodb和MyISAM的区别" class="headerlink" title="Innodb和MyISAM的区别"></a>Innodb和MyISAM的区别</h2><ul><li><strong>Innodb支持事务，MyISAM不支持事务</strong></li><li><strong>MyISAM不支持外键，InnoDB支持外键</strong></li><li><strong>MyISAM只支持表级锁，InnoDB支持行级锁和表级锁，默认是行级锁</strong></li><li><strong>MyISAM支持全文索引，InnoDB不支持全文索引</strong></li><li><strong>MyISAM支持没有主键的表存在，InnoDB不支持没有主键</strong></li><li><strong>MyISAM较简单，效率上优于InnoDB，适合小型应用</strong></li><li><strong>MyISAM使用非聚集索引，InnoDB使用聚集索引</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL存储引擎是什么？&quot;&gt;&lt;a href=&quot;#MySQL存储引擎是什么？&quot; class=&quot;headerlink&quot; title=&quot;MySQL存储引擎是什么？&quot;&gt;&lt;/a&gt;MySQL存储引擎是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MySQL中的数据、索引</summary>
      
    
    
    
    <category term="《MySQL技术内幕》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MySQL" scheme="https://mactql.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>牛客SQL第1-20题</title>
    <link href="https://mactql.github.io/posts/642795887.html"/>
    <id>https://mactql.github.io/posts/642795887.html</id>
    <published>2021-07-30T14:47:00.000Z</published>
    <updated>2021-08-06T01:33:59.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL1"><a href="#SQL1" class="headerlink" title="SQL1"></a>SQL1</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>第一种：适用于最晚的员工如果不止一个的情况</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>先找到最晚的hire_data，再用条件查到</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(hire_date) <span class="keyword">FROM</span> employees)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>第二种：不适用于最晚的员工如果不止一个的情况。</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>降序排序，并且只显示第一行  </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>limit(x,y)代表第x行开始共显示y行  limit x [<span class="keyword">offset</span> y]代表取前x行数据，但是跳过y行</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> LIMIT <span class="number">0</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL2"><a href="#SQL2" class="headerlink" title="SQL2"></a>SQL2</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>适用于相同时间员工不止一个的情况</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法同SQL1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>注意<span class="keyword">DISTINCT</span>去重</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> hire_date <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> LIMIT <span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>不适用于相同时间员工不止一个的情况</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法同SQL1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> LIMIT <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL3"><a href="#SQL3" class="headerlink" title="SQL3"></a>SQL3</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>给表起别名 <span class="keyword">FROM</span> tablea t 把tablea起名为t</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>等值连接 <span class="keyword">where</span>连接两个表</span><br><span class="line"><span class="keyword">SELECT</span> s.<span class="operator">*</span> ,d.dept_no <span class="keyword">FROM</span> salaries s,dept_manager d</span><br><span class="line">  <span class="keyword">WHERE</span> s.emp_no <span class="operator">=</span> d.emp_no</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> s.emp_no</span><br></pre></td></tr></table></figure><hr><h2 id="SQL4"><a href="#SQL4" class="headerlink" title="SQL4"></a>SQL4</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>第一种：等值连接</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line">  <span class="keyword">FROM</span> employees e,dept_emp d</span><br><span class="line">  <span class="keyword">WHERE</span> e.emp_no <span class="operator">=</span> d.emp_no</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>第二种：自然连接 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span></span><br><span class="line"> <span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line">  <span class="keyword">FROM</span> employees e</span><br><span class="line">  <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> dept_emp d</span><br></pre></td></tr></table></figure><hr><h2 id="SQL5"><a href="#SQL5" class="headerlink" title="SQL5"></a>SQL5</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* INNER JOIN 两边表同时有对应的数据，即任何一边缺失数据就不显示。</span></span><br><span class="line"><span class="comment">LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</span></span><br><span class="line"><span class="comment">RIGHT JOIN 会读取右边数据表的全部数据，即便左边表无对应数据。*/</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>内外连接需要用<span class="keyword">ON</span>做条件</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line">  <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept_emp d</span><br><span class="line">  <span class="keyword">ON</span> e.emp_no <span class="operator">=</span> d.emp_no</span><br></pre></td></tr></table></figure><hr><h2 id="SQL7"><a href="#SQL7" class="headerlink" title="SQL7"></a>SQL7</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">GROUP</span> <span class="keyword">BY</span> 可以按照属性对表分组</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>当用上 <span class="keyword">GROUP</span> <span class="keyword">BY</span>后的聚集函数是对每一个组进行聚集</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">HAVING</span>和 <span class="keyword">WHERE</span>类似，都是起到过滤作用，但是<span class="keyword">HAVING</span>是对分组进行过滤，<span class="keyword">WHERE</span>是对行进行过滤</span><br><span class="line"><span class="keyword">SELECT</span> emp_no,<span class="built_in">COUNT</span>(emp_no) <span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(emp_no) <span class="operator">&gt;</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL8"><a href="#SQL8" class="headerlink" title="SQL8"></a>SQL8</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>同SQL2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary <span class="keyword">FROM</span> salaries</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL10"><a href="#SQL10" class="headerlink" title="SQL10"></a>SQL10</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/7.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>不包含用 <span class="keyword">NOT</span> <span class="keyword">IN</span>(...)</span><br><span class="line"><span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">WHERE</span> emp_no <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> dept_manager</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><hr><h2 id="SQL11"><a href="#SQL11" class="headerlink" title="SQL11"></a>SQL11</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/8.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>等值连接<span class="operator">+</span>条件判断</span><br><span class="line"><span class="keyword">SELECT</span> emp.emp_no,man.emp_no <span class="keyword">FROM</span> dept_emp emp,dept_manager man</span><br><span class="line">  <span class="keyword">WHERE</span> emp.dept_no <span class="operator">=</span> man.dept_no <span class="operator">&amp;&amp;</span> emp.emp_no <span class="operator">!=</span> man.emp_no</span><br></pre></td></tr></table></figure><hr><h2 id="SQL12"><a href="#SQL12" class="headerlink" title="SQL12"></a>SQL12</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/9.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>首先是内连接，若不匹配直接不显示。因为两个表有两个相同属性，from_date数据不同所以不能用自然连接</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>然后用窗口函数 <span class="keyword">OVER</span>(PARITION BY... <span class="keyword">ORDER</span> <span class="keyword">BY</span>) <span class="keyword">as</span> ... 可以分组进行排序，并且不修改原来的数据只添加一个排序列</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>要求TOPN的题都可以用窗口函数嵌套上查询和<span class="keyword">where</span>条件把rank<span class="operator">=</span>N的取出来</span><br><span class="line"><span class="keyword">SELECT</span> t.dept_no,t.emp_no,t.salary</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> d.dept_no,d.emp_no,d.salary,<span class="built_in">DENSE_RANK</span>()</span><br><span class="line">          <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> d.dept_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> d.salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> sal_rank</span><br><span class="line">          <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> emp.dept_no,emp.emp_no,s.salary</span><br><span class="line">                  <span class="keyword">FROM</span> dept_emp emp</span><br><span class="line">                  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries s <span class="keyword">ON</span> emp.emp_no <span class="operator">=</span> s.emp_no) d</span><br><span class="line">       ) t</span><br><span class="line">  <span class="keyword">WHERE</span> t.sal_rank <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL15"><a href="#SQL15" class="headerlink" title="SQL15"></a>SQL15</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/10.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>值不相等用<span class="operator">!=</span>，非空用 <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>字符串用<span class="string">&#x27;&#x27;</span>引上</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>多个条件用 <span class="keyword">AND</span>连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">WHERE</span> emp_no <span class="operator">%</span> <span class="number">2</span> <span class="operator">!=</span> <span class="number">0</span> <span class="keyword">AND</span> last_name <span class="operator">!=</span> <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL16"><a href="#SQL16" class="headerlink" title="SQL16"></a>SQL16</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/11.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>要对分组后的聚集函数的结果进行 <span class="keyword">ORDER</span> <span class="keyword">BY</span>，需要先对结果起个别名</span><br><span class="line"><span class="keyword">SELECT</span> t.title,<span class="built_in">AVG</span>(s.salary) <span class="keyword">AS</span> sal_avg <span class="keyword">FROM</span> titles t</span><br><span class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries s <span class="keyword">ON</span> t.emp_no <span class="operator">=</span> s.emp_no</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> t.title</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal_avg</span><br></pre></td></tr></table></figure><hr><h2 id="SQL17"><a href="#SQL17" class="headerlink" title="SQL17"></a>SQL17</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/12.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>同SQL1</span><br><span class="line"><span class="keyword">SELECT</span> emp_no,salary <span class="keyword">FROM</span> salaries</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">1</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL18"><a href="#SQL18" class="headerlink" title="SQL18"></a>SQL18</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/13.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>怪题</span><br><span class="line"><span class="keyword">SELECT</span> s.emp_no, s.salary, e.last_name, e.first_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> salaries s</span><br><span class="line"><span class="keyword">WHERE</span> s.salary <span class="operator">=</span> (</span><br><span class="line">  <span class="keyword">select</span> <span class="built_in">max</span>(salary)</span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line">  <span class="keyword">where</span> salary <span class="operator">!=</span> ( <span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> salaries )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="SQL19"><a href="#SQL19" class="headerlink" title="SQL19"></a>SQL19</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/14.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>双左连接，左边有数据右边没有数据也显示</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept_emp t <span class="keyword">ON</span> e.emp_no <span class="operator">=</span> t.emp_no</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> t.dept_no <span class="operator">=</span> d.dept_no</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL1&quot;&gt;&lt;a href=&quot;#SQL1&quot; class=&quot;headerlink&quot; title=&quot;SQL1&quot;&gt;&lt;/a&gt;SQL1&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=&quot;lazyload placeholder&quot; data-original=&quot;/medias/%E</summary>
      
    
    
    
    <category term="牛客网SQL题库" scheme="https://mactql.github.io/categories/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E9%A2%98%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://mactql.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第4章 锁的优化</title>
    <link href="https://mactql.github.io/posts/110256432.html"/>
    <id>https://mactql.github.io/posts/110256432.html</id>
    <published>2021-07-28T07:04:00.000Z</published>
    <updated>2021-07-28T10:16:47.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-锁的优化有哪些点？"><a href="#4-1-锁的优化有哪些点？" class="headerlink" title="4.1 锁的优化有哪些点？"></a>4.1 锁的优化有哪些点？</h2><ul><li><strong>减少锁的持有时间：尽量避免对整个方法synchronized，只在必要时进行synchronized</strong></li><li><strong>减小锁粒度：即缩小锁定对象的范围。例如ConcurrentHashMap对其中的某个段加锁，不要对整个HashMap加锁</strong></li><li><strong>使用读写锁，即ReadWriteLock</strong></li><li><strong>锁分离：把读写锁的思想作延伸，对不同的操作功能加锁。例如LinkedBlockingQueue的take()和put()方法使用不同的锁</strong></li><li><strong>锁粗化：如果对同一个锁不断地进行请求，同步和释放，这些操作本身就会占用大量的系统资源</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC4%E7%AB%A0%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>JVM对锁的优化：</strong><ul><li><strong>偏向锁：当一个线程获得锁，就进入偏向模式。再次请求锁时，无需同步</strong></li><li><strong>轻量级锁：如果偏向锁失败，则尝试轻量级锁。若加锁失败轻量级锁被其他线程争夺到，则转为重量级锁</strong></li><li><strong>自旋锁：在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取</strong></li><li><strong>锁消除：去除不可能存在共享资源竞争的锁</strong></li></ul></li></ul><hr><h2 id="4-3-ThreadLocal是与锁不同的另一个思路"><a href="#4-3-ThreadLocal是与锁不同的另一个思路" class="headerlink" title="4.3 ThreadLocal是与锁不同的另一个思路"></a>4.3 ThreadLocal是与锁不同的另一个思路</h2><ul><li><p><strong>除了锁可以保证线程安全，还可以通过增加资源来保证</strong></p></li><li><p><strong>ThreadLocal实际是Thread.ThreadLocalMap中一条记录的引用。而这个ThreadLocalMap实际上是在任何地方都可以访问到的。所以， <code>他实际是在存储全局变量，只不过这个全局变量比较特殊，每一个实例都跟一个线程绑定了。</code> 你在A线程set了这个变量进去，那这个变量只是A的，只有A线程运行时才能访问到，线程B是访问不到的，除非线程B也set一个，也就是所谓的每个线程持有一个副本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ThreadLocal的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//设置ThreadLocal的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//删除ThreadLocal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//初始化ThreadLocal的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>这里仅了解，后续会作专栏深入分析</strong></p></li></ul><hr><h2 id="4-4-CAS比较交换也是与锁不同的一种新思路"><a href="#4-4-CAS比较交换也是与锁不同的一种新思路" class="headerlink" title="4.4 CAS比较交换也是与锁不同的一种新思路"></a>4.4 CAS比较交换也是与锁不同的一种新思路</h2><ul><li><strong>CAS(V,E,N)三个参数，V表示要更新的变量，E表示预期值，N表示新值。</strong></li><li><strong>只有V=E时，才会更新V为N。否则宣布失败，并返回V当前值，并且不会被挂起，可再次尝试</strong></li><li><strong>简单的说，E就是你以为V应该是多少了，如果V不是你想的那样，说明已经被其他线程改过了，就得重新读，再次尝试就好了</strong></li></ul><h3 id="JDK并发包中的atomic包就是使用CAS理论："><a href="#JDK并发包中的atomic包就是使用CAS理论：" class="headerlink" title="JDK并发包中的atomic包就是使用CAS理论："></a>JDK并发包中的atomic包就是使用CAS理论：</h3><ul><li><strong>AtomicInteger：基于CAS理论的无锁的线程安全的整数，原理如图 incrementAndGet方法是使用CAS操作让自己+1</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC4%E7%AB%A0%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-1-锁的优化有哪些点？&quot;&gt;&lt;a href=&quot;#4-1-锁的优化有哪些点？&quot; class=&quot;headerlink&quot; title=&quot;4.1 锁的优化有哪些点？&quot;&gt;&lt;/a&gt;4.1 锁的优化有哪些点？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减少锁的持有时间：尽量避</summary>
      
    
    
    
    <category term="《Java高并发程序设计》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java并发" scheme="https://mactql.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第3章 JDK并发包</title>
    <link href="https://mactql.github.io/posts/4214418351.html"/>
    <id>https://mactql.github.io/posts/4214418351.html</id>
    <published>2021-07-27T13:56:00.000Z</published>
    <updated>2021-07-27T13:59:13.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-1-重入锁ReentrantLock和synchronized的区别"><a href="#3-1-1-重入锁ReentrantLock和synchronized的区别" class="headerlink" title="3.1.1 重入锁ReentrantLock和synchronized的区别"></a>3.1.1 重入锁ReentrantLock和synchronized的区别</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">    lock.lock();<span class="comment">//指定何时加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();<span class="comment">//指定何时解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ReentrantLock的特点：</strong><ul><li><strong>在等待锁的过程中，可以中断线程让他不再等待，lock.lockInterruptibly()</strong></li><li><strong>可以指定公平锁或者非公平锁</strong><ul><li><strong>公平锁的意思就是当锁可用时，先申请该锁的线程先获得锁</strong></li></ul></li><li><strong>提供了Condition类，可以实现synchronized类似wait/notify的功能</strong></li></ul></li><li><strong>当需要使用ReentrantLock这三个特点时使用，其他时候可以使用synchronized</strong></li></ul><hr><h2 id="3-1-3-信号量（Semaphore）"><a href="#3-1-3-信号量（Semaphore）" class="headerlink" title="3.1.3 信号量（Semaphore）"></a>3.1.3 信号量（Semaphore）</h2><ul><li><strong>用来指定同时可以有多少线程访问某个资源</strong></li></ul><hr><h2 id="3-1-4-ReadWriteLock读写锁"><a href="#3-1-4-ReadWriteLock读写锁" class="headerlink" title="3.1.4 ReadWriteLock读写锁"></a>3.1.4 ReadWriteLock读写锁</h2><ul><li><strong>读写锁是为了防止读操作和读操作之间不阻塞，读写锁访问约束如下图所示</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><hr><h2 id="3-1-5-倒计时器（CountDownLatch）"><a href="#3-1-5-倒计时器（CountDownLatch）" class="headerlink" title="3.1.5 倒计时器（CountDownLatch）"></a>3.1.5 倒计时器（CountDownLatch）</h2><ul><li><strong>适用场景：火箭发射</strong></li><li><strong>主线程在CountDownLatch上等待，当所有前置任务完成后，主线程再执行</strong></li></ul><hr><h2 id="3-2-线程池"><a href="#3-2-线程池" class="headerlink" title="3.2 线程池"></a>3.2 线程池</h2><h3 id="首先是线程池框架："><a href="#首先是线程池框架：" class="headerlink" title="首先是线程池框架："></a>首先是线程池框架：</h3><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h3 id="如何使用线程池？"><a href="#如何使用线程池？" class="headerlink" title="如何使用线程池？"></a>如何使用线程池？</h3><ul><li><strong>常用的线程池</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>手动创建线程池</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>线程池实现原理</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>即和corePoolSize、workQueue、maximumPoolSize比较</strong></li></ul><hr><h2 id="3-3-JDK并发容器（仅了解，后续专门出专栏深入分析）"><a href="#3-3-JDK并发容器（仅了解，后续专门出专栏深入分析）" class="headerlink" title="3.3 JDK并发容器（仅了解，后续专门出专栏深入分析）"></a>3.3 JDK并发容器（仅了解，后续专门出专栏深入分析）</h2><ul><li><strong>ConcurrentHashMap</strong></li><li><strong>CopyOnWriteArrayList</strong></li><li><strong>BlockingQueue</strong></li><li><strong>ConcurrentSkipListMap</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3-1-1-重入锁ReentrantLock和synchronized的区别&quot;&gt;&lt;a href=&quot;#3-1-1-重入锁ReentrantLock和synchronized的区别&quot; class=&quot;headerlink&quot; title=&quot;3.1.1 重入锁Reentra</summary>
      
    
    
    
    <category term="《Java高并发程序设计》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java并发" scheme="https://mactql.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第7章 类加载机制</title>
    <link href="https://mactql.github.io/posts/1316463453.html"/>
    <id>https://mactql.github.io/posts/1316463453.html</id>
    <published>2021-07-24T08:26:00.000Z</published>
    <updated>2021-07-24T12:19:53.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类从被加载到JVM到卸载出内存的完整生命周期？"><a href="#类从被加载到JVM到卸载出内存的完整生命周期？" class="headerlink" title="类从被加载到JVM到卸载出内存的完整生命周期？"></a>类从被加载到JVM到卸载出内存的完整生命周期？</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC7%E7%AB%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="说一下各个步骤？"><a href="#说一下各个步骤？" class="headerlink" title="说一下各个步骤？"></a>说一下各个步骤？</h2><h3 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h3><ul><li><strong>查找并加载类文件的二进制数据</strong></li><li><strong>会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的数据的入口</strong></li></ul><h3 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h3><ul><li><strong>把已经读入内存的类的二进制数据放到虚拟机环境中，包括以下步骤：</strong><ul><li><strong>验证：确保被加载类的正确性</strong></li><li><strong>准备：为类的静态变量分配内存，并初始化</strong></li><li><strong>解析：把常量池中的符号引用替换为直接引用</strong></li></ul></li></ul><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化：</strong></h3><ul><li><strong>为类的静态变量赋初值</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类从被加载到JVM到卸载出内存的完整生命周期？&quot;&gt;&lt;a href=&quot;#类从被加载到JVM到卸载出内存的完整生命周期？&quot; class=&quot;headerlink&quot; title=&quot;类从被加载到JVM到卸载出内存的完整生命周期？&quot;&gt;&lt;/a&gt;类从被加载到JVM到卸载出内存的完</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第6章 Class文件结构</title>
    <link href="https://mactql.github.io/posts/3853486135.html"/>
    <id>https://mactql.github.io/posts/3853486135.html</id>
    <published>2021-07-24T02:12:00.000Z</published>
    <updated>2021-07-24T02:15:21.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Class文件？"><a href="#什么是Class文件？" class="headerlink" title="什么是Class文件？"></a>什么是Class文件？</h2><ul><li><strong>Class文件是一组以8字节为单位的字节流，各个数据项目按顺序紧凑排列</strong></li><li><strong>Class文件格式只有两种类型：无符号数和表</strong><ul><li><strong>无符号数是基本数据类型，如u1，u2，u4，u8代表1个字节，2个字节，4个字节，8个字节的无符号数</strong></li><li><strong>表是由多个无符号数和其他表组成的复合数据结构，一般名称以_info结尾</strong></li></ul></li></ul><hr><h2 id="具体说一下Class文件的结构？"><a href="#具体说一下Class文件的结构？" class="headerlink" title="具体说一下Class文件的结构？"></a>具体说一下Class文件的结构？</h2><ul><li><strong>首先头4个字节是魔数，有这4个字节的才是Class文件</strong></li><li><strong>后面第5、6字节是次版本号，第7、8字节是主版本号</strong></li><li><strong>第9字节开始是常量池，每个常量开头第一个字节表示常量池的某个项目标记，按照标记确定是哪个常量类型，第二个字节是长度，根据长度往后找这么多个字节表示常量</strong><ul><li><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC6%E7%AB%A0Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>常量池结束后两个字节代表访问标志，包括这个Class是类还是接口，是不是public，是不是abstract等</strong><ul><li><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC6%E7%AB%A0Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>访问标志之后是类索引、父类索引和接口索引集合</strong></li><li><strong>之后是字段表集合，用来描述类/接口中的变量，包括各种修饰符和引用常量池的常量</strong></li><li><strong>然后是方法表集合，和字段表几乎一样，用来描述类/接口中的方法</strong></li><li><strong>最后是属性表集合，字段表和方法表都可以拥有自己的属性表集合，例如栈深度、变量存储空间、行号等</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是Class文件？&quot;&gt;&lt;a href=&quot;#什么是Class文件？&quot; class=&quot;headerlink&quot; title=&quot;什么是Class文件？&quot;&gt;&lt;/a&gt;什么是Class文件？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Class文件是一组以8字节为单位的字节</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第3章 垃圾回收</title>
    <link href="https://mactql.github.io/posts/121600763.html"/>
    <id>https://mactql.github.io/posts/121600763.html</id>
    <published>2021-07-21T07:27:00.000Z</published>
    <updated>2021-07-21T07:30:58.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="怎么判断对象是否需要回收？"><a href="#怎么判断对象是否需要回收？" class="headerlink" title="怎么判断对象是否需要回收？"></a>怎么判断对象是否需要回收？</h2><blockquote><ul><li><strong>引用计数法：给对象添加一个<code>引用</code>计数器，每有一个地方<code>引用</code>它就+1，<code>引用</code>失效就-1，如果是0则回收。</strong><ul><li><strong>优点：效率高；缺点：无法回收循环<code>引用</code>的对象</strong></li></ul></li><li><strong>可达性分析法：当一个对象到GC Roots对象没有任何<code>引用</code>链，则回收</strong><ul><li><strong>GC Roots对象包括虚拟机栈帧中<code>引用</code>的对象、方法区静态变量/常量<code>引用</code>的对象、Native方法<code>引用</code>的对象</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/184604/33/14082/59596/60f395a6Ecd2724bd/d1c15f01625eb0f3.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li></ul></blockquote><hr><h2 id="那么如何判断对象是否被引用呢？"><a href="#那么如何判断对象是否被引用呢？" class="headerlink" title="那么如何判断对象是否被引用呢？"></a>那么如何判断对象是否被引用呢？</h2><blockquote><ul><li><strong>强引用：类似<code>Object obj = new Object()</code> ，只要强引用存在，就不会回收掉</strong></li><li><strong>软引用：用SoftReference来实现，用来描述还有用但非必需的对象，会在内存溢出之前回收</strong></li><li><strong>弱引用：用WeakReference来实现，用来描述非必需的对象，不管内存够不够在下一次垃圾回收时一定会被回收</strong></li><li><strong>虚引用：用PhantomReference来实现，虚引用的对象无法获得实例，随时都可能回收</strong></li></ul></blockquote><hr><h2 id="垃圾回收算法？"><a href="#垃圾回收算法？" class="headerlink" title="垃圾回收算法？"></a>垃圾回收算法？</h2><blockquote><ul><li><strong>标记-清除法：标记所有要回收的对象，然后回收</strong><ul><li><strong>缺点：效率不高且会产生大量不连续的内存碎片，导致分配大对象时频繁GC</strong></li><li><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/185383/8/14522/53934/60f3d996Ef41bae8f/d83aeb330f503134.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>复制算法：<strong><strong>一般用于新生代，</strong></strong>将内存分成两块，每次只使用一块，每次回收都复制到另一块上，清除原来的空间</strong><ul><li><strong>缺点：内存缩小一半，浪费</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/176921/26/14679/62356/60f3daffEd4c25677/15d4ef96862c0ab5.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li><li><strong>标记整理法：一般用于老年代，和标记清除法一样，但是在标记后先整理，然后再回收</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/43697/29/16010/52898/60f3dc75E1aa9490e/0e7b3d567b1f6e36.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul></blockquote><hr><h2 id="如何真正实现垃圾回收？"><a href="#如何真正实现垃圾回收？" class="headerlink" title="如何真正实现垃圾回收？"></a>如何真正实现垃圾回收？</h2><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/173645/25/20673/66480/60f7b9b6Ec08b96f1/62fb3ab1ee064160.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="具体介绍一下CMS？"><a href="#具体介绍一下CMS？" class="headerlink" title="具体介绍一下CMS？"></a>具体介绍一下CMS？</h3><ul><li><strong>CMS基于标记-清除法，目标为获取最短回收停顿时间的收集器</strong></li><li><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/182782/9/15017/89966/60f7bc62Ec7fa78c8/2c08336b28b74381.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li><li><strong>共分为四个步骤：</strong><ul><li><strong>初始标记：只标记一下GC Roots能连接的对象</strong></li><li><strong>并发标记：GC Roots tracing，即可达性分析</strong></li><li><strong>重新标记：修正并发标记期间因用户线程导致产生变动的对象的标记</strong></li><li><strong>并发清理：并发垃圾回收</strong></li></ul></li><li><strong>CMS优点：不停顿，并发执行。</strong></li><li><strong>缺点：并发执行对CPU资源压力大，且无法处理在处理过程中产生的垃圾，且标记清除法会产生垃圾碎片</strong></li></ul><h3 id="具体介绍一下G1？"><a href="#具体介绍一下G1？" class="headerlink" title="具体介绍一下G1？"></a>具体介绍一下G1？</h3><ul><li><strong>G1是当前垃圾收集器最前沿成果之一，采用标记整理法，且能精确控制停顿时间</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/174570/7/20663/93930/60f7c803Ea2dcff2e/f72746522c8fde5d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><ul><li><strong>和CMS很类似，但是G1会把内存分成多个独立的区域，并根据允许回收的时间优先回收垃圾最多的区域</strong></li></ul></li></ul><hr><h2 id="具体说一下新生代和老年代的对象"><a href="#具体说一下新生代和老年代的对象" class="headerlink" title="具体说一下新生代和老年代的对象"></a>具体说一下新生代和老年代的对象</h2><ul><li><strong>首先大多数情况，对象在新生代Eden区中分配。当Eden区空间不够时，会触发一次Minor GC（新生代GC）</strong></li><li><strong>大对象直接进入到老年代</strong></li><li><strong>长期存活的对象直接进入老年代。</strong><ul><li><strong>对象在Eden区出生并经过一次Minor GC仍然存活且能被Survivor区容纳，会被移动到Survivor区，并且设置年龄为1岁。每熬过一次Minor GC年龄就+1</strong></li><li><strong>如果Survivor区中相同年龄的所有对象大小总和大于Survivor区的一半，那么年龄大于等于该年龄的对象都去老年代</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;怎么判断对象是否需要回收？&quot;&gt;&lt;a href=&quot;#怎么判断对象是否需要回收？&quot; class=&quot;headerlink&quot; title=&quot;怎么判断对象是否需要回收？&quot;&gt;&lt;/a&gt;怎么判断对象是否需要回收？&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第2章 内存分配</title>
    <link href="https://mactql.github.io/posts/815353185.html"/>
    <id>https://mactql.github.io/posts/815353185.html</id>
    <published>2021-07-17T08:02:00.000Z</published>
    <updated>2021-07-18T01:29:05.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-2-JVM体系结构概览"><a href="#2-2-JVM体系结构概览" class="headerlink" title="2.2 JVM体系结构概览"></a>2.2 JVM体系结构概览</h2><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/173588/33/19717/156152/60f17a35Ee1bce496/2e168a5d18d9e86a.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h3 id="运行时数据区包含以下部分"><a href="#运行时数据区包含以下部分" class="headerlink" title="运行时数据区包含以下部分"></a>运行时数据区包含以下部分</h3><blockquote><ul><li><strong>程序计数器：（线程私有）</strong><ul><li><strong>一块较小的内存空间, 用来存储指向下一条指令的地址</strong></li><li><strong>这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域</strong></li></ul></li><li><strong>虚拟机栈：（线程私有）</strong><ul><li><strong>每个方法在执行的同时都会创建一个栈帧</strong></li><li><strong>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</strong></li></ul></li><li><strong>本地方法栈：（线程私有）</strong><ul><li><strong>和虚拟机栈类似，区别为此栈执行的是Native方法</strong></li></ul></li><li><strong>堆：（线程共享）</strong><ul><li><strong>创建的对象实例和数组都保存在堆中</strong></li><li><strong>运行时动态分配内存大小，自动垃圾回收</strong></li></ul></li><li><strong>方法区：（线程共享）</strong><ul><li><strong>用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></li></ul></li></ul></blockquote><hr><h3 id="栈、堆、方法区是怎么交互的？"><a href="#栈、堆、方法区是怎么交互的？" class="headerlink" title="栈、堆、方法区是怎么交互的？"></a>栈、堆、方法区是怎么交互的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMain</span> </span>&#123; <span class="comment">//运行时，JVM把AppMain的信息都放入方法区    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//main成员方法本身放入方法区。    </span></span><br><span class="line">        Sample test1 = <span class="keyword">new</span> Sample( <span class="string">&quot; 测试1 &quot;</span> ); <span class="comment">//test1是引用，所以放到栈区里，Sample是对象应该放到堆里         </span></span><br><span class="line">        test1.printName();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上述代码的JVM执行流程："><a href="#上述代码的JVM执行流程：" class="headerlink" title="上述代码的JVM执行流程："></a>上述代码的JVM执行流程：</h4><ul><li><strong>首先启动了一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中。这一过程称为AppMain类的加载过程。</strong></li><li><strong>接着，JVM定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：Sample test1 = new Sample(“测试1”);</strong><ul><li><strong>Java虚拟机一看，不就是建立一个Sample类的实例吗，简单，于是就直奔方法区（方法区存放已经加载的类的相关信息，如类、静态变量和常量）而去，先找到Sample类的类型信息再说。结果呢，嘿嘿，没找到，这会儿的方法区里还没有Sample类呢（即Sample类的类信息还没有进入方法区中）。可JVM也不是一根筋的笨蛋，于是，它发扬“自己动手，丰衣足食”的作风，立马加载了Sample类， 把Sample类的相关信息存放在了方法区中。</strong></li><li><strong>Sample类的相关信息加载完成后。Java虚拟机做的第一件事情就是在堆中为一个新的Sample类的实例分配内存，这个Sample类的实例持有着指向方法区的Sample类的类型信息的引用（Java中引用就是内存地址）。这里所说的引用，实际上指的是Sample类的类型信息在方法区中的内存地址，其实，就是有点类似于C语言里的指针啦~~，而这个地址呢，就存放了在Sample类的实例的数据区中。</strong></li><li><strong>然后位于“=”前的test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，test1这个局部变量会被JVM添加到执行main()方法的主线程的Java方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，test1这个局部变量持有指向Sample类的实例的引用（即内存地址）。</strong></li></ul></li><li><strong>JVM将继续执行后续指令，执行printName()方法。当JVM执行test1.printName()方法时，JVM根据局部变量test1持有的引用，定位到堆中的Sample类的实例，再根据Sample类的实例持有的引用，定位到方法区中Sample类的类型信息（包括①类，②静态变量，③静态方法，④常量和⑤成员方法），从而获取printName()成员方法的字节码，接着执行printName()成员方法包含的指令。</strong></li></ul><hr><h2 id="从垃圾回收的角度看java堆？"><a href="#从垃圾回收的角度看java堆？" class="headerlink" title="从垃圾回收的角度看java堆？"></a>从垃圾回收的角度看java堆？</h2><ul><li><p><strong>java堆从垃圾回收的角度上可以分为新生代和老年代</strong></p><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/172817/23/19826/38200/60f27e1eEb41c1672/5997f348a7e5fef9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><h3 id="具体说一下新生代和老年代？"><a href="#具体说一下新生代和老年代？" class="headerlink" title="具体说一下新生代和老年代？"></a>具体说一下新生代和老年代？</h3></li></ul></li><li><p><strong>新生代用来存放的是新分配的对象。经过垃圾回收没有回收掉的对象会被复制到老年代</strong></p></li><li><p><strong>老年代上的对象比新生代对象时间长，大对象直接进入老年代</strong></p></li><li><p><strong>以前的永久代已经被取代为元空间，不在虚拟机里，直接是本地内存</strong></p></li></ul><hr><h2 id="如何通过栈上的引用对象访问堆上的实例呢"><a href="#如何通过栈上的引用对象访问堆上的实例呢" class="headerlink" title="如何通过栈上的引用对象访问堆上的实例呢"></a>如何通过栈上的引用对象访问堆上的实例呢</h2><blockquote><ul><li><strong>主流有两种访问方式，一个是句柄池，另一个是直接指针</strong><ul><li><strong>句柄池：在java堆中划分一部分内存作为句柄池，包含指向实例数据和对象类型数据的指针，reference存储句柄池的地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/193984/7/13445/63957/60f28159E949248bb/1a210ba372c20357.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>直接指针：reference直接存储对象地址，实例对象包含对象类型数据的地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/172188/22/20053/78857/60f2833cE26949bb1/e6e29c6b872144d2.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-2-JVM体系结构概览&quot;&gt;&lt;a href=&quot;#2-2-JVM体系结构概览&quot; class=&quot;headerlink&quot; title=&quot;2.2 JVM体系结构概览&quot;&gt;&lt;/a&gt;2.2 JVM体系结构概览&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=&quot;lazyload pl</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第2章 Java并行程序基础</title>
    <link href="https://mactql.github.io/posts/1877506347.html"/>
    <id>https://mactql.github.io/posts/1877506347.html</id>
    <published>2021-07-08T07:27:00.000Z</published>
    <updated>2021-07-08T07:32:31.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-进程和线程"><a href="#2-1-进程和线程" class="headerlink" title="2.1 进程和线程"></a>2.1 进程和线程</h2><ul><li><strong>进程是独立运行、资源分配的基本单位，程序运行起来就是进程</strong></li><li><strong>线程是资源调度的基本单位，一个进程可以有多个线程</strong></li></ul><h3 id="线程的生命周期如下："><a href="#线程的生命周期如下：" class="headerlink" title="线程的生命周期如下："></a>线程的生命周期如下：</h3><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/183619/38/12549/74295/60e2632cEb819b275/319a62e48ed7704f.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><blockquote><ul><li><strong>New状态表示刚刚创建的线程，还没开始执行，要start（）方法调用后才执行</strong></li><li><strong>线程执行时是RUNNABLE状态，表示一切资源都准备好了</strong></li><li><strong>如果遇到synchronized同步块，则会被阻塞BLOCKED</strong></li><li><strong>当线程中调用wait、join方法时，当前线程就会进入等待态WAITING，等待notify方法唤醒</strong></li><li><strong>当线程中调用wait(time)等方法时，当前线程就会进入有限时间等待态TIMED_WAITING</strong></li><li><strong>线程执行完毕后，就会进入TEAMINATED态</strong></li></ul></blockquote><hr><h2 id="新建线程的方法："><a href="#新建线程的方法：" class="headerlink" title="新建线程的方法："></a>新建线程的方法：</h2><ul><li><strong>参考文献：<a href="https://zhuanlan.zhihu.com/p/144694652">创建线程的方法</a></strong></li><li><strong>本质是两种方法</strong><ul><li><strong>继承 Thread 类 或者直接 匿名内部类</strong></li><li><strong>实现 Runnable 接口</strong></li></ul></li><li><strong>还有其他很多表现形式，但本质都是上面两种</strong><ul><li><strong>通过 ExecutorService 和 Callable 实现有返回值的线程 (这里仅作了解)</strong></li><li><strong>基于线程池的execute()，创建临时线程 (这里仅作了解)</strong></li></ul></li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line">ThreadDemo t1 = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable 接口创建线程类 ThreadDemo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程对象,传入Runnable实现类实例</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo());</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h3 id="通过-ExecutorService-和-Callable-实现有返回值的线程"><a href="#通过-ExecutorService-和-Callable-实现有返回值的线程" class="headerlink" title="通过 ExecutorService 和 Callable 实现有返回值的线程"></a><strong>通过 ExecutorService 和 Callable 实现有返回值的线程</strong></h3><ul><li><strong>我们需要在主线程中开启多个线程去执行一个任务，然后收集各个线程的返回结果并将最终结果进行汇总，这时就需要用到 Callable 接口</strong></li><li><strong>如果不需要返回值，仍然可以用Runnable</strong></li><li><strong>线程的返回结果为Future对象，isDone方法判断线程是否完成，get方法获取结果</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过实现Callable接口来创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CThread</span><span class="params">(String name )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写call()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建接收结果的列表集合</span></span><br><span class="line">List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">    <span class="comment">//创建线程对象</span></span><br><span class="line">    Callable c = <span class="keyword">new</span> CThread(<span class="string">&quot;线程&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将线程对象提交到线程池中，并将返回结果接收</span></span><br><span class="line">    Future future = pool.submit(c);</span><br><span class="line">    System.out.println(<span class="string">&quot;线程&quot;</span>+i+<span class="string">&quot;已经加入线程池&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将返回结果加入集合</span></span><br><span class="line">    list.add(future);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印返回结果</span></span><br><span class="line"><span class="keyword">for</span> (Future future : list) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get().toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="启动线程："><a href="#启动线程：" class="headerlink" title="启动线程："></a>启动线程：</h3><blockquote><ul><li><strong>start方法是新建线程并启动线程</strong></li><li><strong>run方法是启动当前线程，不会开启新线程</strong></li></ul></blockquote><hr><h2 id="线程终止和中断"><a href="#线程终止和中断" class="headerlink" title="线程终止和中断"></a>线程终止和中断</h2><ul><li><strong>终止线程不要用stop方法，会出现数据不一致问题</strong></li><li><strong>线程中断的方法：</strong><ul><li><strong>用interrupt，并且在while循环中通过if判断中断标志位即可</strong></li><li><strong>Thread.sleep(time)，让线程休眠</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程被中断。&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="2-3-初识volatile"><a href="#2-3-初识volatile" class="headerlink" title="2.3 初识volatile"></a>2.3 初识volatile</h2><blockquote><p><strong>作用：</strong></p><ul><li><strong>volatile是同步机制。读volatile变量之前，会让本地缓存失效，必须去主存中读最新值。写volatile变量会直接刷新到主存</strong></li><li><strong>volatile可以禁止指令重排</strong></li></ul><p><strong>缺点：不能保证i++的原子性</strong></p></blockquote><hr><h2 id="2-5-守护线程"><a href="#2-5-守护线程" class="headerlink" title="2.5 守护线程"></a>2.5 守护线程</h2><ul><li><strong>在线程start之前，setDaemon(true)方法可以设置守护线程</strong></li><li><strong>守护线程会在父线程结束后自动结束</strong></li></ul><hr><h2 id="2-7-初识synchronized"><a href="#2-7-初识synchronized" class="headerlink" title="2.7 初识synchronized"></a>2.7 初识synchronized</h2><h3 id="synchronized的作用："><a href="#synchronized的作用：" class="headerlink" title="synchronized的作用："></a>synchronized的作用：</h3><blockquote><ul><li><strong>和volatile一样都是为了实现线程安全，但是volatile不能真正做到线程安全，因为不能保证原子性</strong></li><li><strong>于是就有了synchronzied，用来实现线程同步。会对同步的代码加锁，只允许一个线程进入同步块</strong></li></ul></blockquote><h3 id="synchronized怎么用？"><a href="#synchronized怎么用？" class="headerlink" title="synchronized怎么用？"></a>synchronized怎么用？</h3><ul><li><p><strong>synchronized有三种用法：</strong></p><ul><li><p><strong>给对象加锁:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>给实例非静态方法加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(); <span class="comment">//在run方法内部调用synchronized非静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>给静态方法加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(); <span class="comment">//在run方法内部调用synchronized静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>synchrozied三种用法总结：</strong></p><ul><li><strong>对象锁和非静态方法都要用同一个Runnable实例创建线程，这样对同一个实例对象加锁，才能实现多线程的同步</strong></li><li><strong>静态方法实际上是对类加锁，所以即使是不同的Runnable实例，只要是同一个类，即可完成线程同步</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-1-进程和线程&quot;&gt;&lt;a href=&quot;#2-1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;2.1 进程和线程&quot;&gt;&lt;/a&gt;2.1 进程和线程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程是独立运行、资源分配的基本单位，程序运行起来就是进程</summary>
      
    
    
    
    <category term="《Java高并发程序设计》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java并发" scheme="https://mactql.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第1章 走进并行世界</title>
    <link href="https://mactql.github.io/posts/2486601876.html"/>
    <id>https://mactql.github.io/posts/2486601876.html</id>
    <published>2021-07-04T08:42:00.000Z</published>
    <updated>2021-07-04T08:48:59.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-2-1-同步-异步、阻塞-非阻塞式调用"><a href="#1-2-1-同步-异步、阻塞-非阻塞式调用" class="headerlink" title="1.2.1 同步/异步、阻塞/非阻塞式调用"></a>1.2.1 同步/异步、阻塞/非阻塞式调用</h2><blockquote><ul><li><strong>同步异步关注的是调用完成时消息的通知方式</strong><ul><li><strong>同步是调用方一直问询发现完成</strong></li><li><strong>异步是一调用就立即返回，被调用方完成后会通知调用方已完成</strong></li></ul></li></ul></blockquote><p><strong><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-c8953552c4bbe4ab31d570b31680726e_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><blockquote><ul><li><strong>阻塞非阻塞关注的是发出请求到调用完成之间调用方的状态</strong><ul><li><strong>等待数据返回时设置为挂起态则为阻塞，不是挂起态则非阻塞</strong></li></ul></li></ul></blockquote><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-6507ab3517814b1b84fbff9a3eb31842_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><blockquote><ul><li><strong>举个例子：</strong><ul><li><strong>老张把水壶放到火上，立等水开。（同步阻塞）</strong></li><li><strong>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）</strong></li><li><strong>老张把响水壶放到火上，立等水开。（异步阻塞）</strong></li><li><strong>老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</strong></li></ul></li></ul></blockquote><hr><h2 id="1-2-2-并发和并行"><a href="#1-2-2-并发和并行" class="headerlink" title="1.2.2 并发和并行"></a>1.2.2 并发和并行</h2><ul><li><strong>并发指的是多个进程宏观上同时进行，微观上交替进行</strong></li><li><strong>并行是真的多个进程同时执行，只存在于多CPU的系统中，有几个CPU就能并行几个线程</strong></li></ul><hr><h2 id="1-2-3-临界区"><a href="#1-2-3-临界区" class="headerlink" title="1.2.3 临界区"></a>1.2.3 临界区</h2><ul><li><strong>临界区是访问临界资源的代码段，每一次只能一个线程使用，其他线程等待</strong></li></ul><hr><h2 id="1-2-5-死锁、饥饿、活锁"><a href="#1-2-5-死锁、饥饿、活锁" class="headerlink" title="1.2.5 死锁、饥饿、活锁"></a>1.2.5 死锁、饥饿、活锁</h2><ul><li><strong>死锁：至少两个进程/线程一起死锁，都处于阻塞态</strong></li><li><strong>饥饿：进程/线程一直无法获得资源，例如优先级太低一直排不到它</strong></li></ul><hr><h2 id="1-5-java内存模型（JMM）"><a href="#1-5-java内存模型（JMM）" class="headerlink" title="1.5 java内存模型（JMM）"></a>1.5 java内存模型（JMM）</h2><ul><li><strong>原子性：多线程执行时，每个线程执行完之前不能被其他线程干扰（例如在32位系统多线程写long数据）</strong></li><li><strong>可见性：一个线程修改了共享变量的值，其他线程能否立即知道这个修改</strong></li><li><strong>有序性：在并发时，指令重排导致程序的执行可能就会出现乱序</strong></li></ul><h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/179590/20/12542/217760/60e166d7E2012bb7e/572e1bf3a2494979.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>堆：运行时动态的分配内存大小，垃圾回收</strong></li><li><strong>栈：存在栈中的数据可以共享，主要存放基本数据类型</strong></li><li><strong>如图所示，如果两个线程同时调用了同一个对象Object3，都可以访问这个对象的成员变量，但是线程拥有的是对象的私有拷贝，保存在线程的本地内存中，然后再写回内存中，但是这样会出错，需要保证原子性可见性有序性，需要JMM</strong></li></ul><hr><h2 id="1-5-4-Happen-Before规则"><a href="#1-5-4-Happen-Before规则" class="headerlink" title="1.5.4 Happen-Before规则"></a>1.5.4 Happen-Before规则</h2><p><strong>参考文献：</strong>   <a href="https://zhuanlan.zhihu.com/p/126275344">知乎原文</a></p><ol><li><strong>程序顺序原则：一个线程内根据代码顺序执行</strong></li><li><strong>锁原则：解锁（unlock）要在加锁（lock）之前</strong></li></ol><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/178159/15/12705/185557/60e16f07Eb88abc9f/db76f74baff73153.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ol start="3"><li><strong>volatile规则：volatile变量的写要在读之前，结合第四条传递性一起看</strong></li><li><strong>传递性：A先于B，B先于C，则A必然先于C</strong></li></ol><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/190326/18/11645/76630/60e170b2E2dc2acb6/5a441ab952fe5a9b.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><br><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/185824/18/12742/225582/60e17159Ef4a811f4/eea05b6cd1ea0969.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ol start="5"><li><strong>start()原则：主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作</strong></li><li><strong>join()原则：线程 A 调用线程 B.join()让线程B插到A前面，那么线程B的任何操作都要先于A</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-2-1-同步-异步、阻塞-非阻塞式调用&quot;&gt;&lt;a href=&quot;#1-2-1-同步-异步、阻塞-非阻塞式调用&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 同步/异步、阻塞/非阻塞式调用&quot;&gt;&lt;/a&gt;1.2.1 同步/异步、阻塞/非阻塞式调用&lt;/</summary>
      
    
    
    
    <category term="《Java高并发程序设计》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java并发" scheme="https://mactql.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第7章 确保Web安全的HTTPS</title>
    <link href="https://mactql.github.io/posts/976065235.html"/>
    <id>https://mactql.github.io/posts/976065235.html</id>
    <published>2021-07-03T00:54:00.000Z</published>
    <updated>2021-07-03T00:59:34.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-1-HTTP的缺点："><a href="#7-1-HTTP的缺点：" class="headerlink" title="7.1 HTTP的缺点："></a>7.1 HTTP的缺点：</h2><blockquote><ul><li><strong>用明文通信（不加密），有可能会被窃听</strong></li><li><strong>不验证身份，可能伪装</strong></li><li><strong>无法保证报文的完整性，可能被篡改</strong></li></ul></blockquote><hr><h2 id="7-2-HTTP-加密-认证-完整性保护-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="7.2 HTTP+加密+认证+完整性保护=HTTPS"></a>7.2 HTTP+加密+认证+完整性保护=HTTPS</h2><h3 id="7-2-3-HTTPS是怎么加密的？"><a href="#7-2-3-HTTPS是怎么加密的？" class="headerlink" title="7.2.3 HTTPS是怎么加密的？"></a>7.2.3 HTTPS是怎么加密的？</h3><blockquote><ul><li><strong>对称加密：加密和解密使用同一密钥</strong><ul><li><strong>优点：运算速度快</strong></li><li><strong>缺点：无法安全地将密钥传输给通信方</strong></li></ul></li><li><strong>非对称加密：公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密</strong><ul><li><strong>优点：可以更安全地将公开密钥传输给通信发送方</strong></li><li><strong>缺点：运算速度慢</strong></li></ul></li><li><strong>HTTPS使用的是混合加密方式，有对称加密和非对称加密</strong><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/179946/21/12811/146203/60dfb051Ee0f63dc7/6602dc2628972ddf.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li></ul></blockquote><h2 id="7-2-4-认证"><a href="#7-2-4-认证" class="headerlink" title="7.2.4 认证"></a>7.2.4 认证</h2><h4 id="首先为什么要认证？"><a href="#首先为什么要认证？" class="headerlink" title="首先为什么要认证？"></a>首先为什么要认证？</h4><ul><li><strong>为了保证对称加密的公开密钥没有被攻击者替换，这就要用到认证</strong></li></ul><h4 id="如何认证？"><a href="#如何认证？" class="headerlink" title="如何认证？"></a>如何认证？</h4><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/173987/39/17987/253550/60dfb2abEcc926303/7afefaf1b5014ae7.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;7-1-HTTP的缺点：&quot;&gt;&lt;a href=&quot;#7-1-HTTP的缺点：&quot; class=&quot;headerlink&quot; title=&quot;7.1 HTTP的缺点：&quot;&gt;&lt;/a&gt;7.1 HTTP的缺点：&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用明文</summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第4章 返回结果的HTTP状态码</title>
    <link href="https://mactql.github.io/posts/1773229755.html"/>
    <id>https://mactql.github.io/posts/1773229755.html</id>
    <published>2021-07-02T07:10:00.000Z</published>
    <updated>2021-07-02T07:14:52.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-状态码的分类"><a href="#4-1-状态码的分类" class="headerlink" title="4.1 状态码的分类"></a>4.1 状态码的分类</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/186965/26/11407/111567/60deaf6bE2a15aa4e/598cf017ef7700cc.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 <code>2XX</code> 成功</h2><ul><li><strong><code>200</code> ：表示从客户端发来的请求被正常处理，并返回数据</strong></li><li><strong><code>204</code> ：和<code>200</code>一样，但是不返回任何数据，只返回是否成功</strong></li><li><strong><code>206</code> ：表示客户端进行的范围请求被正常处理，并返回数据</strong></li></ul><hr><h2 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 <code>3XX</code> 重定向</h2><ul><li><strong><code>301</code> ：永久性重定向，请求的资源被分配到新的URI，浏览器输入的网址会瞬间跳转到新URI，原先的网址不可用</strong></li><li><strong><code>302</code> ：临时性重定向，请求的资源被分配到新的URI，浏览器输入的网址会瞬间跳转到新URI，原先的网址仍可用</strong></li><li><strong><code>303</code> ：把POST提交重定向到GET，例如POST一份个人信息，服务器返回<code>303</code>，重定向到一个上传成功的页面</strong></li><li><strong><code>307</code> ：和<code>302</code>一摸一样，但是不允许POST到GET的重定向</strong></li></ul><hr><h2 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 <code>4XX</code> 客户端错误</h2><ul><li><strong><code>400</code> ：表示HTTP请求报文中有语法错误</strong></li><li><strong><code>401</code> ：表示HTTP请求需要登陆认证，或者认证失败</strong></li><li><strong><code>403</code> ：表示需要的资源没有权限访问</strong></li><li><strong><code>404</code> ：表示需要访问的资源不存在</strong></li></ul><hr><h2 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 <code>5XX</code> 服务器错误</h2><ul><li><strong><code>501</code> ：服务器执行请求时发生错误</strong></li><li><strong><code>503</code> ：服务器处于超负载或停机维护</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-1-状态码的分类&quot;&gt;&lt;a href=&quot;#4-1-状态码的分类&quot; class=&quot;headerlink&quot; title=&quot;4.1 状态码的分类&quot;&gt;&lt;/a&gt;4.1 状态码的分类&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=&quot;lazyload placeholder&quot; d</summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第2章 简单的HTTP协议</title>
    <link href="https://mactql.github.io/posts/53019385.html"/>
    <id>https://mactql.github.io/posts/53019385.html</id>
    <published>2021-07-02T02:27:00.000Z</published>
    <updated>2021-07-02T02:29:28.926Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="2-2-HTTP请求和响应报文格式"><a href="#2-2-HTTP请求和响应报文格式" class="headerlink" title="2.2 HTTP请求和响应报文格式"></a>2.2 HTTP请求和响应报文格式</h2><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/180478/2/12183/160617/60de6ccaE6ddb17a3/758649c3c46df958.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="2-5-常用HTTP方法有哪些？"><a href="#2-5-常用HTTP方法有哪些？" class="headerlink" title="2.5 常用HTTP方法有哪些？"></a>2.5 常用HTTP方法有哪些？</h2><blockquote><ul><li><strong>GET：请求访问服务器某个资源</strong></li><li><strong>POST：和GET对应，传输某个资源</strong></li><li><strong>PUT：传输某个文件</strong></li><li><strong>HEAD：与GET相同，但只想获得报文首部，不返回数据，例如想要查询某个资源是否存在，不需要获取数据</strong></li><li><strong>DELETE：删除服务器某个资源</strong></li><li><strong>OPTIONS：查询URI某个资源支持的方法，例如返回GET、POST</strong></li></ul></blockquote><hr><h2 id="2-8-Cookie"><a href="#2-8-Cookie" class="headerlink" title="2.8 Cookie"></a>2.8 Cookie</h2><h3 id="为什么要cookie？"><a href="#为什么要cookie？" class="headerlink" title="为什么要cookie？"></a>为什么要cookie？</h3><p>要求登陆认证的web页面无法保存登陆状态，每次跳转页面都要再次登陆，为了避免这种频繁登陆，需要cookie保存登陆状态</p><h3 id="怎么使用cookie？"><a href="#怎么使用cookie？" class="headerlink" title="怎么使用cookie？"></a>怎么使用cookie？</h3><ul><li><strong>第一次登陆后，服务器返回响应，响应报文中添加一个cookie通知客户端保存cookie</strong></li><li><strong>以后每次请求，在报文中都添加一个cookie值，服务器检查cookie值的记录，有的话就不需要登陆了</strong></li></ul><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/190040/20/11105/187775/60de788dE6941cef1/6043b1e603cef490.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;2-2-HTTP请求和响应报文格式&quot;&gt;&lt;a href=&quot;#2-2-HTTP请求和响应报文格式&quot; class=&quot;headerlink&quot; title=&quot;2.2 HTTP请求和响应报文格式&quot;&gt;&lt;/a&gt;2.2 HTTP请求和响应报文格式&lt;/h2&gt;&lt;p&gt;&lt;img </summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第1章 了解Web及网络基础</title>
    <link href="https://mactql.github.io/posts/3376318152.html"/>
    <id>https://mactql.github.io/posts/3376318152.html</id>
    <published>2021-07-01T12:38:00.000Z</published>
    <updated>2021-07-01T12:56:18.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-3-3-TCP-IP通信是怎么传输的？"><a href="#1-3-3-TCP-IP通信是怎么传输的？" class="headerlink" title="1.3.3 TCP/IP通信是怎么传输的？"></a>1.3.3 TCP/IP通信是怎么传输的？</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/175791/30/17454/177642/60dd6f1fE8814f6d1/ad21adf93aa8afe2.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><blockquote><ul><li><strong>从下到上以此是链路层、网络层、传输层、应用层</strong><ul><li><strong>第一个是链路层，解析的是以太网首部，包含源MAC地址和目标MAC地址</strong><ul><li><strong>在一个网络之内，也就是一”跳”之内进行MAC转发，具体看 <a href="https://mactql.github.io/posts/165302757.html#3-2-4-%E6%80%8E%E4%B9%88%E6%A0%B9%E6%8D%AEMAC%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8F%91%EF%BC%9F">怎么根据MAC地址转发</a></strong></li></ul></li><li><strong>第二个是网络层，解析的是IP首部，包含源IP地址和目标IP地址</strong><ul><li><strong>首先通过ARP查找下一”跳”对应的MAC地址，然后通过链路层实现在每一”跳”之间通信，最终和目标通信，具体看 <a href="https://mactql.github.io/posts/837272352.html#5-3-ARP">ARP是什么</a></strong></li></ul></li><li><strong>第三个是传输层，解析的是TCP首部，包含源进程端口号和目标进程端口号</strong><ul><li><strong>将大块数据分成多个报文段，并发起TCP三次握手，具体看 <a href="https://mactql.github.io/posts/3865951273.html#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%EF%BC%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%89">说一下三次握手</a></strong></li></ul></li><li><strong>最后是应用层，DNS解析以及发送HTTP请求</strong></li></ul></li></ul></blockquote><hr><h2 id="1-7-URI和URL"><a href="#1-7-URI和URL" class="headerlink" title="1.7 URI和URL"></a>1.7 URI和URL</h2><blockquote><ul><li><strong>首先URL是URI的子集</strong></li><li><strong>唯一标识网络中的资源就是URI，如果他是一条路径就是URL</strong></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-3-3-TCP-IP通信是怎么传输的？&quot;&gt;&lt;a href=&quot;#1-3-3-TCP-IP通信是怎么传输的？&quot; class=&quot;headerlink&quot; title=&quot;1.3.3 TCP/IP通信是怎么传输的？&quot;&gt;&lt;/a&gt;1.3.3 TCP/IP通信是怎么传输的？&lt;/</summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第18章 java I/O</title>
    <link href="https://mactql.github.io/posts/3136801953.html"/>
    <id>https://mactql.github.io/posts/3136801953.html</id>
    <published>2021-06-30T02:01:00.000Z</published>
    <updated>2021-07-05T13:59:57.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java的IO分为字符流和字节流："><a href="#java的IO分为字符流和字节流：" class="headerlink" title="java的IO分为字符流和字节流："></a>java的IO分为字符流和字节流：</h2><ul><li><strong>字节流一般处理图像数据或字节文件这类的二进制数据，其他数据一般是字符流</strong></li></ul><blockquote><p><strong>字符流：（以输入流为例）</strong></p><ul><li><strong>字符流中最基本的CharArrayReader和StringReader，从字符数组或字符串的数据元中读取字符</strong></li><li><strong>还有三个复杂功能的类：</strong><ul><li><strong>BufferedReader，对原始数据频繁的读会比较慢，可以采用用缓冲区读写，效率更高</strong></li><li><strong>FilterReader抽象类，创建时需要传入一个Reader对象叠加新的功能，可以跳跃字符流中特定字符等操作</strong></li><li><strong>InputStreamReader，把字节流转化为字符流。常用FileReader子类，从字节文件中转化为字符流读取</strong></li></ul></li></ul></blockquote><blockquote><p><strong>字节流：（以输入流为例）</strong></p><ul><li><strong>字符流中最基本的ByteArrayInputStream和FileInputStream，从字节数组或字节文件的数据元中读取字节</strong></li><li><strong>还有复杂功能的类：</strong><ul><li><strong>FilterInputStream抽象类，常用继承它的子类如下：</strong><ul><li><strong>BufferedInputStream，对原始数据读写频繁会很慢，采用从缓冲区不停的读写，效率更高</strong></li><li><strong>DataInputStream和DataOutputStream可以从字节流中读写数据并转换成基本数据类型</strong></li></ul></li></ul></li></ul></blockquote><h2 id="导图如下："><a href="#导图如下：" class="headerlink" title="导图如下："></a>导图如下：</h2><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/184379/15/11818/205478/60dbcff6E9fde4ddb/8a843a85dd6094a9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java的IO分为字符流和字节流：&quot;&gt;&lt;a href=&quot;#java的IO分为字符流和字节流：&quot; class=&quot;headerlink&quot; title=&quot;java的IO分为字符流和字节流：&quot;&gt;&lt;/a&gt;java的IO分为字符流和字节流：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;str</summary>
      
    
    
    
    <category term="《Java编程思想》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java基础" scheme="https://mactql.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>第6章 TCP与UDP</title>
    <link href="https://mactql.github.io/posts/3865951273.html"/>
    <id>https://mactql.github.io/posts/3865951273.html</id>
    <published>2021-06-26T16:00:00.000Z</published>
    <updated>2021-07-21T07:33:55.725Z</updated>
    
    <content type="html"><![CDATA[<p><strong>传输层有两个代表性的协议，TCP和UDP。TCP提供可靠的通信传输，而UDP用于让广播和细节控制交给应用的通信传输</strong></p><h2 id="6-1-1-传输层的定义"><a href="#6-1-1-传输层的定义" class="headerlink" title="6.1.1 传输层的定义"></a>6.1.1 传输层的定义</h2><p><strong>IP首部有一个协议字段，用来标识网络层的上一层所采用的是哪一种的传输层协议，判断数据是TCP内容还是UDP内容</strong></p><h3 id="6-1-2-TCP和UDP是干啥的呢？"><a href="#6-1-2-TCP和UDP是干啥的呢？" class="headerlink" title="6.1.2 TCP和UDP是干啥的呢？"></a>6.1.2 TCP和UDP是干啥的呢？</h3><p><strong>通过IP地址可以找到目标主机的位置，TCP和UDP是用来识别数据要发送给主机上的哪个应用程序，设定了一个端口号。端口号其实类似于程序地址，通过这个端口号可以确定给哪一个应用程序使用</strong></p><h3 id="6-1-4-TCP和UDP哪个好？"><a href="#6-1-4-TCP和UDP哪个好？" class="headerlink" title="6.1.4 TCP和UDP哪个好？"></a>6.1.4 TCP和UDP哪个好？</h3><p><strong>TCP是可靠的面向有连接的通信传输，UDP虽然不可靠，但是主要用于高速传输和实时性要求搞的通信或广播，例如打IP电话，所以TCP和UDP应该按需使用</strong></p><hr><h3 id="6-2-3-如何识别一个通信"><a href="#6-2-3-如何识别一个通信" class="headerlink" title="6.2.3 如何识别一个通信"></a>6.2.3 如何识别一个通信</h3><ul><li><strong>TCP/IP,UDP/IP通信中通过五个信息来识别一个通信：</strong><ul><li><strong>“源IP地址”，“目标IP地址”，“源端口号”，“目标端口号”，“传输协议(TCP/UDP)”。这五个只要有一个不同， 就可认为是两个不同的通信</strong></li></ul></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/196626/29/10182/246739/60d6dc11E792b84c1/cbbfa22ac0896912.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><hr><h2 id="6-3-UDP"><a href="#6-3-UDP" class="headerlink" title="6.3 UDP"></a>6.3 UDP</h2><ul><li><strong>UDP传输不提供复杂的控制机制，它利用IP提供面向无连接的通信服务</strong><ul><li><strong>优点：它的资源消耗小，传输速度快，通常音频，视频在传送时用UDP传输较多</strong></li><li><strong>缺点：UDP报文没有可靠性保证，顺序保证，和流量控制，可靠性比较差，传输过程中出现包丢失不会重发</strong></li></ul></li></ul><h2 id="6-4-TCP"><a href="#6-4-TCP" class="headerlink" title="6.4 TCP"></a>6.4 TCP</h2><ul><li><strong>TCP是一种面向有连接的传输协议</strong></li><li><strong>TCP充分实现数据传输过程中的各种控制，丢包可以重发，可以顺序控制</strong></li><li><strong>TCP首部格式如下：</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/112871/16/18291/156082/60d7da51E00164f2f/5a5ed30832180698.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h3 id="6-4-2-TCP怎么满足可靠性的？"><a href="#6-4-2-TCP怎么满足可靠性的？" class="headerlink" title="6.4.2 TCP怎么满足可靠性的？"></a>6.4.2 TCP怎么满足可靠性的？</h3><p><strong>发送数据后，接收端会返回确认应答的消息ACK。如果发送端没有收到ACK，则说明丢包了会重发</strong><br><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/191382/11/10403/62582/60d7d42fEb4682d07/74bec6fc7e9524fc.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><ul><li><strong>UDP是面向无连接，而TCP是面向有连接。</strong></li><li><strong>所以TCP在通信前，需要先建立两端的连接，即三次握手</strong></li><li><strong>通信后，需要断开连接，即四次挥手</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/177992/24/11421/88469/60d7e2edE463b6e41/da4baac2f7b299a7.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h2 id="说一下三次握手？（建立连接）"><a href="#说一下三次握手？（建立连接）" class="headerlink" title="说一下三次握手？（建立连接）"></a>说一下三次握手？（建立连接）</h2><ul><li><strong>第一次握手：客户端给服务端发送一个SYN包，假设syn=j，并进入SYN_SEND状态，等待服务端确认</strong></li><li><strong>第二次握手：服务端收到SYN包，发送ACK确认应答设置ack=j+1，同时自己也发送一个SYN包，假设syn=k，并进入SYN_RESV状态</strong></li><li><strong>第三次握手：客户端收到服务端的SYN+ACK包，向服务端发送ACK包确认应答ack=k+1，此包发送完毕双方连接完成</strong></li></ul><h2 id="说一下四次挥手？（终止连接）"><a href="#说一下四次挥手？（终止连接）" class="headerlink" title="说一下四次挥手？（终止连接）"></a>说一下四次挥手？（终止连接）</h2><ul><li><strong>第一次挥手：客户端发送一个FIN包给服务端，用来关闭客户端到服务端数据传送</strong></li><li><strong>第二次挥手：服务端收到这个FIN包，就发送一个ACK确认应答给客户端</strong></li><li><strong>第三次挥手：服务端关闭与客户端之间的连接，发送FIN包给客户端</strong></li><li><strong>第四次挥手：客户端收到后，发送一个ACK应答给服务端，此时连接断开</strong></li></ul><h3 id="为什么服务端的ACK和FIN包不能一起发？"><a href="#为什么服务端的ACK和FIN包不能一起发？" class="headerlink" title="为什么服务端的ACK和FIN包不能一起发？"></a>为什么服务端的ACK和FIN包不能一起发？</h3><ul><li><strong>服务器发送ACK后，可能还有数据没有处理完成，要等处理完成后才能发送FIN包</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;传输层有两个代表性的协议，TCP和UDP。TCP提供可靠的通信传输，而UDP用于让广播和细节控制交给应用的通信传输&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-1-1-传输层的定义&quot;&gt;&lt;a href=&quot;#6-1-1-传输层的定义&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="《图解TCP/IP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第5章 IP协议相关技术</title>
    <link href="https://mactql.github.io/posts/837272352.html"/>
    <id>https://mactql.github.io/posts/837272352.html</id>
    <published>2021-06-25T16:00:00.000Z</published>
    <updated>2021-06-29T14:04:01.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-2-DNS"><a href="#5-2-DNS" class="headerlink" title="5.2 DNS"></a>5.2 DNS</h2><p><strong>平时访问网站用IP地址很不方便，一般都是用主机名（域名）</strong><br><strong>为了实现用主机名（域名）替代IP地址的功能，主机会利用hosts数据文件，也就是DNS</strong></p><h3 id="DNS是怎么查询IP地址的？"><a href="#DNS是怎么查询IP地址的？" class="headerlink" title="DNS是怎么查询IP地址的？"></a>DNS是怎么查询IP地址的？</h3><ul><li><strong>首先向最近的DNS服务器查询IP地址，如果有就返回，没有就向根域名服务器查询</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/188784/3/10285/175846/60d5da27E70bb3d0c/788c7379b5553333.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><hr><h2 id="5-3-ARP"><a href="#5-3-ARP" class="headerlink" title="5.3 ARP"></a>5.3 ARP</h2><h3 id="5-3-1-ARP是什么？"><a href="#5-3-1-ARP是什么？" class="headerlink" title="5.3.1 ARP是什么？"></a>5.3.1 ARP是什么？</h3><ul><li><strong>在数据链路层中我们需要查找目标IP地址的MAC地址，可以通过广播发送一个ARP请求包，询问目标IP的MAC地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/182434/3/11078/83772/60d5dc4dE12cf50af/5306723c38908076.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>为了防止每发一次数据就要一次ARP请求，会将MAC地址和IP地址的映射关系缓存在主机中，即ARP缓存表</strong></li></ul><h3 id="5-3-3-IP地址和MAC地址为什么缺一不可？"><a href="#5-3-3-IP地址和MAC地址为什么缺一不可？" class="headerlink" title="5.3.3 IP地址和MAC地址为什么缺一不可？"></a>5.3.3 IP地址和MAC地址为什么缺一不可？</h3><ul><li><strong>首先在第4章 IP协议中的4.1.2说明了网络层和数据链路层为什么缺一不可</strong></li><li><strong>主机A和主机B如果不在同一个数据链路中，也就是不在同一个网段，主机A想要发送数据给主机B，必须要经过路由器。如果只知道主机A和主机B的MAC地址，主机A在自己的网段中找不到主机B的MAC，便会发送数据给路由器，但是这时候如果没有IP协议和ARP地址解析协议，是无法进行路由控制，获取路由器的MAC，这样主机A的数据就到达不了路由器，更到达不了主机B</strong></li></ul><h3 id="5-3-4-RARP"><a href="#5-3-4-RARP" class="headerlink" title="5.3.4 RARP"></a>5.3.4 RARP</h3><p><strong>和ARP相反，通过自己的MAC地址查询自己的IP地址</strong></p><hr><h2 id="5-4-ICMP"><a href="#5-4-ICMP" class="headerlink" title="5.4 ICMP"></a>5.4 ICMP</h2><h3 id="5-4-1-ICMP是什么？"><a href="#5-4-1-ICMP是什么？" class="headerlink" title="5.4.1 ICMP是什么？"></a>5.4.1 ICMP是什么？</h3><ul><li><strong>在IP通信中，如果因为某种原因没到目的地，那么目的地的路由器就会发一个ICMP包，包中有发生问题的原因</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/175355/24/16654/103299/60d6833bE555ce6c8/a123d6fbb4e5a9f4.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><hr><h2 id="5-5-DHCP"><a href="#5-5-DHCP" class="headerlink" title="5.5 DHCP"></a>5.5 DHCP</h2><p><strong>DHCP是用来自动分配IP地址的</strong></p><hr><h2 id="5-6-NAT"><a href="#5-6-NAT" class="headerlink" title="5.6 NAT"></a>5.6 NAT</h2><p><strong>NAT是用来对本地网络的私有IP地址和互联网的全局IP地址相互转换</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;5-2-DNS&quot;&gt;&lt;a href=&quot;#5-2-DNS&quot; class=&quot;headerlink&quot; title=&quot;5.2 DNS&quot;&gt;&lt;/a&gt;5.2 DNS&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;平时访问网站用IP地址很不方便，一般都是用主机名（域名）&lt;/strong&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="《图解TCP/IP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第4章 IP协议</title>
    <link href="https://mactql.github.io/posts/2555026619.html"/>
    <id>https://mactql.github.io/posts/2555026619.html</id>
    <published>2021-06-24T16:00:00.000Z</published>
    <updated>2021-06-29T14:03:47.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-1-IP相当于OSI模型的网络层"><a href="#4-1-1-IP相当于OSI模型的网络层" class="headerlink" title="4.1.1 IP相当于OSI模型的网络层"></a>4.1.1 IP相当于OSI模型的网络层</h2><p><strong>数据链路层中通过MAC地址来识别同一个链路中不同主机，而一旦跨越多种数据链路就要用到网络层，而IP地址就是用于网络层中区分不同的主机</strong></p><h2 id="4-1-2-网络层和数据链路层的关系"><a href="#4-1-2-网络层和数据链路层的关系" class="headerlink" title="4.1.2 网络层和数据链路层的关系"></a>4.1.2 网络层和数据链路层的关系</h2><ul><li><strong>比如用户A要去地点B旅行：</strong><ul><li><strong>数据链路层就相当于途中每一站的火车票，只能一个个区域移动</strong></li><li><strong>网络层相当于整个旅途的行程表，规划好从A要去B的路线</strong></li></ul></li><li><strong>所以数据链路层和网络层缺一不可，没有数据链路相当于没有车票就无法去往目的地，没有网络层就不知道每一站去哪</strong></li></ul><h2 id="4-2-2-路由控制"><a href="#4-2-2-路由控制" class="headerlink" title="4.2.2 路由控制"></a>4.2.2 路由控制</h2><ul><li><strong>首先是”跳”，指的是网络中的一个区间，即同一个数据链路</strong></li><li><strong>数据链路层负责一跳之间的传输，网络层中的路由控制即IP决定下一跳的路径，最终实现目标地址的通信</strong></li></ul><h3 id="路由控制表："><a href="#路由控制表：" class="headerlink" title="路由控制表："></a>路由控制表：</h3><p><strong>每个主机和路由器都维护一张路由控制表，记录各个网络和路由器的配对关系</strong></p><ul><li><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/174139/15/16121/138429/60d53bd3E1490cad1/223862e27edc29c9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul><h2 id="4-2-4-IP属于面向无连接，不需要建立连接即可发送"><a href="#4-2-4-IP属于面向无连接，不需要建立连接即可发送" class="headerlink" title="4.2.4 IP属于面向无连接，不需要建立连接即可发送"></a>4.2.4 IP属于面向无连接，不需要建立连接即可发送</h2><h2 id="4-3-IP地址的基础知识"><a href="#4-3-IP地址的基础知识" class="headerlink" title="4.3 IP地址的基础知识"></a>4.3 IP地址的基础知识</h2><h3 id="4-3-1-IP地址定义"><a href="#4-3-1-IP地址定义" class="headerlink" title="4.3.1 IP地址定义"></a>4.3.1 IP地址定义</h3><p><strong>IP地址是TCP/IP通信时候，用于识别主机和路由器的标识</strong><br><strong>IPV4由32位二进制组成，习惯表示为4个十进制的整数：192.168.1.1</strong></p><h3 id="4-3-2-IP地址由网络地址和主机地址组成"><a href="#4-3-2-IP地址由网络地址和主机地址组成" class="headerlink" title="4.3.2 IP地址由网络地址和主机地址组成"></a>4.3.2 IP地址由网络地址和主机地址组成</h3><p><strong>首先IP地址由网络地址和主机地址组成</strong><br><strong>为了判断网络地址，引入了子网掩码。将IP地址和子网掩码AND运算就可以得到网络地址</strong></p><h3 id="4-3-3-IP地址分类"><a href="#4-3-3-IP地址分类" class="headerlink" title="4.3.3 IP地址分类"></a>4.3.3 IP地址分类</h3><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-7438cb1ba454ffe278f5c2310e69f3aa_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="4-3-6-子网掩码"><a href="#4-3-6-子网掩码" class="headerlink" title="4.3.6 子网掩码"></a>4.3.6 子网掩码</h3><p><strong>子网掩码也是32位的二进制表示，他用1表示IP的网络地址位置，用0表示IP地址主机地址位置，比如C类IP地址子网掩码：11111111 11111111 11111111 00000000</strong></p><h2 id="4-4-路由控制"><a href="#4-4-路由控制" class="headerlink" title="4.4 路由控制"></a>4.4 路由控制</h2><ul><li><strong>每个路由器和主机都有一张路由控制表，记录网络地址和对应的路由器地址</strong></li><li><strong>发送IP数据包时，首先确定包首部的目标IP地址，从路由控制表中查找对应的路由器地址并发送给下一个路由器</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/196104/38/10116/123501/60d582ebEaf339829/f1689f2f210b8e8d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><h2 id="4-5-IP分片"><a href="#4-5-IP分片" class="headerlink" title="4.5 IP分片"></a>4.5 IP分片</h2><p><strong>不同数据链路则MTU就不同。MTU即最大传输单元</strong><br><strong>当IP数据报太大，MTU小，无法在一帧内传输，路由器就会将它分片，传输到主机后，再根据IP首部识别码重组</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-1-1-IP相当于OSI模型的网络层&quot;&gt;&lt;a href=&quot;#4-1-1-IP相当于OSI模型的网络层&quot; class=&quot;headerlink&quot; title=&quot;4.1.1 IP相当于OSI模型的网络层&quot;&gt;&lt;/a&gt;4.1.1 IP相当于OSI模型的网络层&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="《图解TCP/IP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第3章 数据链路</title>
    <link href="https://mactql.github.io/posts/165302757.html"/>
    <id>https://mactql.github.io/posts/165302757.html</id>
    <published>2021-06-24T13:23:00.000Z</published>
    <updated>2021-06-29T14:03:56.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-数据链路有什么用？"><a href="#3-1-数据链路有什么用？" class="headerlink" title="3.1 数据链路有什么用？"></a>3.1 数据链路有什么用？</h2><ul><li><strong>首先传输数据时，物理层和链路层必不可少</strong></li><li><strong>物理层是将电压、电波和二进制0、1进行转换，而数据链路层则把这些二进制集合为一个”帧”的数据块，再传输</strong></li></ul><h2 id="3-2-MAC地址"><a href="#3-2-MAC地址" class="headerlink" title="3.2 MAC地址"></a>3.2 MAC地址</h2><p><strong>每个网卡的MAC地址都是唯一的，用于识别数据链路中互连的节点</strong></p><h2 id="3-2-4-怎么根据MAC地址转发？"><a href="#3-2-4-怎么根据MAC地址转发？" class="headerlink" title="3.2.4 怎么根据MAC地址转发？"></a>3.2.4 怎么根据MAC地址转发？</h2><ul><li><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/192683/17/9895/275450/60d48d88E07e3eceb/d130143a31957709.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p></li><li><p><strong>交换机会记住MAC地址和对应的交换机上的端口号，即MAC地址表和ARP缓存表是不一样的</strong></p><h2 id="3-3-以太网"><a href="#3-3-以太网" class="headerlink" title="3.3 以太网"></a>3.3 以太网</h2><h3 id="以太网帧格式？"><a href="#以太网帧格式？" class="headerlink" title="以太网帧格式？"></a>以太网帧格式？</h3></li><li><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/176740/10/16716/51432/60d48f0cE509259e1/2fad6921e646f5dd.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>类型指的是协议的类型，FCS是用来检测帧是否损坏</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3-1-数据链路有什么用？&quot;&gt;&lt;a href=&quot;#3-1-数据链路有什么用？&quot; class=&quot;headerlink&quot; title=&quot;3.1 数据链路有什么用？&quot;&gt;&lt;/a&gt;3.1 数据链路有什么用？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;首先传输数据时，物理层和</summary>
      
    
    
    
    <category term="《图解TCP/IP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
