<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mactql的博客</title>
  
  
  <link href="https://mactql.github.io/atom.xml" rel="self"/>
  
  <link href="https://mactql.github.io/"/>
  <updated>2021-07-24T08:38:48.982Z</updated>
  <id>https://mactql.github.io/</id>
  
  <author>
    <name>mactql</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第7章 类加载机制</title>
    <link href="https://mactql.github.io/posts/1316463453.html"/>
    <id>https://mactql.github.io/posts/1316463453.html</id>
    <published>2021-07-24T08:26:00.000Z</published>
    <updated>2021-07-24T08:38:48.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类从被加载到JVM到卸载出内存的完整生命周期？"><a href="#类从被加载到JVM到卸载出内存的完整生命周期？" class="headerlink" title="类从被加载到JVM到卸载出内存的完整生命周期？"></a>类从被加载到JVM到卸载出内存的完整生命周期？</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC7%E7%AB%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="说一下各个步骤？"><a href="#说一下各个步骤？" class="headerlink" title="说一下各个步骤？"></a>说一下各个步骤？</h2><h3 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h3><ul><li><strong>查找并加载类文件的二进制数据</strong></li><li><strong>会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的数据的入口</strong></li></ul><h3 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h3><ul><li><strong>把已经读入内存的类的二进制数据放到虚拟机环境中，包括以下步骤：</strong><ul><li><strong>验证：确保被加载类的正确性</strong></li><li><strong>准备：为类的静态变量分配内存，并初始化</strong></li><li><strong>解析：把常量池中的符号引用替换为直接引用</strong></li></ul></li></ul><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化：</strong></h3><ul><li><strong>为类的静态变量赋初值</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类从被加载到JVM到卸载出内存的完整生命周期？&quot;&gt;&lt;a href=&quot;#类从被加载到JVM到卸载出内存的完整生命周期？&quot; class=&quot;headerlink&quot; title=&quot;类从被加载到JVM到卸载出内存的完整生命周期？&quot;&gt;&lt;/a&gt;类从被加载到JVM到卸载出内存的完</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第6章 Class文件结构</title>
    <link href="https://mactql.github.io/posts/3853486135.html"/>
    <id>https://mactql.github.io/posts/3853486135.html</id>
    <published>2021-07-24T02:12:00.000Z</published>
    <updated>2021-07-24T02:15:21.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Class文件？"><a href="#什么是Class文件？" class="headerlink" title="什么是Class文件？"></a>什么是Class文件？</h2><ul><li><strong>Class文件是一组以8字节为单位的字节流，各个数据项目按顺序紧凑排列</strong></li><li><strong>Class文件格式只有两种类型：无符号数和表</strong><ul><li><strong>无符号数是基本数据类型，如u1，u2，u4，u8代表1个字节，2个字节，4个字节，8个字节的无符号数</strong></li><li><strong>表是由多个无符号数和其他表组成的复合数据结构，一般名称以_info结尾</strong></li></ul></li></ul><hr><h2 id="具体说一下Class文件的结构？"><a href="#具体说一下Class文件的结构？" class="headerlink" title="具体说一下Class文件的结构？"></a>具体说一下Class文件的结构？</h2><ul><li><strong>首先头4个字节是魔数，有这4个字节的才是Class文件</strong></li><li><strong>后面第5、6字节是次版本号，第7、8字节是主版本号</strong></li><li><strong>第9字节开始是常量池，每个常量开头第一个字节表示常量池的某个项目标记，按照标记确定是哪个常量类型，第二个字节是长度，根据长度往后找这么多个字节表示常量</strong><ul><li><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC6%E7%AB%A0Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>常量池结束后两个字节代表访问标志，包括这个Class是类还是接口，是不是public，是不是abstract等</strong><ul><li><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC6%E7%AB%A0Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>访问标志之后是类索引、父类索引和接口索引集合</strong></li><li><strong>之后是字段表集合，用来描述类/接口中的变量，包括各种修饰符和引用常量池的常量</strong></li><li><strong>然后是方法表集合，和字段表几乎一样，用来描述类/接口中的方法</strong></li><li><strong>最后是属性表集合，字段表和方法表都可以拥有自己的属性表集合，例如栈深度、变量存储空间、行号等</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是Class文件？&quot;&gt;&lt;a href=&quot;#什么是Class文件？&quot; class=&quot;headerlink&quot; title=&quot;什么是Class文件？&quot;&gt;&lt;/a&gt;什么是Class文件？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Class文件是一组以8字节为单位的字节</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第3章 垃圾回收</title>
    <link href="https://mactql.github.io/posts/121600763.html"/>
    <id>https://mactql.github.io/posts/121600763.html</id>
    <published>2021-07-21T07:27:00.000Z</published>
    <updated>2021-07-21T07:30:58.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="怎么判断对象是否需要回收？"><a href="#怎么判断对象是否需要回收？" class="headerlink" title="怎么判断对象是否需要回收？"></a>怎么判断对象是否需要回收？</h2><blockquote><ul><li><strong>引用计数法：给对象添加一个<code>引用</code>计数器，每有一个地方<code>引用</code>它就+1，<code>引用</code>失效就-1，如果是0则回收。</strong><ul><li><strong>优点：效率高；缺点：无法回收循环<code>引用</code>的对象</strong></li></ul></li><li><strong>可达性分析法：当一个对象到GC Roots对象没有任何<code>引用</code>链，则回收</strong><ul><li><strong>GC Roots对象包括虚拟机栈帧中<code>引用</code>的对象、方法区静态变量/常量<code>引用</code>的对象、Native方法<code>引用</code>的对象</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/184604/33/14082/59596/60f395a6Ecd2724bd/d1c15f01625eb0f3.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li></ul></blockquote><hr><h2 id="那么如何判断对象是否被引用呢？"><a href="#那么如何判断对象是否被引用呢？" class="headerlink" title="那么如何判断对象是否被引用呢？"></a>那么如何判断对象是否被引用呢？</h2><blockquote><ul><li><strong>强引用：类似<code>Object obj = new Object()</code> ，只要强引用存在，就不会回收掉</strong></li><li><strong>软引用：用SoftReference来实现，用来描述还有用但非必需的对象，会在内存溢出之前回收</strong></li><li><strong>弱引用：用WeakReference来实现，用来描述非必需的对象，不管内存够不够在下一次垃圾回收时一定会被回收</strong></li><li><strong>虚引用：用PhantomReference来实现，虚引用的对象无法获得实例，随时都可能回收</strong></li></ul></blockquote><hr><h2 id="垃圾回收算法？"><a href="#垃圾回收算法？" class="headerlink" title="垃圾回收算法？"></a>垃圾回收算法？</h2><blockquote><ul><li><strong>标记-清除法：标记所有要回收的对象，然后回收</strong><ul><li><strong>缺点：效率不高且会产生大量不连续的内存碎片，导致分配大对象时频繁GC</strong></li><li><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/185383/8/14522/53934/60f3d996Ef41bae8f/d83aeb330f503134.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>复制算法：<strong><strong>一般用于新生代，</strong></strong>将内存分成两块，每次只使用一块，每次回收都复制到另一块上，清除原来的空间</strong><ul><li><strong>缺点：内存缩小一半，浪费</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/176921/26/14679/62356/60f3daffEd4c25677/15d4ef96862c0ab5.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li><li><strong>标记整理法：一般用于老年代，和标记清除法一样，但是在标记后先整理，然后再回收</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/43697/29/16010/52898/60f3dc75E1aa9490e/0e7b3d567b1f6e36.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul></blockquote><hr><h2 id="如何真正实现垃圾回收？"><a href="#如何真正实现垃圾回收？" class="headerlink" title="如何真正实现垃圾回收？"></a>如何真正实现垃圾回收？</h2><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/173645/25/20673/66480/60f7b9b6Ec08b96f1/62fb3ab1ee064160.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="具体介绍一下CMS？"><a href="#具体介绍一下CMS？" class="headerlink" title="具体介绍一下CMS？"></a>具体介绍一下CMS？</h3><ul><li><strong>CMS基于标记-清除法，目标为获取最短回收停顿时间的收集器</strong></li><li><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/182782/9/15017/89966/60f7bc62Ec7fa78c8/2c08336b28b74381.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li><li><strong>共分为四个步骤：</strong><ul><li><strong>初始标记：只标记一下GC Roots能连接的对象</strong></li><li><strong>并发标记：GC Roots tracing，即可达性分析</strong></li><li><strong>重新标记：修正并发标记期间因用户线程导致产生变动的对象的标记</strong></li><li><strong>并发清理：并发垃圾回收</strong></li></ul></li><li><strong>CMS优点：不停顿，并发执行。</strong></li><li><strong>缺点：并发执行对CPU资源压力大，且无法处理在处理过程中产生的垃圾，且标记清除法会产生垃圾碎片</strong></li></ul><h3 id="具体介绍一下G1？"><a href="#具体介绍一下G1？" class="headerlink" title="具体介绍一下G1？"></a>具体介绍一下G1？</h3><ul><li><strong>G1是当前垃圾收集器最前沿成果之一，采用标记整理法，且能精确控制停顿时间</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/174570/7/20663/93930/60f7c803Ea2dcff2e/f72746522c8fde5d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><ul><li><strong>和CMS很类似，但是G1会把内存分成多个独立的区域，并根据允许回收的时间优先回收垃圾最多的区域</strong></li></ul></li></ul><hr><h2 id="具体说一下新生代和老年代的对象"><a href="#具体说一下新生代和老年代的对象" class="headerlink" title="具体说一下新生代和老年代的对象"></a>具体说一下新生代和老年代的对象</h2><ul><li><strong>首先大多数情况，对象在新生代Eden区中分配。当Eden区空间不够时，会触发一次Minor GC（新生代GC）</strong></li><li><strong>大对象直接进入到老年代</strong></li><li><strong>长期存活的对象直接进入老年代。</strong><ul><li><strong>对象在Eden区出生并经过一次Minor GC仍然存活且能被Survivor区容纳，会被移动到Survivor区，并且设置年龄为1岁。每熬过一次Minor GC年龄就+1</strong></li><li><strong>如果Survivor区中相同年龄的所有对象大小总和大于Survivor区的一半，那么年龄大于等于该年龄的对象都去老年代</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;怎么判断对象是否需要回收？&quot;&gt;&lt;a href=&quot;#怎么判断对象是否需要回收？&quot; class=&quot;headerlink&quot; title=&quot;怎么判断对象是否需要回收？&quot;&gt;&lt;/a&gt;怎么判断对象是否需要回收？&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第2章 内存分配</title>
    <link href="https://mactql.github.io/posts/815353185.html"/>
    <id>https://mactql.github.io/posts/815353185.html</id>
    <published>2021-07-17T08:02:00.000Z</published>
    <updated>2021-07-18T01:29:05.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-2-JVM体系结构概览"><a href="#2-2-JVM体系结构概览" class="headerlink" title="2.2 JVM体系结构概览"></a>2.2 JVM体系结构概览</h2><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/173588/33/19717/156152/60f17a35Ee1bce496/2e168a5d18d9e86a.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h3 id="运行时数据区包含以下部分"><a href="#运行时数据区包含以下部分" class="headerlink" title="运行时数据区包含以下部分"></a>运行时数据区包含以下部分</h3><blockquote><ul><li><strong>程序计数器：（线程私有）</strong><ul><li><strong>一块较小的内存空间, 用来存储指向下一条指令的地址</strong></li><li><strong>这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域</strong></li></ul></li><li><strong>虚拟机栈：（线程私有）</strong><ul><li><strong>每个方法在执行的同时都会创建一个栈帧</strong></li><li><strong>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</strong></li></ul></li><li><strong>本地方法栈：（线程私有）</strong><ul><li><strong>和虚拟机栈类似，区别为此栈执行的是Native方法</strong></li></ul></li><li><strong>堆：（线程共享）</strong><ul><li><strong>创建的对象实例和数组都保存在堆中</strong></li><li><strong>运行时动态分配内存大小，自动垃圾回收</strong></li></ul></li><li><strong>方法区：（线程共享）</strong><ul><li><strong>用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></li></ul></li></ul></blockquote><hr><h3 id="栈、堆、方法区是怎么交互的？"><a href="#栈、堆、方法区是怎么交互的？" class="headerlink" title="栈、堆、方法区是怎么交互的？"></a>栈、堆、方法区是怎么交互的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMain</span> </span>&#123; <span class="comment">//运行时，JVM把AppMain的信息都放入方法区    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//main成员方法本身放入方法区。    </span></span><br><span class="line">        Sample test1 = <span class="keyword">new</span> Sample( <span class="string">&quot; 测试1 &quot;</span> ); <span class="comment">//test1是引用，所以放到栈区里，Sample是对象应该放到堆里         </span></span><br><span class="line">        test1.printName();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上述代码的JVM执行流程："><a href="#上述代码的JVM执行流程：" class="headerlink" title="上述代码的JVM执行流程："></a>上述代码的JVM执行流程：</h4><ul><li><strong>首先启动了一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中。这一过程称为AppMain类的加载过程。</strong></li><li><strong>接着，JVM定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：Sample test1 = new Sample(“测试1”);</strong><ul><li><strong>Java虚拟机一看，不就是建立一个Sample类的实例吗，简单，于是就直奔方法区（方法区存放已经加载的类的相关信息，如类、静态变量和常量）而去，先找到Sample类的类型信息再说。结果呢，嘿嘿，没找到，这会儿的方法区里还没有Sample类呢（即Sample类的类信息还没有进入方法区中）。可JVM也不是一根筋的笨蛋，于是，它发扬“自己动手，丰衣足食”的作风，立马加载了Sample类， 把Sample类的相关信息存放在了方法区中。</strong></li><li><strong>Sample类的相关信息加载完成后。Java虚拟机做的第一件事情就是在堆中为一个新的Sample类的实例分配内存，这个Sample类的实例持有着指向方法区的Sample类的类型信息的引用（Java中引用就是内存地址）。这里所说的引用，实际上指的是Sample类的类型信息在方法区中的内存地址，其实，就是有点类似于C语言里的指针啦~~，而这个地址呢，就存放了在Sample类的实例的数据区中。</strong></li><li><strong>然后位于“=”前的test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，test1这个局部变量会被JVM添加到执行main()方法的主线程的Java方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，test1这个局部变量持有指向Sample类的实例的引用（即内存地址）。</strong></li></ul></li><li><strong>JVM将继续执行后续指令，执行printName()方法。当JVM执行test1.printName()方法时，JVM根据局部变量test1持有的引用，定位到堆中的Sample类的实例，再根据Sample类的实例持有的引用，定位到方法区中Sample类的类型信息（包括①类，②静态变量，③静态方法，④常量和⑤成员方法），从而获取printName()成员方法的字节码，接着执行printName()成员方法包含的指令。</strong></li></ul><hr><h2 id="从垃圾回收的角度看java堆？"><a href="#从垃圾回收的角度看java堆？" class="headerlink" title="从垃圾回收的角度看java堆？"></a>从垃圾回收的角度看java堆？</h2><ul><li><p><strong>java堆从垃圾回收的角度上可以分为新生代和老年代</strong></p><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/172817/23/19826/38200/60f27e1eEb41c1672/5997f348a7e5fef9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><h3 id="具体说一下新生代和老年代？"><a href="#具体说一下新生代和老年代？" class="headerlink" title="具体说一下新生代和老年代？"></a>具体说一下新生代和老年代？</h3></li></ul></li><li><p><strong>新生代用来存放的是新分配的对象。经过垃圾回收没有回收掉的对象会被复制到老年代</strong></p></li><li><p><strong>老年代上的对象比新生代对象时间长，大对象直接进入老年代</strong></p></li><li><p><strong>以前的永久代已经被取代为元空间，不在虚拟机里，直接是本地内存</strong></p></li></ul><hr><h2 id="如何通过栈上的引用对象访问堆上的实例呢"><a href="#如何通过栈上的引用对象访问堆上的实例呢" class="headerlink" title="如何通过栈上的引用对象访问堆上的实例呢"></a>如何通过栈上的引用对象访问堆上的实例呢</h2><blockquote><ul><li><strong>主流有两种访问方式，一个是句柄池，另一个是直接指针</strong><ul><li><strong>句柄池：在java堆中划分一部分内存作为句柄池，包含指向实例数据和对象类型数据的指针，reference存储句柄池的地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/193984/7/13445/63957/60f28159E949248bb/1a210ba372c20357.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>直接指针：reference直接存储对象地址，实例对象包含对象类型数据的地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/172188/22/20053/78857/60f2833cE26949bb1/e6e29c6b872144d2.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-2-JVM体系结构概览&quot;&gt;&lt;a href=&quot;#2-2-JVM体系结构概览&quot; class=&quot;headerlink&quot; title=&quot;2.2 JVM体系结构概览&quot;&gt;&lt;/a&gt;2.2 JVM体系结构概览&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=&quot;lazyload pl</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第2章 Java并行程序基础</title>
    <link href="https://mactql.github.io/posts/1877506347.html"/>
    <id>https://mactql.github.io/posts/1877506347.html</id>
    <published>2021-07-08T07:27:00.000Z</published>
    <updated>2021-07-08T07:32:31.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-进程和线程"><a href="#2-1-进程和线程" class="headerlink" title="2.1 进程和线程"></a>2.1 进程和线程</h2><ul><li><strong>进程是独立运行、资源分配的基本单位，程序运行起来就是进程</strong></li><li><strong>线程是资源调度的基本单位，一个进程可以有多个线程</strong></li></ul><h3 id="线程的生命周期如下："><a href="#线程的生命周期如下：" class="headerlink" title="线程的生命周期如下："></a>线程的生命周期如下：</h3><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/183619/38/12549/74295/60e2632cEb819b275/319a62e48ed7704f.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><blockquote><ul><li><strong>New状态表示刚刚创建的线程，还没开始执行，要start（）方法调用后才执行</strong></li><li><strong>线程执行时是RUNNABLE状态，表示一切资源都准备好了</strong></li><li><strong>如果遇到synchronized同步块，则会被阻塞BLOCKED</strong></li><li><strong>当线程中调用wait、join方法时，当前线程就会进入等待态WAITING，等待notify方法唤醒</strong></li><li><strong>当线程中调用wait(time)等方法时，当前线程就会进入有限时间等待态TIMED_WAITING</strong></li><li><strong>线程执行完毕后，就会进入TEAMINATED态</strong></li></ul></blockquote><hr><h2 id="新建线程的方法："><a href="#新建线程的方法：" class="headerlink" title="新建线程的方法："></a>新建线程的方法：</h2><ul><li><strong>参考文献：<a href="https://zhuanlan.zhihu.com/p/144694652">创建线程的方法</a></strong></li><li><strong>本质是两种方法</strong><ul><li><strong>继承 Thread 类 或者直接 匿名内部类</strong></li><li><strong>实现 Runnable 接口</strong></li></ul></li><li><strong>还有其他很多表现形式，但本质都是上面两种</strong><ul><li><strong>通过 ExecutorService 和 Callable 实现有返回值的线程 (这里仅作了解)</strong></li><li><strong>基于线程池的execute()，创建临时线程 (这里仅作了解)</strong></li></ul></li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line">ThreadDemo t1 = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable 接口创建线程类 ThreadDemo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程对象,传入Runnable实现类实例</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo());</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h3 id="通过-ExecutorService-和-Callable-实现有返回值的线程"><a href="#通过-ExecutorService-和-Callable-实现有返回值的线程" class="headerlink" title="通过 ExecutorService 和 Callable 实现有返回值的线程"></a><strong>通过 ExecutorService 和 Callable 实现有返回值的线程</strong></h3><ul><li><strong>我们需要在主线程中开启多个线程去执行一个任务，然后收集各个线程的返回结果并将最终结果进行汇总，这时就需要用到 Callable 接口</strong></li><li><strong>如果不需要返回值，仍然可以用Runnable</strong></li><li><strong>线程的返回结果为Future对象，isDone方法判断线程是否完成，get方法获取结果</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过实现Callable接口来创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CThread</span><span class="params">(String name )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写call()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建接收结果的列表集合</span></span><br><span class="line">List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">    <span class="comment">//创建线程对象</span></span><br><span class="line">    Callable c = <span class="keyword">new</span> CThread(<span class="string">&quot;线程&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将线程对象提交到线程池中，并将返回结果接收</span></span><br><span class="line">    Future future = pool.submit(c);</span><br><span class="line">    System.out.println(<span class="string">&quot;线程&quot;</span>+i+<span class="string">&quot;已经加入线程池&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将返回结果加入集合</span></span><br><span class="line">    list.add(future);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印返回结果</span></span><br><span class="line"><span class="keyword">for</span> (Future future : list) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get().toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="启动线程："><a href="#启动线程：" class="headerlink" title="启动线程："></a>启动线程：</h3><blockquote><ul><li><strong>start方法是新建线程并启动线程</strong></li><li><strong>run方法是启动当前线程，不会开启新线程</strong></li></ul></blockquote><hr><h2 id="线程终止和中断"><a href="#线程终止和中断" class="headerlink" title="线程终止和中断"></a>线程终止和中断</h2><ul><li><strong>终止线程不要用stop方法，会出现数据不一致问题</strong></li><li><strong>线程中断的方法：</strong><ul><li><strong>用interrupt，并且在while循环中通过if判断中断标志位即可</strong></li><li><strong>Thread.sleep(time)，让线程休眠</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程被中断。&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="2-3-初识volatile"><a href="#2-3-初识volatile" class="headerlink" title="2.3 初识volatile"></a>2.3 初识volatile</h2><blockquote><p><strong>作用：</strong></p><ul><li><strong>volatile是同步机制。读volatile变量之前，会让本地缓存失效，必须去主存中读最新值。写volatile变量会直接刷新到主存</strong></li><li><strong>volatile可以禁止指令重排</strong></li></ul><p><strong>缺点：不能保证i++的原子性</strong></p></blockquote><hr><h2 id="2-5-守护线程"><a href="#2-5-守护线程" class="headerlink" title="2.5 守护线程"></a>2.5 守护线程</h2><ul><li><strong>在线程start之前，setDaemon(true)方法可以设置守护线程</strong></li><li><strong>守护线程会在父线程结束后自动结束</strong></li></ul><hr><h2 id="2-7-初识synchronized"><a href="#2-7-初识synchronized" class="headerlink" title="2.7 初识synchronized"></a>2.7 初识synchronized</h2><h3 id="synchronized的作用："><a href="#synchronized的作用：" class="headerlink" title="synchronized的作用："></a>synchronized的作用：</h3><blockquote><ul><li><strong>和volatile一样都是为了实现线程安全，但是volatile不能真正做到线程安全，因为不能保证原子性</strong></li><li><strong>于是就有了synchronzied，用来实现线程同步。会对同步的代码加锁，只允许一个线程进入同步块</strong></li></ul></blockquote><h3 id="synchronized怎么用？"><a href="#synchronized怎么用？" class="headerlink" title="synchronized怎么用？"></a>synchronized怎么用？</h3><ul><li><p><strong>synchronized有三种用法：</strong></p><ul><li><p><strong>给对象加锁:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>给实例非静态方法加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(); <span class="comment">//在run方法内部调用synchronized非静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>给静态方法加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(); <span class="comment">//在run方法内部调用synchronized静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>synchrozied三种用法总结：</strong></p><ul><li><strong>对象锁和非静态方法都要用同一个Runnable实例创建线程，这样对同一个实例对象加锁，才能实现多线程的同步</strong></li><li><strong>静态方法实际上是对类加锁，所以即使是不同的Runnable实例，只要是同一个类，即可完成线程同步</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-1-进程和线程&quot;&gt;&lt;a href=&quot;#2-1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;2.1 进程和线程&quot;&gt;&lt;/a&gt;2.1 进程和线程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程是独立运行、资源分配的基本单位，程序运行起来就是进程</summary>
      
    
    
    
    <category term="《Java高并发程序设计》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java并发" scheme="https://mactql.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第1章 走进并行世界</title>
    <link href="https://mactql.github.io/posts/2486601876.html"/>
    <id>https://mactql.github.io/posts/2486601876.html</id>
    <published>2021-07-04T08:42:00.000Z</published>
    <updated>2021-07-04T08:48:59.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-2-1-同步-异步、阻塞-非阻塞式调用"><a href="#1-2-1-同步-异步、阻塞-非阻塞式调用" class="headerlink" title="1.2.1 同步/异步、阻塞/非阻塞式调用"></a>1.2.1 同步/异步、阻塞/非阻塞式调用</h2><blockquote><ul><li><strong>同步异步关注的是调用完成时消息的通知方式</strong><ul><li><strong>同步是调用方一直问询发现完成</strong></li><li><strong>异步是一调用就立即返回，被调用方完成后会通知调用方已完成</strong></li></ul></li></ul></blockquote><p><strong><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-c8953552c4bbe4ab31d570b31680726e_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><blockquote><ul><li><strong>阻塞非阻塞关注的是发出请求到调用完成之间调用方的状态</strong><ul><li><strong>等待数据返回时设置为挂起态则为阻塞，不是挂起态则非阻塞</strong></li></ul></li></ul></blockquote><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-6507ab3517814b1b84fbff9a3eb31842_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><blockquote><ul><li><strong>举个例子：</strong><ul><li><strong>老张把水壶放到火上，立等水开。（同步阻塞）</strong></li><li><strong>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）</strong></li><li><strong>老张把响水壶放到火上，立等水开。（异步阻塞）</strong></li><li><strong>老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</strong></li></ul></li></ul></blockquote><hr><h2 id="1-2-2-并发和并行"><a href="#1-2-2-并发和并行" class="headerlink" title="1.2.2 并发和并行"></a>1.2.2 并发和并行</h2><ul><li><strong>并发指的是多个进程宏观上同时进行，微观上交替进行</strong></li><li><strong>并行是真的多个进程同时执行，只存在于多CPU的系统中，有几个CPU就能并行几个线程</strong></li></ul><hr><h2 id="1-2-3-临界区"><a href="#1-2-3-临界区" class="headerlink" title="1.2.3 临界区"></a>1.2.3 临界区</h2><ul><li><strong>临界区是访问临界资源的代码段，每一次只能一个线程使用，其他线程等待</strong></li></ul><hr><h2 id="1-2-5-死锁、饥饿、活锁"><a href="#1-2-5-死锁、饥饿、活锁" class="headerlink" title="1.2.5 死锁、饥饿、活锁"></a>1.2.5 死锁、饥饿、活锁</h2><ul><li><strong>死锁：至少两个进程/线程一起死锁，都处于阻塞态</strong></li><li><strong>饥饿：进程/线程一直无法获得资源，例如优先级太低一直排不到它</strong></li></ul><hr><h2 id="1-5-java内存模型（JMM）"><a href="#1-5-java内存模型（JMM）" class="headerlink" title="1.5 java内存模型（JMM）"></a>1.5 java内存模型（JMM）</h2><ul><li><strong>原子性：多线程执行时，每个线程执行完之前不能被其他线程干扰（例如在32位系统多线程写long数据）</strong></li><li><strong>可见性：一个线程修改了共享变量的值，其他线程能否立即知道这个修改</strong></li><li><strong>有序性：在并发时，指令重排导致程序的执行可能就会出现乱序</strong></li></ul><h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/179590/20/12542/217760/60e166d7E2012bb7e/572e1bf3a2494979.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>堆：运行时动态的分配内存大小，垃圾回收</strong></li><li><strong>栈：存在栈中的数据可以共享，主要存放基本数据类型</strong></li><li><strong>如图所示，如果两个线程同时调用了同一个对象Object3，都可以访问这个对象的成员变量，但是线程拥有的是对象的私有拷贝，保存在线程的本地内存中，然后再写回内存中，但是这样会出错，需要保证原子性可见性有序性，需要JMM</strong></li></ul><hr><h2 id="1-5-4-Happen-Before规则"><a href="#1-5-4-Happen-Before规则" class="headerlink" title="1.5.4 Happen-Before规则"></a>1.5.4 Happen-Before规则</h2><p><strong>参考文献：</strong>   <a href="https://zhuanlan.zhihu.com/p/126275344">知乎原文</a></p><ol><li><strong>程序顺序原则：一个线程内根据代码顺序执行</strong></li><li><strong>锁原则：解锁（unlock）要在加锁（lock）之前</strong></li></ol><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/178159/15/12705/185557/60e16f07Eb88abc9f/db76f74baff73153.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ol start="3"><li><strong>volatile规则：volatile变量的写要在读之前，结合第四条传递性一起看</strong></li><li><strong>传递性：A先于B，B先于C，则A必然先于C</strong></li></ol><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/190326/18/11645/76630/60e170b2E2dc2acb6/5a441ab952fe5a9b.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><br><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/185824/18/12742/225582/60e17159Ef4a811f4/eea05b6cd1ea0969.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ol start="5"><li><strong>start()原则：主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作</strong></li><li><strong>join()原则：线程 A 调用线程 B.join()让线程B插到A前面，那么线程B的任何操作都要先于A</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-2-1-同步-异步、阻塞-非阻塞式调用&quot;&gt;&lt;a href=&quot;#1-2-1-同步-异步、阻塞-非阻塞式调用&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 同步/异步、阻塞/非阻塞式调用&quot;&gt;&lt;/a&gt;1.2.1 同步/异步、阻塞/非阻塞式调用&lt;/</summary>
      
    
    
    
    <category term="《Java高并发程序设计》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java并发" scheme="https://mactql.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第7章 确保Web安全的HTTPS</title>
    <link href="https://mactql.github.io/posts/976065235.html"/>
    <id>https://mactql.github.io/posts/976065235.html</id>
    <published>2021-07-03T00:54:00.000Z</published>
    <updated>2021-07-03T00:59:34.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-1-HTTP的缺点："><a href="#7-1-HTTP的缺点：" class="headerlink" title="7.1 HTTP的缺点："></a>7.1 HTTP的缺点：</h2><blockquote><ul><li><strong>用明文通信（不加密），有可能会被窃听</strong></li><li><strong>不验证身份，可能伪装</strong></li><li><strong>无法保证报文的完整性，可能被篡改</strong></li></ul></blockquote><hr><h2 id="7-2-HTTP-加密-认证-完整性保护-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="7.2 HTTP+加密+认证+完整性保护=HTTPS"></a>7.2 HTTP+加密+认证+完整性保护=HTTPS</h2><h3 id="7-2-3-HTTPS是怎么加密的？"><a href="#7-2-3-HTTPS是怎么加密的？" class="headerlink" title="7.2.3 HTTPS是怎么加密的？"></a>7.2.3 HTTPS是怎么加密的？</h3><blockquote><ul><li><strong>对称加密：加密和解密使用同一密钥</strong><ul><li><strong>优点：运算速度快</strong></li><li><strong>缺点：无法安全地将密钥传输给通信方</strong></li></ul></li><li><strong>非对称加密：公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密</strong><ul><li><strong>优点：可以更安全地将公开密钥传输给通信发送方</strong></li><li><strong>缺点：运算速度慢</strong></li></ul></li><li><strong>HTTPS使用的是混合加密方式，有对称加密和非对称加密</strong><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/179946/21/12811/146203/60dfb051Ee0f63dc7/6602dc2628972ddf.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li></ul></blockquote><h2 id="7-2-4-认证"><a href="#7-2-4-认证" class="headerlink" title="7.2.4 认证"></a>7.2.4 认证</h2><h4 id="首先为什么要认证？"><a href="#首先为什么要认证？" class="headerlink" title="首先为什么要认证？"></a>首先为什么要认证？</h4><ul><li><strong>为了保证对称加密的公开密钥没有被攻击者替换，这就要用到认证</strong></li></ul><h4 id="如何认证？"><a href="#如何认证？" class="headerlink" title="如何认证？"></a>如何认证？</h4><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/173987/39/17987/253550/60dfb2abEcc926303/7afefaf1b5014ae7.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;7-1-HTTP的缺点：&quot;&gt;&lt;a href=&quot;#7-1-HTTP的缺点：&quot; class=&quot;headerlink&quot; title=&quot;7.1 HTTP的缺点：&quot;&gt;&lt;/a&gt;7.1 HTTP的缺点：&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用明文</summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第4章 返回结果的HTTP状态码</title>
    <link href="https://mactql.github.io/posts/1773229755.html"/>
    <id>https://mactql.github.io/posts/1773229755.html</id>
    <published>2021-07-02T07:10:00.000Z</published>
    <updated>2021-07-02T07:14:52.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-状态码的分类"><a href="#4-1-状态码的分类" class="headerlink" title="4.1 状态码的分类"></a>4.1 状态码的分类</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/186965/26/11407/111567/60deaf6bE2a15aa4e/598cf017ef7700cc.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 <code>2XX</code> 成功</h2><ul><li><strong><code>200</code> ：表示从客户端发来的请求被正常处理，并返回数据</strong></li><li><strong><code>204</code> ：和<code>200</code>一样，但是不返回任何数据，只返回是否成功</strong></li><li><strong><code>206</code> ：表示客户端进行的范围请求被正常处理，并返回数据</strong></li></ul><hr><h2 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 <code>3XX</code> 重定向</h2><ul><li><strong><code>301</code> ：永久性重定向，请求的资源被分配到新的URI，浏览器输入的网址会瞬间跳转到新URI，原先的网址不可用</strong></li><li><strong><code>302</code> ：临时性重定向，请求的资源被分配到新的URI，浏览器输入的网址会瞬间跳转到新URI，原先的网址仍可用</strong></li><li><strong><code>303</code> ：把POST提交重定向到GET，例如POST一份个人信息，服务器返回<code>303</code>，重定向到一个上传成功的页面</strong></li><li><strong><code>307</code> ：和<code>302</code>一摸一样，但是不允许POST到GET的重定向</strong></li></ul><hr><h2 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 <code>4XX</code> 客户端错误</h2><ul><li><strong><code>400</code> ：表示HTTP请求报文中有语法错误</strong></li><li><strong><code>401</code> ：表示HTTP请求需要登陆认证，或者认证失败</strong></li><li><strong><code>403</code> ：表示需要的资源没有权限访问</strong></li><li><strong><code>404</code> ：表示需要访问的资源不存在</strong></li></ul><hr><h2 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 <code>5XX</code> 服务器错误</h2><ul><li><strong><code>501</code> ：服务器执行请求时发生错误</strong></li><li><strong><code>503</code> ：服务器处于超负载或停机维护</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-1-状态码的分类&quot;&gt;&lt;a href=&quot;#4-1-状态码的分类&quot; class=&quot;headerlink&quot; title=&quot;4.1 状态码的分类&quot;&gt;&lt;/a&gt;4.1 状态码的分类&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=&quot;lazyload placeholder&quot; d</summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第2章 简单的HTTP协议</title>
    <link href="https://mactql.github.io/posts/53019385.html"/>
    <id>https://mactql.github.io/posts/53019385.html</id>
    <published>2021-07-02T02:27:00.000Z</published>
    <updated>2021-07-02T02:29:28.926Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="2-2-HTTP请求和响应报文格式"><a href="#2-2-HTTP请求和响应报文格式" class="headerlink" title="2.2 HTTP请求和响应报文格式"></a>2.2 HTTP请求和响应报文格式</h2><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/180478/2/12183/160617/60de6ccaE6ddb17a3/758649c3c46df958.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="2-5-常用HTTP方法有哪些？"><a href="#2-5-常用HTTP方法有哪些？" class="headerlink" title="2.5 常用HTTP方法有哪些？"></a>2.5 常用HTTP方法有哪些？</h2><blockquote><ul><li><strong>GET：请求访问服务器某个资源</strong></li><li><strong>POST：和GET对应，传输某个资源</strong></li><li><strong>PUT：传输某个文件</strong></li><li><strong>HEAD：与GET相同，但只想获得报文首部，不返回数据，例如想要查询某个资源是否存在，不需要获取数据</strong></li><li><strong>DELETE：删除服务器某个资源</strong></li><li><strong>OPTIONS：查询URI某个资源支持的方法，例如返回GET、POST</strong></li></ul></blockquote><hr><h2 id="2-8-Cookie"><a href="#2-8-Cookie" class="headerlink" title="2.8 Cookie"></a>2.8 Cookie</h2><h3 id="为什么要cookie？"><a href="#为什么要cookie？" class="headerlink" title="为什么要cookie？"></a>为什么要cookie？</h3><p>要求登陆认证的web页面无法保存登陆状态，每次跳转页面都要再次登陆，为了避免这种频繁登陆，需要cookie保存登陆状态</p><h3 id="怎么使用cookie？"><a href="#怎么使用cookie？" class="headerlink" title="怎么使用cookie？"></a>怎么使用cookie？</h3><ul><li><strong>第一次登陆后，服务器返回响应，响应报文中添加一个cookie通知客户端保存cookie</strong></li><li><strong>以后每次请求，在报文中都添加一个cookie值，服务器检查cookie值的记录，有的话就不需要登陆了</strong></li></ul><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/190040/20/11105/187775/60de788dE6941cef1/6043b1e603cef490.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;2-2-HTTP请求和响应报文格式&quot;&gt;&lt;a href=&quot;#2-2-HTTP请求和响应报文格式&quot; class=&quot;headerlink&quot; title=&quot;2.2 HTTP请求和响应报文格式&quot;&gt;&lt;/a&gt;2.2 HTTP请求和响应报文格式&lt;/h2&gt;&lt;p&gt;&lt;img </summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第1章 了解Web及网络基础</title>
    <link href="https://mactql.github.io/posts/3376318152.html"/>
    <id>https://mactql.github.io/posts/3376318152.html</id>
    <published>2021-07-01T12:38:00.000Z</published>
    <updated>2021-07-01T12:56:18.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-3-3-TCP-IP通信是怎么传输的？"><a href="#1-3-3-TCP-IP通信是怎么传输的？" class="headerlink" title="1.3.3 TCP/IP通信是怎么传输的？"></a>1.3.3 TCP/IP通信是怎么传输的？</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/175791/30/17454/177642/60dd6f1fE8814f6d1/ad21adf93aa8afe2.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><blockquote><ul><li><strong>从下到上以此是链路层、网络层、传输层、应用层</strong><ul><li><strong>第一个是链路层，解析的是以太网首部，包含源MAC地址和目标MAC地址</strong><ul><li><strong>在一个网络之内，也就是一”跳”之内进行MAC转发，具体看 <a href="https://mactql.github.io/posts/165302757.html#3-2-4-%E6%80%8E%E4%B9%88%E6%A0%B9%E6%8D%AEMAC%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8F%91%EF%BC%9F">怎么根据MAC地址转发</a></strong></li></ul></li><li><strong>第二个是网络层，解析的是IP首部，包含源IP地址和目标IP地址</strong><ul><li><strong>首先通过ARP查找下一”跳”对应的MAC地址，然后通过链路层实现在每一”跳”之间通信，最终和目标通信，具体看 <a href="https://mactql.github.io/posts/837272352.html#5-3-ARP">ARP是什么</a></strong></li></ul></li><li><strong>第三个是传输层，解析的是TCP首部，包含源进程端口号和目标进程端口号</strong><ul><li><strong>将大块数据分成多个报文段，并发起TCP三次握手，具体看 <a href="https://mactql.github.io/posts/3865951273.html#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%EF%BC%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%89">说一下三次握手</a></strong></li></ul></li><li><strong>最后是应用层，DNS解析以及发送HTTP请求</strong></li></ul></li></ul></blockquote><hr><h2 id="1-7-URI和URL"><a href="#1-7-URI和URL" class="headerlink" title="1.7 URI和URL"></a>1.7 URI和URL</h2><blockquote><ul><li><strong>首先URL是URI的子集</strong></li><li><strong>唯一标识网络中的资源就是URI，如果他是一条路径就是URL</strong></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-3-3-TCP-IP通信是怎么传输的？&quot;&gt;&lt;a href=&quot;#1-3-3-TCP-IP通信是怎么传输的？&quot; class=&quot;headerlink&quot; title=&quot;1.3.3 TCP/IP通信是怎么传输的？&quot;&gt;&lt;/a&gt;1.3.3 TCP/IP通信是怎么传输的？&lt;/</summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第18章 java I/O</title>
    <link href="https://mactql.github.io/posts/3136801953.html"/>
    <id>https://mactql.github.io/posts/3136801953.html</id>
    <published>2021-06-30T02:01:00.000Z</published>
    <updated>2021-07-05T13:59:57.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java的IO分为字符流和字节流："><a href="#java的IO分为字符流和字节流：" class="headerlink" title="java的IO分为字符流和字节流："></a>java的IO分为字符流和字节流：</h2><ul><li><strong>字节流一般处理图像数据或字节文件这类的二进制数据，其他数据一般是字符流</strong></li></ul><blockquote><p><strong>字符流：（以输入流为例）</strong></p><ul><li><strong>字符流中最基本的CharArrayReader和StringReader，从字符数组或字符串的数据元中读取字符</strong></li><li><strong>还有三个复杂功能的类：</strong><ul><li><strong>BufferedReader，对原始数据频繁的读会比较慢，可以采用用缓冲区读写，效率更高</strong></li><li><strong>FilterReader抽象类，创建时需要传入一个Reader对象叠加新的功能，可以跳跃字符流中特定字符等操作</strong></li><li><strong>InputStreamReader，把字节流转化为字符流。常用FileReader子类，从字节文件中转化为字符流读取</strong></li></ul></li></ul></blockquote><blockquote><p><strong>字节流：（以输入流为例）</strong></p><ul><li><strong>字符流中最基本的ByteArrayInputStream和FileInputStream，从字节数组或字节文件的数据元中读取字节</strong></li><li><strong>还有复杂功能的类：</strong><ul><li><strong>FilterInputStream抽象类，常用继承它的子类如下：</strong><ul><li><strong>BufferedInputStream，对原始数据读写频繁会很慢，采用从缓冲区不停的读写，效率更高</strong></li><li><strong>DataInputStream和DataOutputStream可以从字节流中读写数据并转换成基本数据类型</strong></li></ul></li></ul></li></ul></blockquote><h2 id="导图如下："><a href="#导图如下：" class="headerlink" title="导图如下："></a>导图如下：</h2><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/184379/15/11818/205478/60dbcff6E9fde4ddb/8a843a85dd6094a9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java的IO分为字符流和字节流：&quot;&gt;&lt;a href=&quot;#java的IO分为字符流和字节流：&quot; class=&quot;headerlink&quot; title=&quot;java的IO分为字符流和字节流：&quot;&gt;&lt;/a&gt;java的IO分为字符流和字节流：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;str</summary>
      
    
    
    
    <category term="《Java编程思想》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java基础" scheme="https://mactql.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>第6章 TCP与UDP</title>
    <link href="https://mactql.github.io/posts/3865951273.html"/>
    <id>https://mactql.github.io/posts/3865951273.html</id>
    <published>2021-06-26T16:00:00.000Z</published>
    <updated>2021-07-21T07:33:55.725Z</updated>
    
    <content type="html"><![CDATA[<p><strong>传输层有两个代表性的协议，TCP和UDP。TCP提供可靠的通信传输，而UDP用于让广播和细节控制交给应用的通信传输</strong></p><h2 id="6-1-1-传输层的定义"><a href="#6-1-1-传输层的定义" class="headerlink" title="6.1.1 传输层的定义"></a>6.1.1 传输层的定义</h2><p><strong>IP首部有一个协议字段，用来标识网络层的上一层所采用的是哪一种的传输层协议，判断数据是TCP内容还是UDP内容</strong></p><h3 id="6-1-2-TCP和UDP是干啥的呢？"><a href="#6-1-2-TCP和UDP是干啥的呢？" class="headerlink" title="6.1.2 TCP和UDP是干啥的呢？"></a>6.1.2 TCP和UDP是干啥的呢？</h3><p><strong>通过IP地址可以找到目标主机的位置，TCP和UDP是用来识别数据要发送给主机上的哪个应用程序，设定了一个端口号。端口号其实类似于程序地址，通过这个端口号可以确定给哪一个应用程序使用</strong></p><h3 id="6-1-4-TCP和UDP哪个好？"><a href="#6-1-4-TCP和UDP哪个好？" class="headerlink" title="6.1.4 TCP和UDP哪个好？"></a>6.1.4 TCP和UDP哪个好？</h3><p><strong>TCP是可靠的面向有连接的通信传输，UDP虽然不可靠，但是主要用于高速传输和实时性要求搞的通信或广播，例如打IP电话，所以TCP和UDP应该按需使用</strong></p><hr><h3 id="6-2-3-如何识别一个通信"><a href="#6-2-3-如何识别一个通信" class="headerlink" title="6.2.3 如何识别一个通信"></a>6.2.3 如何识别一个通信</h3><ul><li><strong>TCP/IP,UDP/IP通信中通过五个信息来识别一个通信：</strong><ul><li><strong>“源IP地址”，“目标IP地址”，“源端口号”，“目标端口号”，“传输协议(TCP/UDP)”。这五个只要有一个不同， 就可认为是两个不同的通信</strong></li></ul></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/196626/29/10182/246739/60d6dc11E792b84c1/cbbfa22ac0896912.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><hr><h2 id="6-3-UDP"><a href="#6-3-UDP" class="headerlink" title="6.3 UDP"></a>6.3 UDP</h2><ul><li><strong>UDP传输不提供复杂的控制机制，它利用IP提供面向无连接的通信服务</strong><ul><li><strong>优点：它的资源消耗小，传输速度快，通常音频，视频在传送时用UDP传输较多</strong></li><li><strong>缺点：UDP报文没有可靠性保证，顺序保证，和流量控制，可靠性比较差，传输过程中出现包丢失不会重发</strong></li></ul></li></ul><h2 id="6-4-TCP"><a href="#6-4-TCP" class="headerlink" title="6.4 TCP"></a>6.4 TCP</h2><ul><li><strong>TCP是一种面向有连接的传输协议</strong></li><li><strong>TCP充分实现数据传输过程中的各种控制，丢包可以重发，可以顺序控制</strong></li><li><strong>TCP首部格式如下：</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/112871/16/18291/156082/60d7da51E00164f2f/5a5ed30832180698.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h3 id="6-4-2-TCP怎么满足可靠性的？"><a href="#6-4-2-TCP怎么满足可靠性的？" class="headerlink" title="6.4.2 TCP怎么满足可靠性的？"></a>6.4.2 TCP怎么满足可靠性的？</h3><p><strong>发送数据后，接收端会返回确认应答的消息ACK。如果发送端没有收到ACK，则说明丢包了会重发</strong><br><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/191382/11/10403/62582/60d7d42fEb4682d07/74bec6fc7e9524fc.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><ul><li><strong>UDP是面向无连接，而TCP是面向有连接。</strong></li><li><strong>所以TCP在通信前，需要先建立两端的连接，即三次握手</strong></li><li><strong>通信后，需要断开连接，即四次挥手</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/177992/24/11421/88469/60d7e2edE463b6e41/da4baac2f7b299a7.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h2 id="说一下三次握手？（建立连接）"><a href="#说一下三次握手？（建立连接）" class="headerlink" title="说一下三次握手？（建立连接）"></a>说一下三次握手？（建立连接）</h2><ul><li><strong>第一次握手：客户端给服务端发送一个SYN包，假设syn=j，并进入SYN_SEND状态，等待服务端确认</strong></li><li><strong>第二次握手：服务端收到SYN包，发送ACK确认应答设置ack=j+1，同时自己也发送一个SYN包，假设syn=k，并进入SYN_RESV状态</strong></li><li><strong>第三次握手：客户端收到服务端的SYN+ACK包，向服务端发送ACK包确认应答ack=k+1，此包发送完毕双方连接完成</strong></li></ul><h2 id="说一下四次挥手？（终止连接）"><a href="#说一下四次挥手？（终止连接）" class="headerlink" title="说一下四次挥手？（终止连接）"></a>说一下四次挥手？（终止连接）</h2><ul><li><strong>第一次挥手：客户端发送一个FIN包给服务端，用来关闭客户端到服务端数据传送</strong></li><li><strong>第二次挥手：服务端收到这个FIN包，就发送一个ACK确认应答给客户端</strong></li><li><strong>第三次挥手：服务端关闭与客户端之间的连接，发送FIN包给客户端</strong></li><li><strong>第四次挥手：客户端收到后，发送一个ACK应答给服务端，此时连接断开</strong></li></ul><h3 id="为什么服务端的ACK和FIN包不能一起发？"><a href="#为什么服务端的ACK和FIN包不能一起发？" class="headerlink" title="为什么服务端的ACK和FIN包不能一起发？"></a>为什么服务端的ACK和FIN包不能一起发？</h3><ul><li><strong>服务器发送ACK后，可能还有数据没有处理完成，要等处理完成后才能发送FIN包</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;传输层有两个代表性的协议，TCP和UDP。TCP提供可靠的通信传输，而UDP用于让广播和细节控制交给应用的通信传输&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-1-1-传输层的定义&quot;&gt;&lt;a href=&quot;#6-1-1-传输层的定义&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="《图解TCP/IP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第5章 IP协议相关技术</title>
    <link href="https://mactql.github.io/posts/837272352.html"/>
    <id>https://mactql.github.io/posts/837272352.html</id>
    <published>2021-06-25T16:00:00.000Z</published>
    <updated>2021-06-29T14:04:01.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-2-DNS"><a href="#5-2-DNS" class="headerlink" title="5.2 DNS"></a>5.2 DNS</h2><p><strong>平时访问网站用IP地址很不方便，一般都是用主机名（域名）</strong><br><strong>为了实现用主机名（域名）替代IP地址的功能，主机会利用hosts数据文件，也就是DNS</strong></p><h3 id="DNS是怎么查询IP地址的？"><a href="#DNS是怎么查询IP地址的？" class="headerlink" title="DNS是怎么查询IP地址的？"></a>DNS是怎么查询IP地址的？</h3><ul><li><strong>首先向最近的DNS服务器查询IP地址，如果有就返回，没有就向根域名服务器查询</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/188784/3/10285/175846/60d5da27E70bb3d0c/788c7379b5553333.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><hr><h2 id="5-3-ARP"><a href="#5-3-ARP" class="headerlink" title="5.3 ARP"></a>5.3 ARP</h2><h3 id="5-3-1-ARP是什么？"><a href="#5-3-1-ARP是什么？" class="headerlink" title="5.3.1 ARP是什么？"></a>5.3.1 ARP是什么？</h3><ul><li><strong>在数据链路层中我们需要查找目标IP地址的MAC地址，可以通过广播发送一个ARP请求包，询问目标IP的MAC地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/182434/3/11078/83772/60d5dc4dE12cf50af/5306723c38908076.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>为了防止每发一次数据就要一次ARP请求，会将MAC地址和IP地址的映射关系缓存在主机中，即ARP缓存表</strong></li></ul><h3 id="5-3-3-IP地址和MAC地址为什么缺一不可？"><a href="#5-3-3-IP地址和MAC地址为什么缺一不可？" class="headerlink" title="5.3.3 IP地址和MAC地址为什么缺一不可？"></a>5.3.3 IP地址和MAC地址为什么缺一不可？</h3><ul><li><strong>首先在第4章 IP协议中的4.1.2说明了网络层和数据链路层为什么缺一不可</strong></li><li><strong>主机A和主机B如果不在同一个数据链路中，也就是不在同一个网段，主机A想要发送数据给主机B，必须要经过路由器。如果只知道主机A和主机B的MAC地址，主机A在自己的网段中找不到主机B的MAC，便会发送数据给路由器，但是这时候如果没有IP协议和ARP地址解析协议，是无法进行路由控制，获取路由器的MAC，这样主机A的数据就到达不了路由器，更到达不了主机B</strong></li></ul><h3 id="5-3-4-RARP"><a href="#5-3-4-RARP" class="headerlink" title="5.3.4 RARP"></a>5.3.4 RARP</h3><p><strong>和ARP相反，通过自己的MAC地址查询自己的IP地址</strong></p><hr><h2 id="5-4-ICMP"><a href="#5-4-ICMP" class="headerlink" title="5.4 ICMP"></a>5.4 ICMP</h2><h3 id="5-4-1-ICMP是什么？"><a href="#5-4-1-ICMP是什么？" class="headerlink" title="5.4.1 ICMP是什么？"></a>5.4.1 ICMP是什么？</h3><ul><li><strong>在IP通信中，如果因为某种原因没到目的地，那么目的地的路由器就会发一个ICMP包，包中有发生问题的原因</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/175355/24/16654/103299/60d6833bE555ce6c8/a123d6fbb4e5a9f4.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><hr><h2 id="5-5-DHCP"><a href="#5-5-DHCP" class="headerlink" title="5.5 DHCP"></a>5.5 DHCP</h2><p><strong>DHCP是用来自动分配IP地址的</strong></p><hr><h2 id="5-6-NAT"><a href="#5-6-NAT" class="headerlink" title="5.6 NAT"></a>5.6 NAT</h2><p><strong>NAT是用来对本地网络的私有IP地址和互联网的全局IP地址相互转换</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;5-2-DNS&quot;&gt;&lt;a href=&quot;#5-2-DNS&quot; class=&quot;headerlink&quot; title=&quot;5.2 DNS&quot;&gt;&lt;/a&gt;5.2 DNS&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;平时访问网站用IP地址很不方便，一般都是用主机名（域名）&lt;/strong&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="《图解TCP/IP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第4章 IP协议</title>
    <link href="https://mactql.github.io/posts/2555026619.html"/>
    <id>https://mactql.github.io/posts/2555026619.html</id>
    <published>2021-06-24T16:00:00.000Z</published>
    <updated>2021-06-29T14:03:47.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-1-IP相当于OSI模型的网络层"><a href="#4-1-1-IP相当于OSI模型的网络层" class="headerlink" title="4.1.1 IP相当于OSI模型的网络层"></a>4.1.1 IP相当于OSI模型的网络层</h2><p><strong>数据链路层中通过MAC地址来识别同一个链路中不同主机，而一旦跨越多种数据链路就要用到网络层，而IP地址就是用于网络层中区分不同的主机</strong></p><h2 id="4-1-2-网络层和数据链路层的关系"><a href="#4-1-2-网络层和数据链路层的关系" class="headerlink" title="4.1.2 网络层和数据链路层的关系"></a>4.1.2 网络层和数据链路层的关系</h2><ul><li><strong>比如用户A要去地点B旅行：</strong><ul><li><strong>数据链路层就相当于途中每一站的火车票，只能一个个区域移动</strong></li><li><strong>网络层相当于整个旅途的行程表，规划好从A要去B的路线</strong></li></ul></li><li><strong>所以数据链路层和网络层缺一不可，没有数据链路相当于没有车票就无法去往目的地，没有网络层就不知道每一站去哪</strong></li></ul><h2 id="4-2-2-路由控制"><a href="#4-2-2-路由控制" class="headerlink" title="4.2.2 路由控制"></a>4.2.2 路由控制</h2><ul><li><strong>首先是”跳”，指的是网络中的一个区间，即同一个数据链路</strong></li><li><strong>数据链路层负责一跳之间的传输，网络层中的路由控制即IP决定下一跳的路径，最终实现目标地址的通信</strong></li></ul><h3 id="路由控制表："><a href="#路由控制表：" class="headerlink" title="路由控制表："></a>路由控制表：</h3><p><strong>每个主机和路由器都维护一张路由控制表，记录各个网络和路由器的配对关系</strong></p><ul><li><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/174139/15/16121/138429/60d53bd3E1490cad1/223862e27edc29c9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul><h2 id="4-2-4-IP属于面向无连接，不需要建立连接即可发送"><a href="#4-2-4-IP属于面向无连接，不需要建立连接即可发送" class="headerlink" title="4.2.4 IP属于面向无连接，不需要建立连接即可发送"></a>4.2.4 IP属于面向无连接，不需要建立连接即可发送</h2><h2 id="4-3-IP地址的基础知识"><a href="#4-3-IP地址的基础知识" class="headerlink" title="4.3 IP地址的基础知识"></a>4.3 IP地址的基础知识</h2><h3 id="4-3-1-IP地址定义"><a href="#4-3-1-IP地址定义" class="headerlink" title="4.3.1 IP地址定义"></a>4.3.1 IP地址定义</h3><p><strong>IP地址是TCP/IP通信时候，用于识别主机和路由器的标识</strong><br><strong>IPV4由32位二进制组成，习惯表示为4个十进制的整数：192.168.1.1</strong></p><h3 id="4-3-2-IP地址由网络地址和主机地址组成"><a href="#4-3-2-IP地址由网络地址和主机地址组成" class="headerlink" title="4.3.2 IP地址由网络地址和主机地址组成"></a>4.3.2 IP地址由网络地址和主机地址组成</h3><p><strong>首先IP地址由网络地址和主机地址组成</strong><br><strong>为了判断网络地址，引入了子网掩码。将IP地址和子网掩码AND运算就可以得到网络地址</strong></p><h3 id="4-3-3-IP地址分类"><a href="#4-3-3-IP地址分类" class="headerlink" title="4.3.3 IP地址分类"></a>4.3.3 IP地址分类</h3><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-7438cb1ba454ffe278f5c2310e69f3aa_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="4-3-6-子网掩码"><a href="#4-3-6-子网掩码" class="headerlink" title="4.3.6 子网掩码"></a>4.3.6 子网掩码</h3><p><strong>子网掩码也是32位的二进制表示，他用1表示IP的网络地址位置，用0表示IP地址主机地址位置，比如C类IP地址子网掩码：11111111 11111111 11111111 00000000</strong></p><h2 id="4-4-路由控制"><a href="#4-4-路由控制" class="headerlink" title="4.4 路由控制"></a>4.4 路由控制</h2><ul><li><strong>每个路由器和主机都有一张路由控制表，记录网络地址和对应的路由器地址</strong></li><li><strong>发送IP数据包时，首先确定包首部的目标IP地址，从路由控制表中查找对应的路由器地址并发送给下一个路由器</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/196104/38/10116/123501/60d582ebEaf339829/f1689f2f210b8e8d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><h2 id="4-5-IP分片"><a href="#4-5-IP分片" class="headerlink" title="4.5 IP分片"></a>4.5 IP分片</h2><p><strong>不同数据链路则MTU就不同。MTU即最大传输单元</strong><br><strong>当IP数据报太大，MTU小，无法在一帧内传输，路由器就会将它分片，传输到主机后，再根据IP首部识别码重组</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-1-1-IP相当于OSI模型的网络层&quot;&gt;&lt;a href=&quot;#4-1-1-IP相当于OSI模型的网络层&quot; class=&quot;headerlink&quot; title=&quot;4.1.1 IP相当于OSI模型的网络层&quot;&gt;&lt;/a&gt;4.1.1 IP相当于OSI模型的网络层&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="《图解TCP/IP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第3章 数据链路</title>
    <link href="https://mactql.github.io/posts/165302757.html"/>
    <id>https://mactql.github.io/posts/165302757.html</id>
    <published>2021-06-24T13:23:00.000Z</published>
    <updated>2021-06-29T14:03:56.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-数据链路有什么用？"><a href="#3-1-数据链路有什么用？" class="headerlink" title="3.1 数据链路有什么用？"></a>3.1 数据链路有什么用？</h2><ul><li><strong>首先传输数据时，物理层和链路层必不可少</strong></li><li><strong>物理层是将电压、电波和二进制0、1进行转换，而数据链路层则把这些二进制集合为一个”帧”的数据块，再传输</strong></li></ul><h2 id="3-2-MAC地址"><a href="#3-2-MAC地址" class="headerlink" title="3.2 MAC地址"></a>3.2 MAC地址</h2><p><strong>每个网卡的MAC地址都是唯一的，用于识别数据链路中互连的节点</strong></p><h2 id="3-2-4-怎么根据MAC地址转发？"><a href="#3-2-4-怎么根据MAC地址转发？" class="headerlink" title="3.2.4 怎么根据MAC地址转发？"></a>3.2.4 怎么根据MAC地址转发？</h2><ul><li><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/192683/17/9895/275450/60d48d88E07e3eceb/d130143a31957709.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p></li><li><p><strong>交换机会记住MAC地址和对应的交换机上的端口号，即MAC地址表和ARP缓存表是不一样的</strong></p><h2 id="3-3-以太网"><a href="#3-3-以太网" class="headerlink" title="3.3 以太网"></a>3.3 以太网</h2><h3 id="以太网帧格式？"><a href="#以太网帧格式？" class="headerlink" title="以太网帧格式？"></a>以太网帧格式？</h3></li><li><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/176740/10/16716/51432/60d48f0cE509259e1/2fad6921e646f5dd.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>类型指的是协议的类型，FCS是用来检测帧是否损坏</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3-1-数据链路有什么用？&quot;&gt;&lt;a href=&quot;#3-1-数据链路有什么用？&quot; class=&quot;headerlink&quot; title=&quot;3.1 数据链路有什么用？&quot;&gt;&lt;/a&gt;3.1 数据链路有什么用？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;首先传输数据时，物理层和</summary>
      
    
    
    
    <category term="《图解TCP/IP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第2章 TCP/IP基础知识</title>
    <link href="https://mactql.github.io/posts/4267583022.html"/>
    <id>https://mactql.github.io/posts/4267583022.html</id>
    <published>2021-06-24T01:45:00.000Z</published>
    <updated>2021-06-29T14:03:40.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-TCP-IP协议具体含义是什么？"><a href="#2-1-TCP-IP协议具体含义是什么？" class="headerlink" title="2.1 TCP/IP协议具体含义是什么？"></a>2.1 TCP/IP协议具体含义是什么？</h2><ul><li><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/179434/14/10976/69551/60d3d3ffE2223d64f/334cac42e28c9f85.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="2-4-TCP-IP分层模型？"><a href="#2-4-TCP-IP分层模型？" class="headerlink" title="2.4 TCP/IP分层模型？"></a>2.4 TCP/IP分层模型？</h2></li><li><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/130799/23/16984/172129/60d3dfe4E30425cc7/89d002a00de3ef48.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="2-5-TCP-IP模型通信实例"><a href="#2-5-TCP-IP模型通信实例" class="headerlink" title="2.5 TCP/IP模型通信实例"></a>2.5 TCP/IP模型通信实例</h2></li><li><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/169177/23/9325/394530/60d3e047Ef27e831c/eb22f13e3ecee896.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-1-TCP-IP协议具体含义是什么？&quot;&gt;&lt;a href=&quot;#2-1-TCP-IP协议具体含义是什么？&quot; class=&quot;headerlink&quot; title=&quot;2.1 TCP/IP协议具体含义是什么？&quot;&gt;&lt;/a&gt;2.1 TCP/IP协议具体含义是什么？&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="《图解TCP/IP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第1章 网络基础知识</title>
    <link href="https://mactql.github.io/posts/3097388358.html"/>
    <id>https://mactql.github.io/posts/3097388358.html</id>
    <published>2021-06-22T16:00:00.000Z</published>
    <updated>2021-06-29T14:03:36.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-协议是什么？"><a href="#1-1-协议是什么？" class="headerlink" title="1.1 协议是什么？"></a>1.1 协议是什么？</h2><ul><li><strong>首先互联网代表协议TCP/IP，包括HTTP、TCP、IP等协议</strong></li><li><strong>两台计算机之间必须支持相同的协议，否则无法通信</strong></li></ul><h2 id="1-3-什么是分组通信（分组交换协议）？"><a href="#1-3-什么是分组通信（分组交换协议）？" class="headerlink" title="1.3 什么是分组通信（分组交换协议）？"></a>1.3 什么是分组通信（分组交换协议）？</h2><p><strong>将大数据分割为一个个叫包的较小单位进行传播，其中通信协议用于规定报文首部应该写入哪些信息、应该如何处理这些信息</strong></p><h2 id="1-4-协议由谁规定？"><a href="#1-4-协议由谁规定？" class="headerlink" title="1.4 协议由谁规定？"></a>1.4 协议由谁规定？</h2><p><strong>OSI模型由ISO定义，而TCP/IP模型由IETF规定</strong></p><h2 id="1-5-OSI参考模型"><a href="#1-5-OSI参考模型" class="headerlink" title="1.5 OSI参考模型"></a>1.5 OSI参考模型</h2><h3 id="OSI参考模型每一层的作用？"><a href="#OSI参考模型每一层的作用？" class="headerlink" title="OSI参考模型每一层的作用？"></a>OSI参考模型每一层的作用？</h3><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/177615/12/10754/88478/60d32fd1E7fc173f0/45e530292054a0a5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="7层通信处理举例："><a href="#7层通信处理举例：" class="headerlink" title="7层通信处理举例："></a>7层通信处理举例：</h3><blockquote><p><strong>用户A给用户B发送”早上好”：</strong></p><ul><li><strong>第1步，输入完发送内容后点击发送那一刻，即进入应用层</strong><ul><li><strong>应用层将发送数据的前端添加一个首部，标明内容与收件人</strong></li></ul></li><li><strong>第2步，表示层：将”某个计算机特定的数据格式”转化为”统一的标准网络格式”</strong></li><li><strong>第3步，会话层：决定采用何种连接发送数据，例如发一封邮件就建立一次连接还是连发五封邮件，甚至建立五个连接</strong></li><li><strong>第4步，传输层：建立连接或断开连接或重发，例如用户B没有收到完整的”早上好”，告知用户A，则会重发未收到的内容，并再次确认</strong></li><li><strong>第5步，网络层与数据链路层：数据链路层负责每个区间的通信，网络层将数据发送给最终目标（端对端）</strong><ul><li><strong>数据链路层将数据0、1转化为电压和脉冲光传输给物理介质，通过物理介质实现通信传输</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/192330/34/9724/101153/60d2e8d6E196f29f0/545697238fd8fd15.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li><li><strong>第6步，用户B接收，与用户A相反，从物理层开始往上逐层处理</strong><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/182094/37/10771/156623/60d2e983E2d6aeaa3/dfe43cdcdfb0afd5.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li></ul></blockquote><hr><h2 id="1-7-传输方式分类"><a href="#1-7-传输方式分类" class="headerlink" title="1.7 传输方式分类"></a>1.7 传输方式分类</h2><h3 id="1-7-1-面向有连接与面向无连接"><a href="#1-7-1-面向有连接与面向无连接" class="headerlink" title="1.7.1 面向有连接与面向无连接"></a>1.7.1 面向有连接与面向无连接</h3><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/180716/23/10735/168022/60d2eafbEb229cd7c/03036bb435a13b3b.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>面向有连接型：在发送数据之前，需要在收发主机之间建立一条通信线路。在通信传输前后，专门进行建立和断开连接的处理，可以避免发送无谓的数据</strong></li><li><strong>面向无连接型：发送数据时候不需要建立连接，发送端可以在任何时候自由发送数据，即使接收端不存在，发送端也可以将数据发送出去</strong></li></ul><h3 id="1-7-2-电路交换与分组交换"><a href="#1-7-2-电路交换与分组交换" class="headerlink" title="1.7.2 电路交换与分组交换"></a>1.7.2 电路交换与分组交换</h3><ul><li><strong>电路交换：两台计算机通过独占电路完成信息交换，一次最多只能两个用户同时通信</strong></li><li><strong>分组交换：路由器之间通过一条/多条共享线路相连，发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再以先进先出的顺序转发给目标计算机（TCP/IP用的分组交换）</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/171999/3/16497/156446/60d326baE0caeb759/cfd772a646dfb68f.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h4 id="分组交换和电路交换的特点："><a href="#分组交换和电路交换的特点：" class="headerlink" title="分组交换和电路交换的特点："></a>分组交换和电路交换的特点：</h4><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/174188/39/16437/235381/60d3272bE3054b37c/a07c189c70f7d6d7.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="1-9-网络构成要素"><a href="#1-9-网络构成要素" class="headerlink" title="1.9 网络构成要素"></a>1.9 网络构成要素</h2><h3 id="1-9-2-网卡"><a href="#1-9-2-网卡" class="headerlink" title="1.9.2 网卡"></a>1.9.2 网卡</h3><ul><li><strong>将电脑的数据封装为帧，并通过网线（无线网络是电磁波）将数据发送到网络上</strong></li><li><strong>接收网络其他设备发送的帧，将帧重新组合成数据，发送到所在的电脑中</strong></li></ul><h3 id="1-9-3-中继器"><a href="#1-9-3-中继器" class="headerlink" title="1.9.3 中继器"></a>1.9.3 中继器</h3><p><strong>OSI模型的物理层，延长网络距离的设备，将电缆传过来的衰减的信号放大传给另一个电缆，延长网络长度</strong></p><h3 id="1-9-4-网桥-2层交换机"><a href="#1-9-4-网桥-2层交换机" class="headerlink" title="1.9.4 网桥/2层交换机"></a>1.9.4 网桥/2层交换机</h3><p><strong>OSI模型的数据链路层，能识别数据包中的MAC地址，根据MAC地址转发</strong></p><h3 id="1-9-5-路由器-3层交换机"><a href="#1-9-5-路由器-3层交换机" class="headerlink" title="1.9.5 路由器/3层交换机"></a>1.9.5 路由器/3层交换机</h3><p><strong>OSI模型的网络层，根据IP地址处理数据</strong></p><h3 id="1-9-7-网关"><a href="#1-9-7-网关" class="headerlink" title="1.9.7 网关"></a>1.9.7 网关</h3><p><strong>负责协议的转换和数据的转发</strong><br><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/172527/11/16785/89243/60d32e77Eaf128ea1/ec74714d1ab1421b.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-1-协议是什么？&quot;&gt;&lt;a href=&quot;#1-1-协议是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.1 协议是什么？&quot;&gt;&lt;/a&gt;1.1 协议是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;首先互联网代表协议TCP/IP，包括HTTP、T</summary>
      
    
    
    
    <category term="《图解TCP/IP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3TCP-IP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浏览器是怎样通信的</title>
    <link href="https://mactql.github.io/posts/2853482812.html"/>
    <id>https://mactql.github.io/posts/2853482812.html</id>
    <published>2021-06-18T16:00:00.000Z</published>
    <updated>2021-06-29T14:04:35.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1步，从在浏览器中输入网址开始："><a href="#第1步，从在浏览器中输入网址开始：" class="headerlink" title="第1步，从在浏览器中输入网址开始："></a>第1步，从在浏览器中输入网址开始：</h2><ul><li><strong>首先网址就是URL，通常是访问web服务器，用”http:”，即HTTP协议</strong></li><li><strong>URL的格式会随着协议的不同而不同</strong></li><li><strong>URL的各种格式如下：</strong><ul><li><strong>访问Web服务器或FTP服务器时，URL包括域名和文件路径名，有时还会包含用户名和密码和服务器端口号</strong></li></ul></li></ul><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/192120/18/9188/187284/60cd994bE12331888/5d15ca108f2daa5f.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="第2步，浏览器对URL进行解析"><a href="#第2步，浏览器对URL进行解析" class="headerlink" title="第2步，浏览器对URL进行解析"></a>第2步，浏览器对URL进行解析</h2><p><strong>对URL解析也就是对URL进行拆分，拆分结果如下：</strong><br><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/25315/31/13123/231182/60cd9d42E76517b5c/4415e5064467809d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>还有URL中省略文件名的特殊情况，甚至最后不以/结尾，将会直接访问服务器中设置的默认文件</strong></li></ul><h2 id="第3步，根据解析信息来生成HTTP请求消息"><a href="#第3步，根据解析信息来生成HTTP请求消息" class="headerlink" title="第3步，根据解析信息来生成HTTP请求消息"></a>第3步，根据解析信息来生成HTTP请求消息</h2><p><strong>HTTP方法最常用的就是GET和POST：</strong></p><ul><li><strong>在地址栏中输入网址并显示网页，因此这里应该使用 GET 方法</strong></li><li><strong>点击超级链接的场景中也是使用 GET 方法</strong></li><li><strong>如果是表单，在 HTML 源代码中会在表单的属性中指定使用哪种方法来发送请求，可能是 GET也可能是POST</strong></li></ul><h3 id="生成HTTP请求消息的格式："><a href="#生成HTTP请求消息的格式：" class="headerlink" title="生成HTTP请求消息的格式："></a>生成HTTP请求消息的格式：</h3><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/194117/1/9057/110909/60cdad3dEb4f176eb/1baee7cd88773d39.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="怎么生成HTTP请求消息："><a href="#怎么生成HTTP请求消息：" class="headerlink" title="怎么生成HTTP请求消息："></a>怎么生成HTTP请求消息：</h3><ul><li><strong>第1步，写好方法，是GET还是POST，加一个空格</strong></li><li><strong>第2步，写URI，即文件和程序的路径名，直接从URL中提取出来即可，再加一个空格，写HTTP版本</strong></li><li><strong>第3步，第二行开始写消息头，存放请求的额外信息，如日期，客户端支持的数据类型，软件名称和版本等等</strong></li><li><strong>第4步，空一行，写消息体。GET方法不需要写消息体，POST方法把表单中的信息写上</strong></li></ul><h3 id="生成结果如下："><a href="#生成结果如下：" class="headerlink" title="生成结果如下："></a>生成结果如下：</h3><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/177642/23/10196/223242/60cdafceEe9e56c53/4d1133388c4b3978.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="第4步，生成请求消息后，向DNS服务器查询Web服务器的IP地址"><a href="#第4步，生成请求消息后，向DNS服务器查询Web服务器的IP地址" class="headerlink" title="第4步，生成请求消息后，向DNS服务器查询Web服务器的IP地址"></a>第4步，生成请求消息后，向DNS服务器查询Web服务器的IP地址</h2><p><strong>虽然浏览器能生成解析地址生成HTTP请求消息，但是浏览器不能发送消息到网络，需要委托操作系统来做</strong></p><h3 id="IP地址原理"><a href="#IP地址原理" class="headerlink" title="IP地址原理"></a>IP地址原理</h3><h4 id="子网："><a href="#子网：" class="headerlink" title="子网："></a>子网：</h4><p><strong>由集线器连接起来几台计算机，看成一个单位</strong></p><h4 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h4><p><strong>把子网用路由器连起来形成网络</strong></p><h4 id="IP地址："><a href="#IP地址：" class="headerlink" title="IP地址："></a>IP地址：</h4><ul><li><strong>网络中所有的设备都被分配一个地址，由网络号、主机号组成</strong></li><li><strong>通过IP地址可以判断出访问服务器的位置，从而发送消息</strong></li></ul><h4 id="消息发送过程："><a href="#消息发送过程：" class="headerlink" title="消息发送过程："></a>消息发送过程：</h4><p><strong>发送者的消息先通过子网的集线器发送到最近的路由器上，路由器根据目的地判断并发送到下一个路由器，然后再经过子网的集线器发到下一个路由器，直到发送到目的地</strong></p><h3 id="为什么要查询IP地址？"><a href="#为什么要查询IP地址？" class="headerlink" title="为什么要查询IP地址？"></a>为什么要查询IP地址？</h3><p><strong>因为发送消息需要的不是域名，而是域名对应的IP地址</strong></p><h3 id="怎么向DNS服务器查询IP地址？"><a href="#怎么向DNS服务器查询IP地址？" class="headerlink" title="怎么向DNS服务器查询IP地址？"></a>怎么向DNS服务器查询IP地址？</h3><ul><li><strong>首先操作系统上有DNS客户端，客户端里有Socket库的DNS解析器</strong></li><li><strong>需要查询IP地址时</strong><ul><li><strong>第1步，浏览器会调用操作系统的解析器，解析器委托操作系统的协议栈通过网卡向DNS服务器发送查询消息，然后DNS会返回响应消息</strong></li><li><strong>第2步，响应消息通过协议栈传递给解析器，解析器会取出响应消息中的IP地址，并写入浏览器指定的内存地址中</strong></li></ul></li><li><strong>解析器程序如下：</strong></li></ul><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/180986/16/10049/89745/60cde338Ef32162ea/4a45757e8b9b22c9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="第5步，委托操作系统的协议栈向目标IP服务器收发HTTP消息"><a href="#第5步，委托操作系统的协议栈向目标IP服务器收发HTTP消息" class="headerlink" title="第5步，委托操作系统的协议栈向目标IP服务器收发HTTP消息"></a>第5步，委托操作系统的协议栈向目标IP服务器收发HTTP消息</h2><h3 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h3><ul><li><strong>首先收发消息操作之前，先要建立一条管道连接双方。管道两端的数据出入口叫套接字，所以先创建套接字</strong></li><li><strong>然后通过套接字连接起来形成管道</strong></li><li><strong>这些步骤都是委托协议栈完成的</strong></li></ul><h3 id="第1步，收发消息的准备工作："><a href="#第1步，收发消息的准备工作：" class="headerlink" title="第1步，收发消息的准备工作："></a>第1步，收发消息的准备工作：</h3><ul><li><strong>首先服务器创建套接字，等待客户端创建套接字并返回描述符</strong></li><li><strong>协议栈根据描述符、IP地址、端口号判断哪个套接字和哪个服务器的哪个套接字进行连接管道，连接后就完成了准备工作</strong><ul><li><strong>原理：描述符是用来在一台计算机内部识别套接字的，端口号就是用来识别服务器的套接字的</strong></li></ul></li><li><strong>传输完成后任何一方断开管道，通信就结束，套接字将删除</strong></li></ul><h3 id="第2步，收发HTTP消息"><a href="#第2步，收发HTTP消息" class="headerlink" title="第2步，收发HTTP消息"></a>第2步，收发HTTP消息</h3><ul><li><strong>发送消息：调用write程序组件并指定套接字和HTTP消息（需要发送的数据），协议栈就会发送数据到服务器</strong></li><li><strong>服务器响应消息：</strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/185016/29/10128/91496/60ce01bdEb0e8d8d3/624e0fc6f36db344.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li><li><strong>接收消息：调用read程序组件并指定消息存放内存地址，协议栈就会接收数据到接收缓冲区</strong></li></ul><h3 id="第3步，断开连接"><a href="#第3步，断开连接" class="headerlink" title="第3步，断开连接"></a>第3步，断开连接</h3><p><strong>服务器首先断开连接，传达到客户端后，客户端套接字也会断开，浏览器调用read后会得知通信结束，浏览器也会断开</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第1步，从在浏览器中输入网址开始：&quot;&gt;&lt;a href=&quot;#第1步，从在浏览器中输入网址开始：&quot; class=&quot;headerlink&quot; title=&quot;第1步，从在浏览器中输入网址开始：&quot;&gt;&lt;/a&gt;第1步，从在浏览器中输入网址开始：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;str</summary>
      
    
    
    
    <category term="《网络是怎样连接的》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第17章 集合深入研究</title>
    <link href="https://mactql.github.io/posts/1634000993.html"/>
    <id>https://mactql.github.io/posts/1634000993.html</id>
    <published>2021-06-18T14:54:00.000Z</published>
    <updated>2021-06-29T14:01:20.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="17-1-完整的集合分类"><a href="#17-1-完整的集合分类" class="headerlink" title="17.1 完整的集合分类"></a>17.1 完整的集合分类</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/185403/25/9715/152618/60cc4962E674c638f/44f842c2660115cc.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h2><blockquote><ul><li><strong>ArrayList是一种集合类，其底层基于数组实现，所以查找操作可在O(1)的时间范围内实现</strong></li><li><strong>ArrayList允许空值和重复元素</strong></li><li><strong>当向ArrayList中添加的元素数量大于其底层数组容量时，其会通过扩容机制生成一个新的数组</strong></li></ul></blockquote><h3 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">        <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">        <span class="comment">//创建空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">    *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器总结："><a href="#构造器总结：" class="headerlink" title="构造器总结："></a>构造器总结：</h4><blockquote><ul><li><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></li><li><strong>JDK7 new无参构造的ArrayList对象时，直接创建了长度是10的Object[]数组elementData 。jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式。</strong></li></ul></blockquote><h3 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a><strong>ArrayList扩容机制</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩充机制总结："><a href="#扩充机制总结：" class="headerlink" title="扩充机制总结："></a>扩充机制总结：</h4><p><strong><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</strong></p><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在元素序列尾部插入 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检测是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2. 将新元素插入序列尾部</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 在元素序列 index 位置处插入 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检测是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2. 将 index 及其之后的所有元素都向后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 3. 将新元素插入至 index 处</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入元素总结："><a href="#插入元素总结：" class="headerlink" title="插入元素总结："></a>插入元素总结：</h4><blockquote><p><strong>对于在元素序列尾部插入，这种情况比较简单，只需两个步骤即可：</strong></p><ul><li><strong>检测数组是否有足够的空间插入</strong></li><li><strong>将新元素插入至序列尾部</strong></li></ul></blockquote><p><strong>如果是在元素序列指定位置（假设该位置合理）插入，则情况稍微复杂一点，需要三个步骤：</strong></p><blockquote><ul><li><strong>检测数组是否有足够的空间</strong></li><li><strong>将 index 及其之后的所有元素向后移一位</strong></li><li><strong>将新元素插入至 index 处</strong></li></ul></blockquote><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 删除指定位置的元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回被删除的元素值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将 index + 1 及之后的元素向前移动一位，覆盖被删除值</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 将最后一个元素置空，并将 size 值减1                </span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 删除指定元素，若元素重复，则只删除下标最小的元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历数组，查找要删除元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 快速删除，不做边界检查，也不返回删除的元素值 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素总结："><a href="#删除元素总结：" class="headerlink" title="删除元素总结："></a>删除元素总结：</h4><blockquote><p><strong>以第一个删除方法为例，删除一个元素步骤如下：</strong></p><ul><li><strong>获取指定位置 index 处的元素值</strong></li><li><strong>将 index + 1 及之后的元素向前移动一位</strong></li><li><strong>将最后一个元素置空，并将 size 值减 1</strong></li><li><strong>返回被删除值，完成删除操作</strong></li></ul></blockquote><hr><h2 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h2><blockquote><ul><li><strong>LinkedList是一个实现了List接口和Deque接口的双端链表</strong></li><li><strong>LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性; LinkedList不是线程安全的。和 ArrayList 一样，LinkedList 也支持空值和重复值。</strong></li><li><strong>由于 LinkedList 基于链表实现，存储元素过程中，无需像 ArrayList 那样进行扩容。但有得必有失，LinkedList 存储元素的节点需要额外的空间存储前驱和后继的引用。</strong></li></ul></blockquote><h3 id="查找元素："><a href="#查找元素：" class="headerlink" title="查找元素："></a>查找元素：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 则从头节点开始查找，否则从尾节点查找</span></span><br><span class="line"><span class="comment">     * 查找位置 index 如果小于节点数量的一半，</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">// 循环向后查找，直至 i == index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找元素总结："><a href="#查找元素总结：" class="headerlink" title="查找元素总结："></a>查找元素总结：</h4><blockquote><ul><li><strong>如果查找位置小于节点数的一半，则从头节点开始找</strong></li><li><strong>如果查找位置大于等于节点数一半，则从尾节点向前找</strong></li></ul></blockquote><h3 id="插入元素："><a href="#插入元素：" class="headerlink" title="插入元素："></a>插入元素：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在链表尾部插入元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 在链表指定位置插入元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 判断 index 是不是链表尾部位置，如果是，直接将元素节点插入链表尾部即可</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将元素节点插入到链表尾部 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 将 last 引用指向新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空，为空表示当前链表还没有节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;    <span class="comment">// 让原尾节点后继引用 next 指向新的尾节点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将元素节点插入到 succ 之前的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 1. 初始化节点，并指明前驱和后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 2. 将 succ 节点前驱引用 prev 指向新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空，为空表示当前链表还没有节点    </span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;   <span class="comment">// 3. succ 节点前驱的后继引用指向新节点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入元素总结：-1"><a href="#插入元素总结：-1" class="headerlink" title="插入元素总结："></a>插入元素总结：</h4><blockquote><ul><li><strong>LinkedList分别有两个指针指向两端，两端均可插入元素</strong></li><li><strong>一开始创建链表时前后指针指向都是空的。只有插入第一个元素后，前后指针才有指向</strong></li></ul></blockquote><h3 id="删除元素："><a href="#删除元素：" class="headerlink" title="删除元素："></a>删除元素：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历链表，找到要删除的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);    <span class="comment">// 将节点从链表中移除</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 通过 node 方法定位节点，并调用 unlink 将节点从链表中移除</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将某个节点从链表中移除 */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prev 为空，表明删除的是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将 x 的前驱的后继指向 x 的后继</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 将 x 的前驱引用置空，断开与前驱的链接</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next 为空，表明删除的是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将 x 的后继的前驱指向 x 的前驱</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 将 x 的后继引用置空，断开与后继的链接</span></span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 item 置空，方便 GC 回收</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素总结：-1"><a href="#删除元素总结：-1" class="headerlink" title="删除元素总结："></a>删除元素总结：</h4><blockquote><p><strong>删除元素步骤如下：</strong></p><ol><li><strong>将待删除节点 x 的前驱的后继指向 x 的后继</strong></li><li><strong>将待删除节点 x 的前驱引用置空，断开与前驱的链接</strong></li><li><strong>将待删除节点 x 的后继的前驱指向 x 的前驱</strong></li><li><strong>将待删除节点 x 的后继引用置空，断开与后继的链接</strong></li></ol></blockquote><hr><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote><p><strong>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</strong><br><strong>JDK1.8 之后 HashMap 的组成多了红黑树，在满足下面两个条件之后，会执行链表转红黑树操作，用来加快搜索速度</strong></p></blockquote><blockquote><ul><li><strong>链表长度大于阈值（默认为 8）</strong></li><li><strong>HashMap 数组长度超过 64</strong></li></ul></blockquote><ul><li><strong>源码分析还需后期深入研究…</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;17-1-完整的集合分类&quot;&gt;&lt;a href=&quot;#17-1-完整的集合分类&quot; class=&quot;headerlink&quot; title=&quot;17.1 完整的集合分类&quot;&gt;&lt;/a&gt;17.1 完整的集合分类&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=&quot;lazyload placeh</summary>
      
    
    
    
    <category term="《Java编程思想》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java基础" scheme="https://mactql.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>第15章 泛型</title>
    <link href="https://mactql.github.io/posts/1779638846.html"/>
    <id>https://mactql.github.io/posts/1779638846.html</id>
    <published>2021-06-18T09:23:00.000Z</published>
    <updated>2021-06-29T14:01:29.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="15-2-简单泛型"><a href="#15-2-简单泛型" class="headerlink" title="15.2 简单泛型"></a>15.2 简单泛型</h2><p><strong>在没有泛型之前，采用的是继承机制来实现泛型，但是需要强制类型转换，会有风险</strong></p><h3 id="创建泛型类："><a href="#创建泛型类：" class="headerlink" title="创建泛型类："></a>创建泛型类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">T ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建泛型对象</span></span><br><span class="line">A&lt;..&gt; a = <span class="keyword">new</span> A&lt;&gt;();</span><br></pre></td></tr></table></figure><hr><h3 id="15-2-1-使用泛型创建多维元祖，实现一次调用返回多个对象"><a href="#15-2-1-使用泛型创建多维元祖，实现一次调用返回多个对象" class="headerlink" title="15.2.1 使用泛型创建多维元祖，实现一次调用返回多个对象"></a>15.2.1 使用泛型创建多维元祖，实现一次调用返回多个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>,...&gt;</span>&#123;<span class="comment">//A,B,C是泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second; <span class="comment">// 使用final使得客户端程序员无法修改，相当于private+getset方法</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(A a,B b)</span></span>&#123;first = a;second = b;&#125; <span class="comment">//构造器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="15-3-泛型接口"><a href="#15-3-泛型接口" class="headerlink" title="15.3 泛型接口"></a>15.3 泛型接口</h2><p><strong><code>public interface Generator&lt;T&gt; &#123;T next();&#125;</code></strong></p><h3 id="实现接口："><a href="#实现接口：" class="headerlink" title="实现接口："></a>实现接口：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Integer</span>&gt;</span>&#123; <span class="comment">//指定泛型T具体类型，可以是包装类数据类型也可以是自定义类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span></span>&#123; <span class="comment">// 重写接口中的方法</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-4-泛型方法"><a href="#15-4-泛型方法" class="headerlink" title="15.4 泛型方法"></a>15.4 泛型方法</h2><h3 id="为什么要用泛型方法？"><a href="#为什么要用泛型方法？" class="headerlink" title="为什么要用泛型方法？"></a>为什么要用泛型方法？</h3><ul><li><strong>因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活</strong></li><li><strong>使用泛型类，创建对象时必须指定泛型具体类型；而使用泛型方法，则不必指定，编译器会根据参数自动判断</strong></li></ul><h3 id="泛型方法定义"><a href="#泛型方法定义" class="headerlink" title="泛型方法定义"></a>泛型方法定义</h3><p><strong>泛型参数列表必须置于返回值之前前，泛型方法的类可以是泛型类也可以不是</strong></p><blockquote><ul><li><strong><code>public &lt;T&gt; void f(T x)&#123;...&#125;</code></strong></li><li><strong><code>public &lt;T,E&gt; E f(T a, E b) &#123;...&#125;</code></strong></li><li><strong><code>public  static &lt;T&gt; T f(T a)&#123;&#125;</code>  //泛型静态方法定义</strong></li></ul></blockquote><p><strong>显式指定类型调用泛型方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T x)</span></span>&#123;<span class="comment">//泛型方法</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">staticfun</span><span class="params">(T x)</span></span>&#123; <span class="comment">//静态泛型方法</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> main&#123;</span><br><span class="line">    A&lt;Integer&gt; a = <span class="keyword">new</span> A&lt;&gt;();</span><br><span class="line">        a.&lt;String&gt;fun(<span class="string">&quot;abc&quot;</span>); <span class="comment">//指定泛型具体类型调用泛型方法</span></span><br><span class="line">        A.&lt;String&gt;staticfun(<span class="string">&quot;abc&quot;</span>); <span class="comment">//指定泛型具体类型调用静态泛型方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="15-7-擦除"><a href="#15-7-擦除" class="headerlink" title="15.7 擦除"></a>15.7 擦除</h2><h3 id="什么是擦除："><a href="#什么是擦除：" class="headerlink" title="什么是擦除："></a>什么是擦除：</h3><ul><li><p><strong>泛型具体类型不同擦除后会变成原生类 如List<String> 和List<Integer>是一种类型，最后都会擦除成List</strong></p></li><li><p><strong>泛型只是用来检查类型正确性，一旦运行就会被擦除</strong></p><h3 id="擦除的结果："><a href="#擦除的结果：" class="headerlink" title="擦除的结果："></a>擦除的结果：</h3></li><li><p><strong><code>List&lt;T&gt;</code>被擦除为<code>List</code>  、  <code>List&lt;String&gt;</code>被擦除为<code>List&lt;Object&gt;</code></strong></p></li><li><p><strong><code>&lt;T extends  A&gt;</code>擦除为<code>&lt;A&gt;</code></strong></p></li></ul><h3 id="什么是边界："><a href="#什么是边界：" class="headerlink" title="什么是边界："></a>什么是边界：</h3><ul><li><strong>运行后泛型会被擦除到上边界</strong></li><li><strong><code>class A&lt;T extends B&gt;</code>擦除到<code>&lt;B&gt;</code></strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;15-2-简单泛型&quot;&gt;&lt;a href=&quot;#15-2-简单泛型&quot; class=&quot;headerlink&quot; title=&quot;15.2 简单泛型&quot;&gt;&lt;/a&gt;15.2 简单泛型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在没有泛型之前，采用的是继承机制来实现泛型，但是需要强制类型转换，会</summary>
      
    
    
    
    <category term="《Java编程思想》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java基础" scheme="https://mactql.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
