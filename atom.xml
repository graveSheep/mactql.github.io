<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mactql的小站</title>
  
  
  <link href="https://mactql.github.io/atom.xml" rel="self"/>
  
  <link href="https://mactql.github.io/"/>
  <updated>2021-08-19T07:56:41.299Z</updated>
  <id>https://mactql.github.io/</id>
  
  <author>
    <name>mactql</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识Spark及HDFS与MR</title>
    <link href="https://mactql.github.io/posts/367393044.html"/>
    <id>https://mactql.github.io/posts/367393044.html</id>
    <published>2021-08-19T07:54:00.000Z</published>
    <updated>2021-08-19T07:56:41.299Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本笔记是对《贝叶斯网络结构学习算法研究》论文进行学习时所写</strong><br><strong>上篇文章我们了解了什么是BN结构学习算法以及GA算法</strong><br><strong>该论文还需要学习的内容如下：（本文只解决第一个问题）</strong></p><ul><li><strong>什么是Spark分布式计算平台？</strong></li><li><strong>如何用分布式实现GA算法？</strong></li><li><strong>如何并行化构造超结构？</strong></li><li><strong>如何基于Spark实现GA算法？</strong></li><li><strong>如何基于Spark实现评分计算？</strong></li></ul><hr><h2 id="在学习Spark之前，先了解以下分布式计算框架"><a href="#在学习Spark之前，先了解以下分布式计算框架" class="headerlink" title="在学习Spark之前，先了解以下分布式计算框架"></a>在学习Spark之前，先了解以下分布式计算框架</h2><blockquote><p><strong>首先是Hadoop平台，即一个面向大数据的分布式基础架构</strong><br><strong>其中HDFS是分布式文件系统，把大数据进行切分然后存储到HDFS的若干节点上</strong></p><ul><li><strong>HDFS有两种节点，NameNode(NN)和DataNode(DN)。运行时一般是一个NN多个DN</strong></li></ul></blockquote><p><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86Spark%E5%8F%8AHDFS%E4%B8%8EMR/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><blockquote><ul><li><strong>读取步骤：首先HDFS客户端通过分布式文件系统向NN请求下载文件，NN查询元数据找到该文件所在的多个DN地址，客户端依次通过FSData输入流向DN地址请求并读取数据，直到完成读取</strong></li></ul></blockquote><blockquote><p><strong>然后介绍一下MapReduce(MR)，MR是一个并行处理数据的编程模型，用来对大数据进行计算</strong></p><ul><li><strong>MR流程分为两个阶段，Map阶段和Reduce阶段，分别由Mapper和Reducer两个接口实现</strong></li><li><strong>什么是Map，就是拆，把拼好的乐高汽车玩具拆成一块块积木</strong></li><li><strong>什么是Reduce，就是组合，用积木组合成变形金刚</strong></li><li><strong>那么怎么实现MR呢？如下图所示，一般先把大数据分成一”片”一”片”，然后每一”片”都由一个Map去拆，拆好了以后再shuffle归类成一组一组的，然后Reduce把每一组进行组合</strong></li></ul></blockquote><p><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86Spark%E5%8F%8AHDFS%E4%B8%8EMR/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="终于可以开始学习Spark了"><a href="#终于可以开始学习Spark了" class="headerlink" title="终于可以开始学习Spark了"></a>终于可以开始学习Spark了</h2><blockquote><p><strong>Spark是基于MR的一个处理大数据的计算框架，比MR速度更快</strong><br><strong>其中SparkSQL用来处理数据，SparkML用来做机器学习，SparkStreaming用来做流计算</strong><br><strong>Spark底层是用的RDD来处理数据的，RDD是什么？</strong></p><ul><li><strong>RDD其实是一个抽象概念，弹性分布式数据集。</strong></li><li><strong>RDD这个数据集是放在内存里的，并且RDD可以分区，每个分区放在集群的不同节点上，从而可以并行操作</strong></li><li><strong>通俗来说，RDD的表现形式类似数据库的视图，是抽象的，如下图所示</strong></li></ul></blockquote><p><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86Spark%E5%8F%8AHDFS%E4%B8%8EMR/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本笔记是对《贝叶斯网络结构学习算法研究》论文进行学习时所写&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;上篇文章我们了解了什么是BN结构学习算法以及GA算法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;该论文还需要学习的内容如下：（本文只解决第一个问题）&lt;/stro</summary>
      
    
    
    
    <category term="《贝叶斯网络结构学习算法》论文笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Spark" scheme="https://mactql.github.io/tags/Spark/"/>
    
    <category term="HDFS" scheme="https://mactql.github.io/tags/HDFS/"/>
    
    <category term="MapReduce" scheme="https://mactql.github.io/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>初识贝叶斯网络与遗传算法</title>
    <link href="https://mactql.github.io/posts/1117388134.html"/>
    <id>https://mactql.github.io/posts/1117388134.html</id>
    <published>2021-08-18T07:21:00.000Z</published>
    <updated>2021-08-19T07:52:17.756Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本笔记是对《贝叶斯网络结构学习算法研究》论文进行学习时所写</strong></p><h2 id="首先通过摘要"><a href="#首先通过摘要" class="headerlink" title="首先通过摘要"></a>首先通过摘要</h2><p><strong>可以了解到该论文研究的方向，即在大数据情况下基于遗传算法的贝叶斯网络结构算法执行效率问题</strong><br><strong>作者将混合方式的 BN 结构学习算法与 Spark 分布式计算平台结合</strong><br><strong>在构建超结构、评分计算和 GA 的进化操作三个流程上进行了并行化工作</strong><br><strong>同时引入Redis对中间数据进行存储以便在评分计算过程中高效复用数据</strong></p><hr><h2 id="故对该论文需要学习的内容如下：（本文只解决前3个问题）"><a href="#故对该论文需要学习的内容如下：（本文只解决前3个问题）" class="headerlink" title="故对该论文需要学习的内容如下：（本文只解决前3个问题）"></a>故对该论文需要学习的内容如下：（本文只解决前3个问题）</h2><ul><li><strong>什么是BN结构学习算法？</strong></li><li><strong>什么是GA算法？</strong></li><li><strong>怎么使用GA算法来得到BN结构？</strong></li><li><strong>什么是Spark分布式计算平台？</strong></li><li><strong>如何并行化构造超结构？</strong></li><li><strong>如何基于Spark实现GA算法？</strong></li><li><strong>如何基于Spark实现评分计算？</strong></li></ul><hr><h2 id="第1个问题，什么是BN结构学习算法？"><a href="#第1个问题，什么是BN结构学习算法？" class="headerlink" title="第1个问题，什么是BN结构学习算法？"></a>第1个问题，什么是BN结构学习算法？</h2><h3 id="首先回答什么是BN结构？"><a href="#首先回答什么是BN结构？" class="headerlink" title="首先回答什么是BN结构？"></a>首先回答什么是BN结构？</h3><ul><li><strong>BN，即贝叶斯网络，是一种反应世界上一些事物的可能的情况的发生概率的模型，可模拟任何系统</strong></li><li><strong>BN结构，是由有向无环图(DAG)和一组条件概率表组成</strong><ul><li><strong>其中DAG每个节点表示随机变量，有向边表示一个变量对另一个变量的影响</strong></li><li><strong>条件概率表表示每个节点x在其父节点的所有可能的联合赋值条件下的x的概率分布，例如下图节点A在父节点E、B所有可能的联合赋值条件下的概率</strong></li></ul></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h3 id="现在可以回答BN结构学习算法了"><a href="#现在可以回答BN结构学习算法了" class="headerlink" title="现在可以回答BN结构学习算法了"></a>现在可以回答BN结构学习算法了</h3><ul><li><strong>我们使用BN的目的就是为了得到那一组条件概率表，那么首先得构建一个BN网络，即那个有向无环图</strong></li><li><strong>那么怎么构造呢，很复杂的关系没办法手动构造吧，那么就是这里讨论的BN结构学习算法了</strong></li></ul><p><strong>当然啦，那个概率表也是要训练的才行的，不过这里讨论的是BN结构哈</strong></p><ul><li><strong>该论文指出BN结构学习算法主要是三种，基于评分、基于约束、约束和评分混合</strong></li></ul><h4 id="首先是基于评分，第一步定义评分函数、第二步采用搜索策略"><a href="#首先是基于评分，第一步定义评分函数、第二步采用搜索策略" class="headerlink" title="首先是基于评分，第一步定义评分函数、第二步采用搜索策略"></a>首先是基于评分，第一步定义评分函数、第二步采用搜索策略</h4><p><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>该论文采用BIC评分函数，由BN结构的对数似然度和惩罚项函数组成。前者表示数据集和BN结构的拟合程度，后者防止结构模型过于复杂、参数过多，导致过拟合问题。BIC评分计算方法见如下图，这里仅作了解</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>搜索策略就是在搜索空间中找得分最高的BN结构，也就是对数据集拟合程度最高的BN结构，该论文用的GA算法，下面就会介绍</strong></li></ul><h4 id="然后是基于约束，就是计算各节点间条件是否独立，并通过构造条件独立性集合来建立BN"><a href="#然后是基于约束，就是计算各节点间条件是否独立，并通过构造条件独立性集合来建立BN" class="headerlink" title="然后是基于约束，就是计算各节点间条件是否独立，并通过构造条件独立性集合来建立BN"></a>然后是基于约束，就是计算各节点间条件是否独立，并通过构造条件独立性集合来建立BN</h4><ul><li><strong>比如对于一个节点x，我们要求他的B(x)，即与他有条件联系的节点集合，即互信息。再用CI测试给边定向</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h4 id="最后是混合算法，即首先通过基于约束的方法构造无向图减少冗余搜索空间，然后通过基于评分搜索的方法得到评分最高的BN结构"><a href="#最后是混合算法，即首先通过基于约束的方法构造无向图减少冗余搜索空间，然后通过基于评分搜索的方法得到评分最高的BN结构" class="headerlink" title="最后是混合算法，即首先通过基于约束的方法构造无向图减少冗余搜索空间，然后通过基于评分搜索的方法得到评分最高的BN结构"></a>最后是混合算法，即首先通过基于约束的方法构造无向图减少冗余搜索空间，然后通过基于评分搜索的方法得到评分最高的BN结构</h4><hr><h2 id="第2个问题，什么是GA算法？"><a href="#第2个问题，什么是GA算法？" class="headerlink" title="第2个问题，什么是GA算法？"></a>第2个问题，什么是GA算法？</h2><h3 id="GA算法，即遗传算法。有以下几个概念："><a href="#GA算法，即遗传算法。有以下几个概念：" class="headerlink" title="GA算法，即遗传算法。有以下几个概念："></a>GA算法，即遗传算法。有以下几个概念：</h3><ul><li><strong>染色体：数学问题的每一个可行解就是一条染色体</strong></li><li><strong>基因：染色体上的元素就是基因，比如染色体[1,2,3]，那么每个数都是一个基因</strong></li><li><strong>适应度函数：每次繁衍后，适应度函数给生成的下一代所有的染色体打分，分数高的更有可能保留下去，分数低的淘汰</strong></li><li><strong>交叉：下一代染色体由父母两条染色体交叉形成，如下图所示。爸爸妈妈染色体的选择一般用轮盘赌算法，适应度高的更容易被选中</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>变异：交叉每次选择都是在原有数据集上选择，容易达到局部最优，但不能全局最优。变异就是在交叉后，对染色体上的若干个基因随机修改，从而达到全局最优</strong></li></ul><h3 id="GA算法执行流程？"><a href="#GA算法执行流程？" class="headerlink" title="GA算法执行流程？"></a>GA算法执行流程？</h3><p><strong>首先设置种群大小，突变概率，交叉概率等参数，然后随机初始化个体构成初始种群。每一次通过适应度函数打分，然后交叉、变异得到下一代，不断迭代</strong></p><hr><h2 id="第3个问题，怎么使用GA算法得到BN结构？"><a href="#第3个问题，怎么使用GA算法得到BN结构？" class="headerlink" title="第3个问题，怎么使用GA算法得到BN结构？"></a>第3个问题，怎么使用GA算法得到BN结构？</h2><p><strong>将GA算法应用到BN结构学习中</strong></p><ul><li><strong>首先选择操作：将适应度函数应用到对个体的BN结构评分，评分越高说明BN结构适应度越高</strong></li><li><strong>然后交叉操作：父母BN结构进行交叉，产生下一代BN结构</strong></li><li><strong>还有变异操作：对BN结构的若干基因进行随机变异，避免达到局部最优却无法全局最优解的情况</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本笔记是对《贝叶斯网络结构学习算法研究》论文进行学习时所写&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;首先通过摘要&quot;&gt;&lt;a href=&quot;#首先通过摘要&quot; class=&quot;headerlink&quot; title=&quot;首先通过摘要&quot;&gt;&lt;/a&gt;首先通过摘要&lt;/h2&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="《贝叶斯网络结构学习算法》论文笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E3%80%8B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="贝叶斯网络" scheme="https://mactql.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C/"/>
    
    <category term="遗传算法" scheme="https://mactql.github.io/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第1章 简单工厂模式</title>
    <link href="https://mactql.github.io/posts/4228647784.html"/>
    <id>https://mactql.github.io/posts/4228647784.html</id>
    <published>2021-08-15T07:21:00.000Z</published>
    <updated>2021-08-18T07:37:31.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单工厂模式是什么？用来干啥？"><a href="#简单工厂模式是什么？用来干啥？" class="headerlink" title="简单工厂模式是什么？用来干啥？"></a>简单工厂模式是什么？用来干啥？</h2><p><strong>设想一下，如果有很多个类，都是完成类似的工作。那么就可以写一个工厂类就像一个中间人一样，来帮助我们选择需要的类来创建对象，而不用我们自己去new，UML图如下：</strong><br><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC1%E7%AB%A0%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><br><strong>比如要做一个计算器程序，需要设计加减乘除等运算类 和 去调用这些运算并显示结果的客户端类，可以创建一个工厂类</strong><br><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC1%E7%AB%A0%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="用简单工厂模式有什么好处呢？"><a href="#用简单工厂模式有什么好处呢？" class="headerlink" title="用简单工厂模式有什么好处呢？"></a>用简单工厂模式有什么好处呢？</h2><p><strong>工厂类可以通过逻辑判断，来决定在什么时候创建哪一个产品类的实例，这样客户端可以不用自己去new对象了。简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。外界与具体类隔离开来，偶合性低。明确区分了各自的职责和权力，有利于整个软件体系结构的优化</strong></p><hr><h2 id="那么怎么使用简单工厂模式呢？"><a href="#那么怎么使用简单工厂模式呢？" class="headerlink" title="那么怎么使用简单工厂模式呢？"></a>那么怎么使用简单工厂模式呢？</h2><p><strong>就上述设计计算器程序为例，抽象接口及其实现类如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numA,<span class="keyword">double</span> numB)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="comment">//实现接口中的同名方法，这样客户端可以通过工厂类返回的向上转型的对象实例进行动态绑定调用具体方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numA,<span class="keyword">double</span> numB)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numA+numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他实现类同理</span></span><br></pre></td></tr></table></figure><p><strong>工厂类如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">//简单工厂类中用静态方法，返回类型为抽象接口，通过多态得到不同对象的实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String operate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(operate)&#123;</span><br><span class="line">            <span class="keyword">if</span> operate.equals(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> operate.equals(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>   ...</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过多态的向上转型和动态绑定，虽然是抽象接口的对象，但是可以使用具体实现类的具体方法</span></span><br><span class="line">Operator oper = OperatorFactory.getOperator(<span class="string">&quot;+&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> result = oper.getResult(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单工厂模式是什么？用来干啥？&quot;&gt;&lt;a href=&quot;#简单工厂模式是什么？用来干啥？&quot; class=&quot;headerlink&quot; title=&quot;简单工厂模式是什么？用来干啥？&quot;&gt;&lt;/a&gt;简单工厂模式是什么？用来干啥？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;设想一下，如果有很多</summary>
      
    
    
    
    <category term="《大话设计模式》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="设计模式" scheme="https://mactql.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Maven入门指南</title>
    <link href="https://mactql.github.io/posts/477950076.html"/>
    <id>https://mactql.github.io/posts/477950076.html</id>
    <published>2021-08-14T03:35:00.000Z</published>
    <updated>2021-08-14T03:40:26.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要用Maven？"><a href="#为什么要用Maven？" class="headerlink" title="为什么要用Maven？"></a>为什么要用Maven？</h2><ul><li><strong>场景一：idea开发的项目没法到eclipse中运行，即不同的ide开发的项目不能互相使用</strong></li><li><strong>场景二：大型项目需要很多个jar包，要去不同的网站下载，也不方便更新，很麻烦</strong></li></ul><hr><h2 id="IDEA上怎么创建Maven项目？"><a href="#IDEA上怎么创建Maven项目？" class="headerlink" title="IDEA上怎么创建Maven项目？"></a>IDEA上怎么创建Maven项目？</h2><p><strong>创建Maven项目时需要填写以下信息</strong></p><ul><li><strong>GroupID：机构名或者逆向域名的形式</strong></li><li><strong>ArtifactID：项目名称</strong></li><li><strong>Version：版本号</strong></li></ul><p><strong>创建好了以后会自动生成Maven项目结构以及配置文件pom.xml</strong></p><hr><h2 id="Maven项目结构是什么样的？"><a href="#Maven项目结构是什么样的？" class="headerlink" title="Maven项目结构是什么样的？"></a>Maven项目结构是什么样的？</h2><p><img "" class="lazyload placeholder" data-original="/medias/Maven%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="那pom-xml文件是干啥的？"><a href="#那pom-xml文件是干啥的？" class="headerlink" title="那pom.xml文件是干啥的？"></a>那pom.xml文件是干啥的？</h2><p><strong>pom.xml文件是用来配置项目依赖的，Maven会通过这些依赖自动下载第三方组件</strong></p><h2 id="那么怎么在pom-xml中配置项目依赖呢？"><a href="#那么怎么在pom-xml中配置项目依赖呢？" class="headerlink" title="那么怎么在pom.xml中配置项目依赖呢？"></a>那么怎么在pom.xml中配置项目依赖呢？</h2><p><strong>在search.maven.org网站中搜索需要的组件，找到需要的组件的依赖后加入pom.xml的<code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>中，然后maven就会自动下载这些组件了</strong></p><hr><h2 id="怎么让maven下载依赖的速度快一点呢？"><a href="#怎么让maven下载依赖的速度快一点呢？" class="headerlink" title="怎么让maven下载依赖的速度快一点呢？"></a>怎么让maven下载依赖的速度快一点呢？</h2><p><strong>Maven首先去本地仓库找，如果本地仓库没有再去中央仓库下载到本地仓库。</strong><br><strong>为了加快下载速度，可以使用私服，从私服下载到本地仓库</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以在pom.xml的&lt;version&gt;下方添加一个阿里云私服的地址配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="maven命令常用的有哪些？"><a href="#maven命令常用的有哪些？" class="headerlink" title="maven命令常用的有哪些？"></a>maven命令常用的有哪些？</h2><ul><li><strong>compile：编译，编译成功后会增加一个target目录</strong></li><li><strong>clean：删除整个target目录</strong></li><li><strong>test：在集成junit，并且有test项目和测试类</strong></li><li><strong>package：把项目打包成jar包</strong></li><li><strong>install：把打好的jar包放到本地仓库去</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么要用Maven？&quot;&gt;&lt;a href=&quot;#为什么要用Maven？&quot; class=&quot;headerlink&quot; title=&quot;为什么要用Maven？&quot;&gt;&lt;/a&gt;为什么要用Maven？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;场景一：idea开发的项目没法到ecli</summary>
      
    
    
    
    <category term="《Maven项目管理》课程笔记" scheme="https://mactql.github.io/categories/%E3%80%8AMaven%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E3%80%8B%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Maven" scheme="https://mactql.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>第8章 备份与复制</title>
    <link href="https://mactql.github.io/posts/147568029.html"/>
    <id>https://mactql.github.io/posts/147568029.html</id>
    <published>2021-08-09T07:47:00.000Z</published>
    <updated>2021-08-14T03:33:26.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="备份常用的方法是什么？"><a href="#备份常用的方法是什么？" class="headerlink" title="备份常用的方法是什么？"></a>备份常用的方法是什么？</h2><p><strong>冷备、热备</strong></p><ul><li><strong>冷备是指在停止数据库后备份，直接备份数据库的物理文件即可，一般都是写个脚本</strong></li><li><strong>热备是指在数据库运行的时候直接备份，一般借用工具，如ibbackup、XtraBackup</strong></li></ul><hr><h2 id="什么是复制？"><a href="#什么是复制？" class="headerlink" title="什么是复制？"></a>什么是复制？</h2><p><strong>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库。主数据库一般是准实时的业务数据库</strong></p><ul><li><strong>用来做热备。主数据库坏了可以切换到从数据库</strong></li><li><strong>读写分离。比如报表sql很慢，会导致锁表，可以让从数据库报表，主数据库继续做业务</strong></li></ul><hr><h3 id="主从复制的原理是什么？"><a href="#主从复制的原理是什么？" class="headerlink" title="主从复制的原理是什么？"></a>主从复制的原理是什么？</h3><ul><li><strong>首先master把数据更改记录到二进制日志</strong></li><li><strong>然后slave把master的二进制日志复制到自己的中继日志</strong></li><li><strong>最后slave重做中继日志中的日志，把数据更改也用到自己数据库上，这样就和master保持一致</strong></li></ul><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC8%E7%AB%A0%E5%A4%87%E4%BB%BD%E4%B8%8E%E5%A4%8D%E5%88%B6/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;备份常用的方法是什么？&quot;&gt;&lt;a href=&quot;#备份常用的方法是什么？&quot; class=&quot;headerlink&quot; title=&quot;备份常用的方法是什么？&quot;&gt;&lt;/a&gt;备份常用的方法是什么？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;冷备、热备&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="《MySQL技术内幕》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MySQL" scheme="https://mactql.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第5章 MySQL索引</title>
    <link href="https://mactql.github.io/posts/2979735234.html"/>
    <id>https://mactql.github.io/posts/2979735234.html</id>
    <published>2021-08-08T07:47:00.000Z</published>
    <updated>2021-08-08T07:50:38.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="InnoDB支持的索引"><a href="#InnoDB支持的索引" class="headerlink" title="InnoDB支持的索引"></a>InnoDB支持的索引</h2><ul><li><strong>B+树索引</strong></li><li><strong>全文索引</strong></li><li><strong>哈希索引（自适应）</strong></li></ul><hr><h2 id="说说B-树吧"><a href="#说说B-树吧" class="headerlink" title="说说B+树吧"></a>说说B+树吧</h2><p><strong>B+树就是一种平衡搜索树。所有的记录节点都按照键值从小到大顺序放在同一层的叶子节点上，如下图所示</strong><br><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC5%E7%AB%A0MySQL%E7%B4%A2%E5%BC%95/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h3 id="聚集索引和辅助索引"><a href="#聚集索引和辅助索引" class="headerlink" title="聚集索引和辅助索引"></a>聚集索引和辅助索引</h3><p><strong>假设有个表如下：</strong><br><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC5%E7%AB%A0MySQL%E7%B4%A2%E5%BC%95/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><br><strong>聚集索引就是用每个表的主键构造一课B+树。每个叶子节点里放表的行数据，并且每个叶子在不同的磁盘上面</strong></p><ul><li><strong>如下图所示：如果要查找id=5的数据，那么先把磁盘0读入内存，然后用二分法查找id=5的数在3和6之间，然后通过指针p1查找到磁盘2的地址，然后将磁盘2读入内存中，用二分查找方式查找到id=5的数据</strong></li></ul><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC5%E7%AB%A0MySQL%E7%B4%A2%E5%BC%95/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><br><strong>辅助索引的叶子节点里不包含一行数据的全部数据。如果要找一个完整的行数据，可以通过辅助索引找到指向主键索引的指针，然后去聚集索引里找到完整行数据</strong></p><ul><li><strong>如下图所示：如果要查找到name = 小徐，首先将磁盘0加载到内存中，然后用二分查找的方法查到在指针p1所指的地址上，然后通过指针p1所指的地址可知道在磁盘2上面，然后通过二分查找法得知小徐id=4。然后在根据id=4将磁盘0加载到内存中，用上述聚集索引的方法找到完整的行数据</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC5%E7%AB%A0MySQL%E7%B4%A2%E5%BC%95/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><hr><h3 id="如何创建和删除索引"><a href="#如何创建和删除索引" class="headerlink" title="如何创建和删除索引"></a>如何创建和删除索引</h3><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC5%E7%AB%A0MySQL%E7%B4%A2%E5%BC%95/4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>一开始创建数据库的时候，会创建主键的聚集索引，之后需要手动加入其他属性(列)的索引。对于不常查询的属性，不需要建立索引，会降低更新操作的速度</strong></li></ul><hr><h2 id="再说说自适应哈希索引吧"><a href="#再说说自适应哈希索引吧" class="headerlink" title="再说说自适应哈希索引吧"></a>再说说自适应哈希索引吧</h2><ul><li><strong>这是数据库自动创建的，不能手动创建</strong></li><li><strong>只能用于精准查找，如<code>SELECT ... FROM TABLE WHERE col_name = &#39;xxx&#39;</code></strong></li></ul><hr><h2 id="最后说说全文索引吧"><a href="#最后说说全文索引吧" class="headerlink" title="最后说说全文索引吧"></a>最后说说全文索引吧</h2><ul><li><strong><code>LIKE &#39;xxx%&#39;</code>这种是可以用B+树索引的，但是<code>LIKE &#39;%xxx%&#39;</code>就不行，所以需要全文索引</strong></li><li><strong>以前InnoDB不支持全文索引，现在的版本支持了</strong></li><li><strong>在这里仅作了解，等以后再深入研究</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;InnoDB支持的索引&quot;&gt;&lt;a href=&quot;#InnoDB支持的索引&quot; class=&quot;headerlink&quot; title=&quot;InnoDB支持的索引&quot;&gt;&lt;/a&gt;InnoDB支持的索引&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;B+树索引&lt;/strong&gt;&lt;/li&gt;
</summary>
      
    
    
    
    <category term="《MySQL技术内幕》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MySQL" scheme="https://mactql.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第3章 MySQL日志</title>
    <link href="https://mactql.github.io/posts/4156801793.html"/>
    <id>https://mactql.github.io/posts/4156801793.html</id>
    <published>2021-08-06T13:25:00.000Z</published>
    <updated>2021-08-06T13:34:45.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL常用的日志类型有哪些？"><a href="#MySQL常用的日志类型有哪些？" class="headerlink" title="MySQL常用的日志类型有哪些？"></a>MySQL常用的日志类型有哪些？</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0MySQL%E6%97%A5%E5%BF%97/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p><strong>错误日志记录mysql在启动、运行、关闭过程中出现的问题，并会记录在错误文件中。用户可以通过<code>SHOW VARIABLES LLKE &#39;log_error‘</code>来定位错误日志文件。默认情况下文件名为主机名，查看错误文件并进行优化</strong></p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p><strong>慢查询日志可以定位可能存在问题的SQL语句，从而进行SQL语句层面的优化</strong><br><strong>例如可以在MySQL启动时设一个阈值，若运行时间超过该值的SQL语句就记录到慢查日志文件中</strong><br><strong>用户可以通过<code>SHOW VARIABLES LIKE &#39;log_slow_queries&#39;</code></strong></p><h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p><strong>二进制日志记录了对MySQL数据库执行更改的所有操作，即不包括SHOW和SELECT这类语句</strong><br><strong>二进制日志的作用为基于时间点恢复数据、主从复制数据、审计数据（判断是否有注入攻击）</strong><br><strong>默认文件名为主机名.日志序列号，如host.00001。二进制日志默认关闭，需要手动开启</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL常用的日志类型有哪些？&quot;&gt;&lt;a href=&quot;#MySQL常用的日志类型有哪些？&quot; class=&quot;headerlink&quot; title=&quot;MySQL常用的日志类型有哪些？&quot;&gt;&lt;/a&gt;MySQL常用的日志类型有哪些？&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=</summary>
      
    
    
    
    <category term="《MySQL技术内幕》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MySQL" scheme="https://mactql.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第1章 MySQL和存储引擎</title>
    <link href="https://mactql.github.io/posts/925095689.html"/>
    <id>https://mactql.github.io/posts/925095689.html</id>
    <published>2021-08-06T06:59:00.000Z</published>
    <updated>2021-08-06T06:59:36.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL存储引擎是什么？"><a href="#MySQL存储引擎是什么？" class="headerlink" title="MySQL存储引擎是什么？"></a>MySQL存储引擎是什么？</h2><ul><li><strong>MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现</strong></li></ul><hr><h2 id="MySQL存储引擎的选择"><a href="#MySQL存储引擎的选择" class="headerlink" title="MySQL存储引擎的选择"></a>MySQL存储引擎的选择</h2><ul><li><strong>5.5之前默认存储引擎是MyISAM,5.5之后默认存储引擎是Innodb</strong></li></ul><hr><h2 id="具体说说MyISAM"><a href="#具体说说MyISAM" class="headerlink" title="具体说说MyISAM"></a>具体说说MyISAM</h2><p><strong>首先MyISAM支持全文检索，不支持事务和行级锁，只有表级别锁，它适用于 OLAP 场景，也就是分析类的，基本上都是读取，不会有什么写入动作的场景</strong><br><strong>其次它的数据和索引是分离存储的，也就是不在一个文件上，并且数据库只会缓存索引文件，数据文件的缓存直接交给操作系统搞定</strong><br><strong>然后MyISAM 的索引也是 B+ 树，只是不像 InnoDB 那种叶子节点会存储完整的数据，MyISAM 的数据是独立于索引单独存储的，所以主键和非主键索引差别不大</strong><br><strong>还有一个情况就是 MyISAM 不支持崩溃后的安全恢复，而 InnoDB 有个 redolog 可以支持安全恢复</strong><br><strong>再有一点就是 MyISAM 写入性能差。因为锁的粒度太粗了，不支持行锁，只有表锁，所以写入的时候会对整张表加锁</strong></p><h2 id="具体说说Innodb"><a href="#具体说说Innodb" class="headerlink" title="具体说说Innodb"></a>具体说说Innodb</h2><p><strong>InnoDB 支持事务，实现了四种标准的隔离级别，利用 MVCC 来支持高并发，默认事务隔离级别为可重复读，支持行锁，利用行锁+间隙锁提供可重复读级别下防止幻读的能力，支持崩溃后的数据安全恢复</strong><br><strong>另外还支持外键</strong><br><strong>InnoDB 的主键索引称为聚簇索引，也就是数据和索引是放在一起的，这与 MyISAM 有所不同，并且它的辅助索引(非主键索引)只存储索引值与主键，因此当辅助索引不能覆盖查询的列时，需要通过找到的主键再去聚簇索引查询数据，这个过程称之为****回表</strong><br><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC1%E7%AB%A0MySQL%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><br><strong>它之所以能取代 MyISAM 成为默认引擎就是因为事务的支持、 Innodb的关键特性、崩溃后的数据安全恢复例如MVCC</strong></p><hr><h2 id="Innodb和MyISAM的区别"><a href="#Innodb和MyISAM的区别" class="headerlink" title="Innodb和MyISAM的区别"></a>Innodb和MyISAM的区别</h2><ul><li><strong>Innodb支持事务，MyISAM不支持事务</strong></li><li><strong>MyISAM不支持外键，InnoDB支持外键</strong></li><li><strong>MyISAM只支持表级锁，InnoDB支持行级锁和表级锁，默认是行级锁</strong></li><li><strong>MyISAM支持全文索引，InnoDB不支持全文索引</strong></li><li><strong>MyISAM支持没有主键的表存在，InnoDB不支持没有主键</strong></li><li><strong>MyISAM较简单，效率上优于InnoDB，适合小型应用</strong></li><li><strong>MyISAM使用非聚集索引，InnoDB使用聚集索引</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL存储引擎是什么？&quot;&gt;&lt;a href=&quot;#MySQL存储引擎是什么？&quot; class=&quot;headerlink&quot; title=&quot;MySQL存储引擎是什么？&quot;&gt;&lt;/a&gt;MySQL存储引擎是什么？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MySQL中的数据、索引</summary>
      
    
    
    
    <category term="《MySQL技术内幕》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AMySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MySQL" scheme="https://mactql.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>牛客SQL第1-20题</title>
    <link href="https://mactql.github.io/posts/642795887.html"/>
    <id>https://mactql.github.io/posts/642795887.html</id>
    <published>2021-07-30T14:47:00.000Z</published>
    <updated>2021-08-20T00:25:21.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL1"><a href="#SQL1" class="headerlink" title="SQL1"></a>SQL1</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>第一种：适用于最晚的员工如果不止一个的情况</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>先找到最晚的hire_data，再用条件查到</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(hire_date) <span class="keyword">FROM</span> employees)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>第二种：不适用于最晚的员工如果不止一个的情况。</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>降序排序，并且只显示第一行  </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>limit(x,y)代表第x行开始共显示y行  limit x [<span class="keyword">offset</span> y]代表取前x行数据，但是跳过y行</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> LIMIT <span class="number">0</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL2"><a href="#SQL2" class="headerlink" title="SQL2"></a>SQL2</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>适用于相同时间员工不止一个的情况</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法同SQL1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>注意<span class="keyword">DISTINCT</span>去重</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> hire_date <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> LIMIT <span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>不适用于相同时间员工不止一个的情况</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法同SQL1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> LIMIT <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL3"><a href="#SQL3" class="headerlink" title="SQL3"></a>SQL3</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>给表起别名 <span class="keyword">FROM</span> tablea t 把tablea起名为t</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>等值连接 <span class="keyword">where</span>连接两个表</span><br><span class="line"><span class="keyword">SELECT</span> s.<span class="operator">*</span> ,d.dept_no <span class="keyword">FROM</span> salaries s,dept_manager d</span><br><span class="line">  <span class="keyword">WHERE</span> s.emp_no <span class="operator">=</span> d.emp_no</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> s.emp_no</span><br></pre></td></tr></table></figure><hr><h2 id="SQL4"><a href="#SQL4" class="headerlink" title="SQL4"></a>SQL4</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>第一种：等值连接</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line">  <span class="keyword">FROM</span> employees e,dept_emp d</span><br><span class="line">  <span class="keyword">WHERE</span> e.emp_no <span class="operator">=</span> d.emp_no</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>第二种：自然连接 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span></span><br><span class="line"> <span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line">  <span class="keyword">FROM</span> employees e</span><br><span class="line">  <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> dept_emp d</span><br></pre></td></tr></table></figure><hr><h2 id="SQL5"><a href="#SQL5" class="headerlink" title="SQL5"></a>SQL5</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* INNER JOIN 两边表同时有对应的数据，即任何一边缺失数据就不显示。</span></span><br><span class="line"><span class="comment">LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</span></span><br><span class="line"><span class="comment">RIGHT JOIN 会读取右边数据表的全部数据，即便左边表无对应数据。*/</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>内外连接需要用<span class="keyword">ON</span>做条件</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line">  <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept_emp d</span><br><span class="line">  <span class="keyword">ON</span> e.emp_no <span class="operator">=</span> d.emp_no</span><br></pre></td></tr></table></figure><hr><h2 id="SQL7"><a href="#SQL7" class="headerlink" title="SQL7"></a>SQL7</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">GROUP</span> <span class="keyword">BY</span> 可以按照属性对表分组</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>当用上 <span class="keyword">GROUP</span> <span class="keyword">BY</span>后的聚集函数是对每一个组进行聚集</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">HAVING</span>和 <span class="keyword">WHERE</span>类似，都是起到过滤作用，但是<span class="keyword">HAVING</span>是对分组进行过滤，<span class="keyword">WHERE</span>是对行进行过滤</span><br><span class="line"><span class="keyword">SELECT</span> emp_no,<span class="built_in">COUNT</span>(emp_no) <span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(emp_no) <span class="operator">&gt;</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL8"><a href="#SQL8" class="headerlink" title="SQL8"></a>SQL8</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>同SQL2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary <span class="keyword">FROM</span> salaries</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL10"><a href="#SQL10" class="headerlink" title="SQL10"></a>SQL10</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/7.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>不包含用 <span class="keyword">NOT</span> <span class="keyword">IN</span>(...)</span><br><span class="line"><span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">WHERE</span> emp_no <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> dept_manager</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><hr><h2 id="SQL11"><a href="#SQL11" class="headerlink" title="SQL11"></a>SQL11</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/8.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>等值连接<span class="operator">+</span>条件判断</span><br><span class="line"><span class="keyword">SELECT</span> emp.emp_no,man.emp_no <span class="keyword">FROM</span> dept_emp emp,dept_manager man</span><br><span class="line">  <span class="keyword">WHERE</span> emp.dept_no <span class="operator">=</span> man.dept_no <span class="operator">&amp;&amp;</span> emp.emp_no <span class="operator">!=</span> man.emp_no</span><br></pre></td></tr></table></figure><hr><h2 id="SQL12"><a href="#SQL12" class="headerlink" title="SQL12"></a>SQL12</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/9.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>首先是内连接，若不匹配直接不显示。因为两个表有两个相同属性，from_date数据不同所以不能用自然连接</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>然后用窗口函数 <span class="keyword">OVER</span>(PARITION BY... <span class="keyword">ORDER</span> <span class="keyword">BY</span>) <span class="keyword">as</span> ... 可以分组进行排序，并且不修改原来的数据只添加一个排序列</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>要求TOPN的题都可以用窗口函数嵌套上查询和<span class="keyword">where</span>条件把rank<span class="operator">=</span>N的取出来</span><br><span class="line"><span class="keyword">SELECT</span> t.dept_no,t.emp_no,t.salary</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> d.dept_no,d.emp_no,d.salary,<span class="built_in">DENSE_RANK</span>()</span><br><span class="line">          <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> d.dept_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> d.salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> sal_rank</span><br><span class="line">          <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> emp.dept_no,emp.emp_no,s.salary</span><br><span class="line">                  <span class="keyword">FROM</span> dept_emp emp</span><br><span class="line">                  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries s <span class="keyword">ON</span> emp.emp_no <span class="operator">=</span> s.emp_no) d</span><br><span class="line">       ) t</span><br><span class="line">  <span class="keyword">WHERE</span> t.sal_rank <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL15"><a href="#SQL15" class="headerlink" title="SQL15"></a>SQL15</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/10.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>值不相等用<span class="operator">!=</span>，非空用 <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>字符串用<span class="string">&#x27;&#x27;</span>引上</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>多个条件用 <span class="keyword">AND</span>连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">WHERE</span> emp_no <span class="operator">%</span> <span class="number">2</span> <span class="operator">!=</span> <span class="number">0</span> <span class="keyword">AND</span> last_name <span class="operator">!=</span> <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL16"><a href="#SQL16" class="headerlink" title="SQL16"></a>SQL16</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/11.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>要对分组后的聚集函数的结果进行 <span class="keyword">ORDER</span> <span class="keyword">BY</span>，需要先对结果起个别名</span><br><span class="line"><span class="keyword">SELECT</span> t.title,<span class="built_in">AVG</span>(s.salary) <span class="keyword">AS</span> sal_avg <span class="keyword">FROM</span> titles t</span><br><span class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries s <span class="keyword">ON</span> t.emp_no <span class="operator">=</span> s.emp_no</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> t.title</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal_avg</span><br></pre></td></tr></table></figure><hr><h2 id="SQL17"><a href="#SQL17" class="headerlink" title="SQL17"></a>SQL17</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/12.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>同SQL1</span><br><span class="line"><span class="keyword">SELECT</span> emp_no,salary <span class="keyword">FROM</span> salaries</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">1</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL18"><a href="#SQL18" class="headerlink" title="SQL18"></a>SQL18</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/13.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>怪题</span><br><span class="line"><span class="keyword">SELECT</span> s.emp_no, s.salary, e.last_name, e.first_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> salaries s</span><br><span class="line"><span class="keyword">WHERE</span> s.salary <span class="operator">=</span> (</span><br><span class="line">  <span class="keyword">select</span> <span class="built_in">max</span>(salary)</span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line">  <span class="keyword">where</span> salary <span class="operator">!=</span> ( <span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> salaries )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="SQL19"><a href="#SQL19" class="headerlink" title="SQL19"></a>SQL19</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/14.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>双左连接，左边有数据右边没有数据也显示</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept_emp t <span class="keyword">ON</span> e.emp_no <span class="operator">=</span> t.emp_no</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> t.dept_no <span class="operator">=</span> d.dept_no</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL1&quot;&gt;&lt;a href=&quot;#SQL1&quot; class=&quot;headerlink&quot; title=&quot;SQL1&quot;&gt;&lt;/a&gt;SQL1&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=&quot;lazyload placeholder&quot; data-original=&quot;/medias/%E</summary>
      
    
    
    
    <category term="牛客网SQL题库" scheme="https://mactql.github.io/categories/%E7%89%9B%E5%AE%A2%E7%BD%91SQL%E9%A2%98%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://mactql.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>第4章 锁的优化</title>
    <link href="https://mactql.github.io/posts/110256432.html"/>
    <id>https://mactql.github.io/posts/110256432.html</id>
    <published>2021-07-28T07:04:00.000Z</published>
    <updated>2021-08-18T07:38:11.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-锁的优化有哪些点？"><a href="#4-1-锁的优化有哪些点？" class="headerlink" title="4.1 锁的优化有哪些点？"></a>4.1 锁的优化有哪些点？</h2><ul><li><strong>减少锁的持有时间：尽量避免对整个方法synchronized，只在必要时进行synchronized</strong></li><li><strong>减小锁粒度：即缩小锁定对象的范围。例如ConcurrentHashMap对其中的某个段加锁，不要对整个HashMap加锁</strong></li><li><strong>使用读写锁，即ReadWriteLock</strong></li><li><strong>锁分离：把读写锁的思想作延伸，对不同的操作功能加锁。例如LinkedBlockingQueue的take()和put()方法使用不同的锁</strong></li><li><strong>锁粗化：如果对同一个锁不断地进行请求，同步和释放，这些操作本身就会占用大量的系统资源</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC4%E7%AB%A0%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>JVM对锁的优化：</strong><ul><li><strong>偏向锁：当一个线程获得锁，就进入偏向模式。再次请求锁时，无需同步</strong></li><li><strong>轻量级锁：如果偏向锁失败，则尝试轻量级锁。若加锁失败轻量级锁被其他线程争夺到，则转为重量级锁</strong></li><li><strong>自旋锁：在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取</strong></li><li><strong>锁消除：去除不可能存在共享资源竞争的锁</strong></li></ul></li></ul><hr><h2 id="4-3-ThreadLocal是与锁不同的另一个思路"><a href="#4-3-ThreadLocal是与锁不同的另一个思路" class="headerlink" title="4.3 ThreadLocal是与锁不同的另一个思路"></a>4.3 ThreadLocal是与锁不同的另一个思路</h2><ul><li><p><strong>除了锁可以保证线程安全，还可以通过增加资源来保证</strong></p></li><li><p><strong>ThreadLocal实际是Thread.ThreadLocalMap中一条记录的引用。而这个ThreadLocalMap实际上是在任何地方都可以访问到的。所以， <code>他实际是在存储全局变量，只不过这个全局变量比较特殊，每一个实例都跟一个线程绑定了。</code> 你在A线程set了这个变量进去，那这个变量只是A的，只有A线程运行时才能访问到，线程B是访问不到的，除非线程B也set一个，也就是所谓的每个线程持有一个副本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ThreadLocal的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//设置ThreadLocal的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//删除ThreadLocal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//初始化ThreadLocal的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>这里仅了解，后续会作专栏深入分析</strong></p></li></ul><hr><h2 id="4-4-CAS比较交换也是与锁不同的一种新思路"><a href="#4-4-CAS比较交换也是与锁不同的一种新思路" class="headerlink" title="4.4 CAS比较交换也是与锁不同的一种新思路"></a>4.4 CAS比较交换也是与锁不同的一种新思路</h2><ul><li><strong>CAS(V,E,N)三个参数，V表示要更新的变量，E表示预期值，N表示新值。</strong></li><li><strong>只有V=E时，才会更新V为N。否则宣布失败，并返回V当前值，并且不会被挂起，可再次尝试</strong></li><li><strong>简单的说，E就是你以为V应该是多少了，如果V不是你想的那样，说明已经被其他线程改过了，就得重新读，再次尝试就好了</strong></li></ul><h3 id="JDK并发包中的atomic包就是使用CAS理论："><a href="#JDK并发包中的atomic包就是使用CAS理论：" class="headerlink" title="JDK并发包中的atomic包就是使用CAS理论："></a>JDK并发包中的atomic包就是使用CAS理论：</h3><ul><li><strong>AtomicInteger：基于CAS理论的无锁的线程安全的整数，原理如图 incrementAndGet方法是使用CAS操作让自己+1</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC4%E7%AB%A0%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-1-锁的优化有哪些点？&quot;&gt;&lt;a href=&quot;#4-1-锁的优化有哪些点？&quot; class=&quot;headerlink&quot; title=&quot;4.1 锁的优化有哪些点？&quot;&gt;&lt;/a&gt;4.1 锁的优化有哪些点？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减少锁的持有时间：尽量避</summary>
      
    
    
    
    <category term="《Java高并发程序设计》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java并发" scheme="https://mactql.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第3章 JDK并发包</title>
    <link href="https://mactql.github.io/posts/4214418351.html"/>
    <id>https://mactql.github.io/posts/4214418351.html</id>
    <published>2021-07-27T13:56:00.000Z</published>
    <updated>2021-07-27T13:59:13.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-1-重入锁ReentrantLock和synchronized的区别"><a href="#3-1-1-重入锁ReentrantLock和synchronized的区别" class="headerlink" title="3.1.1 重入锁ReentrantLock和synchronized的区别"></a>3.1.1 重入锁ReentrantLock和synchronized的区别</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">    lock.lock();<span class="comment">//指定何时加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();<span class="comment">//指定何时解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ReentrantLock的特点：</strong><ul><li><strong>在等待锁的过程中，可以中断线程让他不再等待，lock.lockInterruptibly()</strong></li><li><strong>可以指定公平锁或者非公平锁</strong><ul><li><strong>公平锁的意思就是当锁可用时，先申请该锁的线程先获得锁</strong></li></ul></li><li><strong>提供了Condition类，可以实现synchronized类似wait/notify的功能</strong></li></ul></li><li><strong>当需要使用ReentrantLock这三个特点时使用，其他时候可以使用synchronized</strong></li></ul><hr><h2 id="3-1-3-信号量（Semaphore）"><a href="#3-1-3-信号量（Semaphore）" class="headerlink" title="3.1.3 信号量（Semaphore）"></a>3.1.3 信号量（Semaphore）</h2><ul><li><strong>用来指定同时可以有多少线程访问某个资源</strong></li></ul><hr><h2 id="3-1-4-ReadWriteLock读写锁"><a href="#3-1-4-ReadWriteLock读写锁" class="headerlink" title="3.1.4 ReadWriteLock读写锁"></a>3.1.4 ReadWriteLock读写锁</h2><ul><li><strong>读写锁是为了防止读操作和读操作之间不阻塞，读写锁访问约束如下图所示</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><hr><h2 id="3-1-5-倒计时器（CountDownLatch）"><a href="#3-1-5-倒计时器（CountDownLatch）" class="headerlink" title="3.1.5 倒计时器（CountDownLatch）"></a>3.1.5 倒计时器（CountDownLatch）</h2><ul><li><strong>适用场景：火箭发射</strong></li><li><strong>主线程在CountDownLatch上等待，当所有前置任务完成后，主线程再执行</strong></li></ul><hr><h2 id="3-2-线程池"><a href="#3-2-线程池" class="headerlink" title="3.2 线程池"></a>3.2 线程池</h2><h3 id="首先是线程池框架："><a href="#首先是线程池框架：" class="headerlink" title="首先是线程池框架："></a>首先是线程池框架：</h3><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h3 id="如何使用线程池？"><a href="#如何使用线程池？" class="headerlink" title="如何使用线程池？"></a>如何使用线程池？</h3><ul><li><strong>常用的线程池</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>手动创建线程池</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>线程池实现原理</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>即和corePoolSize、workQueue、maximumPoolSize比较</strong></li></ul><hr><h2 id="3-3-JDK并发容器（仅了解，后续专门出专栏深入分析）"><a href="#3-3-JDK并发容器（仅了解，后续专门出专栏深入分析）" class="headerlink" title="3.3 JDK并发容器（仅了解，后续专门出专栏深入分析）"></a>3.3 JDK并发容器（仅了解，后续专门出专栏深入分析）</h2><ul><li><strong>ConcurrentHashMap</strong></li><li><strong>CopyOnWriteArrayList</strong></li><li><strong>BlockingQueue</strong></li><li><strong>ConcurrentSkipListMap</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3-1-1-重入锁ReentrantLock和synchronized的区别&quot;&gt;&lt;a href=&quot;#3-1-1-重入锁ReentrantLock和synchronized的区别&quot; class=&quot;headerlink&quot; title=&quot;3.1.1 重入锁Reentra</summary>
      
    
    
    
    <category term="《Java高并发程序设计》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java并发" scheme="https://mactql.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第7章 类加载机制</title>
    <link href="https://mactql.github.io/posts/1316463453.html"/>
    <id>https://mactql.github.io/posts/1316463453.html</id>
    <published>2021-07-24T08:26:00.000Z</published>
    <updated>2021-07-24T12:19:53.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类从被加载到JVM到卸载出内存的完整生命周期？"><a href="#类从被加载到JVM到卸载出内存的完整生命周期？" class="headerlink" title="类从被加载到JVM到卸载出内存的完整生命周期？"></a>类从被加载到JVM到卸载出内存的完整生命周期？</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC7%E7%AB%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="说一下各个步骤？"><a href="#说一下各个步骤？" class="headerlink" title="说一下各个步骤？"></a>说一下各个步骤？</h2><h3 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h3><ul><li><strong>查找并加载类文件的二进制数据</strong></li><li><strong>会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的数据的入口</strong></li></ul><h3 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h3><ul><li><strong>把已经读入内存的类的二进制数据放到虚拟机环境中，包括以下步骤：</strong><ul><li><strong>验证：确保被加载类的正确性</strong></li><li><strong>准备：为类的静态变量分配内存，并初始化</strong></li><li><strong>解析：把常量池中的符号引用替换为直接引用</strong></li></ul></li></ul><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化：</strong></h3><ul><li><strong>为类的静态变量赋初值</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类从被加载到JVM到卸载出内存的完整生命周期？&quot;&gt;&lt;a href=&quot;#类从被加载到JVM到卸载出内存的完整生命周期？&quot; class=&quot;headerlink&quot; title=&quot;类从被加载到JVM到卸载出内存的完整生命周期？&quot;&gt;&lt;/a&gt;类从被加载到JVM到卸载出内存的完</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第6章 Class文件结构</title>
    <link href="https://mactql.github.io/posts/3853486135.html"/>
    <id>https://mactql.github.io/posts/3853486135.html</id>
    <published>2021-07-24T02:12:00.000Z</published>
    <updated>2021-07-24T02:15:21.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Class文件？"><a href="#什么是Class文件？" class="headerlink" title="什么是Class文件？"></a>什么是Class文件？</h2><ul><li><strong>Class文件是一组以8字节为单位的字节流，各个数据项目按顺序紧凑排列</strong></li><li><strong>Class文件格式只有两种类型：无符号数和表</strong><ul><li><strong>无符号数是基本数据类型，如u1，u2，u4，u8代表1个字节，2个字节，4个字节，8个字节的无符号数</strong></li><li><strong>表是由多个无符号数和其他表组成的复合数据结构，一般名称以_info结尾</strong></li></ul></li></ul><hr><h2 id="具体说一下Class文件的结构？"><a href="#具体说一下Class文件的结构？" class="headerlink" title="具体说一下Class文件的结构？"></a>具体说一下Class文件的结构？</h2><ul><li><strong>首先头4个字节是魔数，有这4个字节的才是Class文件</strong></li><li><strong>后面第5、6字节是次版本号，第7、8字节是主版本号</strong></li><li><strong>第9字节开始是常量池，每个常量开头第一个字节表示常量池的某个项目标记，按照标记确定是哪个常量类型，第二个字节是长度，根据长度往后找这么多个字节表示常量</strong><ul><li><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC6%E7%AB%A0Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>常量池结束后两个字节代表访问标志，包括这个Class是类还是接口，是不是public，是不是abstract等</strong><ul><li><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC6%E7%AB%A0Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>访问标志之后是类索引、父类索引和接口索引集合</strong></li><li><strong>之后是字段表集合，用来描述类/接口中的变量，包括各种修饰符和引用常量池的常量</strong></li><li><strong>然后是方法表集合，和字段表几乎一样，用来描述类/接口中的方法</strong></li><li><strong>最后是属性表集合，字段表和方法表都可以拥有自己的属性表集合，例如栈深度、变量存储空间、行号等</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是Class文件？&quot;&gt;&lt;a href=&quot;#什么是Class文件？&quot; class=&quot;headerlink&quot; title=&quot;什么是Class文件？&quot;&gt;&lt;/a&gt;什么是Class文件？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Class文件是一组以8字节为单位的字节</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第3章 垃圾回收</title>
    <link href="https://mactql.github.io/posts/121600763.html"/>
    <id>https://mactql.github.io/posts/121600763.html</id>
    <published>2021-07-21T07:27:00.000Z</published>
    <updated>2021-07-21T07:30:58.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="怎么判断对象是否需要回收？"><a href="#怎么判断对象是否需要回收？" class="headerlink" title="怎么判断对象是否需要回收？"></a>怎么判断对象是否需要回收？</h2><blockquote><ul><li><strong>引用计数法：给对象添加一个<code>引用</code>计数器，每有一个地方<code>引用</code>它就+1，<code>引用</code>失效就-1，如果是0则回收。</strong><ul><li><strong>优点：效率高；缺点：无法回收循环<code>引用</code>的对象</strong></li></ul></li><li><strong>可达性分析法：当一个对象到GC Roots对象没有任何<code>引用</code>链，则回收</strong><ul><li><strong>GC Roots对象包括虚拟机栈帧中<code>引用</code>的对象、方法区静态变量/常量<code>引用</code>的对象、Native方法<code>引用</code>的对象</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/184604/33/14082/59596/60f395a6Ecd2724bd/d1c15f01625eb0f3.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li></ul></blockquote><hr><h2 id="那么如何判断对象是否被引用呢？"><a href="#那么如何判断对象是否被引用呢？" class="headerlink" title="那么如何判断对象是否被引用呢？"></a>那么如何判断对象是否被引用呢？</h2><blockquote><ul><li><strong>强引用：类似<code>Object obj = new Object()</code> ，只要强引用存在，就不会回收掉</strong></li><li><strong>软引用：用SoftReference来实现，用来描述还有用但非必需的对象，会在内存溢出之前回收</strong></li><li><strong>弱引用：用WeakReference来实现，用来描述非必需的对象，不管内存够不够在下一次垃圾回收时一定会被回收</strong></li><li><strong>虚引用：用PhantomReference来实现，虚引用的对象无法获得实例，随时都可能回收</strong></li></ul></blockquote><hr><h2 id="垃圾回收算法？"><a href="#垃圾回收算法？" class="headerlink" title="垃圾回收算法？"></a>垃圾回收算法？</h2><blockquote><ul><li><strong>标记-清除法：标记所有要回收的对象，然后回收</strong><ul><li><strong>缺点：效率不高且会产生大量不连续的内存碎片，导致分配大对象时频繁GC</strong></li><li><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/185383/8/14522/53934/60f3d996Ef41bae8f/d83aeb330f503134.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>复制算法：<strong><strong>一般用于新生代，</strong></strong>将内存分成两块，每次只使用一块，每次回收都复制到另一块上，清除原来的空间</strong><ul><li><strong>缺点：内存缩小一半，浪费</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/176921/26/14679/62356/60f3daffEd4c25677/15d4ef96862c0ab5.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li><li><strong>标记整理法：一般用于老年代，和标记清除法一样，但是在标记后先整理，然后再回收</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/43697/29/16010/52898/60f3dc75E1aa9490e/0e7b3d567b1f6e36.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul></blockquote><hr><h2 id="如何真正实现垃圾回收？"><a href="#如何真正实现垃圾回收？" class="headerlink" title="如何真正实现垃圾回收？"></a>如何真正实现垃圾回收？</h2><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/173645/25/20673/66480/60f7b9b6Ec08b96f1/62fb3ab1ee064160.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="具体介绍一下CMS？"><a href="#具体介绍一下CMS？" class="headerlink" title="具体介绍一下CMS？"></a>具体介绍一下CMS？</h3><ul><li><strong>CMS基于标记-清除法，目标为获取最短回收停顿时间的收集器</strong></li><li><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/182782/9/15017/89966/60f7bc62Ec7fa78c8/2c08336b28b74381.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li><li><strong>共分为四个步骤：</strong><ul><li><strong>初始标记：只标记一下GC Roots能连接的对象</strong></li><li><strong>并发标记：GC Roots tracing，即可达性分析</strong></li><li><strong>重新标记：修正并发标记期间因用户线程导致产生变动的对象的标记</strong></li><li><strong>并发清理：并发垃圾回收</strong></li></ul></li><li><strong>CMS优点：不停顿，并发执行。</strong></li><li><strong>缺点：并发执行对CPU资源压力大，且无法处理在处理过程中产生的垃圾，且标记清除法会产生垃圾碎片</strong></li></ul><h3 id="具体介绍一下G1？"><a href="#具体介绍一下G1？" class="headerlink" title="具体介绍一下G1？"></a>具体介绍一下G1？</h3><ul><li><strong>G1是当前垃圾收集器最前沿成果之一，采用标记整理法，且能精确控制停顿时间</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/174570/7/20663/93930/60f7c803Ea2dcff2e/f72746522c8fde5d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><ul><li><strong>和CMS很类似，但是G1会把内存分成多个独立的区域，并根据允许回收的时间优先回收垃圾最多的区域</strong></li></ul></li></ul><hr><h2 id="具体说一下新生代和老年代的对象"><a href="#具体说一下新生代和老年代的对象" class="headerlink" title="具体说一下新生代和老年代的对象"></a>具体说一下新生代和老年代的对象</h2><ul><li><strong>首先大多数情况，对象在新生代Eden区中分配。当Eden区空间不够时，会触发一次Minor GC（新生代GC）</strong></li><li><strong>大对象直接进入到老年代</strong></li><li><strong>长期存活的对象直接进入老年代。</strong><ul><li><strong>对象在Eden区出生并经过一次Minor GC仍然存活且能被Survivor区容纳，会被移动到Survivor区，并且设置年龄为1岁。每熬过一次Minor GC年龄就+1</strong></li><li><strong>如果Survivor区中相同年龄的所有对象大小总和大于Survivor区的一半，那么年龄大于等于该年龄的对象都去老年代</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;怎么判断对象是否需要回收？&quot;&gt;&lt;a href=&quot;#怎么判断对象是否需要回收？&quot; class=&quot;headerlink&quot; title=&quot;怎么判断对象是否需要回收？&quot;&gt;&lt;/a&gt;怎么判断对象是否需要回收？&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第2章 内存分配</title>
    <link href="https://mactql.github.io/posts/815353185.html"/>
    <id>https://mactql.github.io/posts/815353185.html</id>
    <published>2021-07-17T08:02:00.000Z</published>
    <updated>2021-07-18T01:29:05.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-2-JVM体系结构概览"><a href="#2-2-JVM体系结构概览" class="headerlink" title="2.2 JVM体系结构概览"></a>2.2 JVM体系结构概览</h2><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/173588/33/19717/156152/60f17a35Ee1bce496/2e168a5d18d9e86a.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h3 id="运行时数据区包含以下部分"><a href="#运行时数据区包含以下部分" class="headerlink" title="运行时数据区包含以下部分"></a>运行时数据区包含以下部分</h3><blockquote><ul><li><strong>程序计数器：（线程私有）</strong><ul><li><strong>一块较小的内存空间, 用来存储指向下一条指令的地址</strong></li><li><strong>这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域</strong></li></ul></li><li><strong>虚拟机栈：（线程私有）</strong><ul><li><strong>每个方法在执行的同时都会创建一个栈帧</strong></li><li><strong>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</strong></li></ul></li><li><strong>本地方法栈：（线程私有）</strong><ul><li><strong>和虚拟机栈类似，区别为此栈执行的是Native方法</strong></li></ul></li><li><strong>堆：（线程共享）</strong><ul><li><strong>创建的对象实例和数组都保存在堆中</strong></li><li><strong>运行时动态分配内存大小，自动垃圾回收</strong></li></ul></li><li><strong>方法区：（线程共享）</strong><ul><li><strong>用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></li></ul></li></ul></blockquote><hr><h3 id="栈、堆、方法区是怎么交互的？"><a href="#栈、堆、方法区是怎么交互的？" class="headerlink" title="栈、堆、方法区是怎么交互的？"></a>栈、堆、方法区是怎么交互的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMain</span> </span>&#123; <span class="comment">//运行时，JVM把AppMain的信息都放入方法区    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//main成员方法本身放入方法区。    </span></span><br><span class="line">        Sample test1 = <span class="keyword">new</span> Sample( <span class="string">&quot; 测试1 &quot;</span> ); <span class="comment">//test1是引用，所以放到栈区里，Sample是对象应该放到堆里         </span></span><br><span class="line">        test1.printName();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上述代码的JVM执行流程："><a href="#上述代码的JVM执行流程：" class="headerlink" title="上述代码的JVM执行流程："></a>上述代码的JVM执行流程：</h4><ul><li><strong>首先启动了一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中。这一过程称为AppMain类的加载过程。</strong></li><li><strong>接着，JVM定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：Sample test1 = new Sample(“测试1”);</strong><ul><li><strong>Java虚拟机一看，不就是建立一个Sample类的实例吗，简单，于是就直奔方法区（方法区存放已经加载的类的相关信息，如类、静态变量和常量）而去，先找到Sample类的类型信息再说。结果呢，嘿嘿，没找到，这会儿的方法区里还没有Sample类呢（即Sample类的类信息还没有进入方法区中）。可JVM也不是一根筋的笨蛋，于是，它发扬“自己动手，丰衣足食”的作风，立马加载了Sample类， 把Sample类的相关信息存放在了方法区中。</strong></li><li><strong>Sample类的相关信息加载完成后。Java虚拟机做的第一件事情就是在堆中为一个新的Sample类的实例分配内存，这个Sample类的实例持有着指向方法区的Sample类的类型信息的引用（Java中引用就是内存地址）。这里所说的引用，实际上指的是Sample类的类型信息在方法区中的内存地址，其实，就是有点类似于C语言里的指针啦~~，而这个地址呢，就存放了在Sample类的实例的数据区中。</strong></li><li><strong>然后位于“=”前的test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，test1这个局部变量会被JVM添加到执行main()方法的主线程的Java方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，test1这个局部变量持有指向Sample类的实例的引用（即内存地址）。</strong></li></ul></li><li><strong>JVM将继续执行后续指令，执行printName()方法。当JVM执行test1.printName()方法时，JVM根据局部变量test1持有的引用，定位到堆中的Sample类的实例，再根据Sample类的实例持有的引用，定位到方法区中Sample类的类型信息（包括①类，②静态变量，③静态方法，④常量和⑤成员方法），从而获取printName()成员方法的字节码，接着执行printName()成员方法包含的指令。</strong></li></ul><hr><h2 id="从垃圾回收的角度看java堆？"><a href="#从垃圾回收的角度看java堆？" class="headerlink" title="从垃圾回收的角度看java堆？"></a>从垃圾回收的角度看java堆？</h2><ul><li><p><strong>java堆从垃圾回收的角度上可以分为新生代和老年代</strong></p><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/172817/23/19826/38200/60f27e1eEb41c1672/5997f348a7e5fef9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><h3 id="具体说一下新生代和老年代？"><a href="#具体说一下新生代和老年代？" class="headerlink" title="具体说一下新生代和老年代？"></a>具体说一下新生代和老年代？</h3></li></ul></li><li><p><strong>新生代用来存放的是新分配的对象。经过垃圾回收没有回收掉的对象会被复制到老年代</strong></p></li><li><p><strong>老年代上的对象比新生代对象时间长，大对象直接进入老年代</strong></p></li><li><p><strong>以前的永久代已经被取代为元空间，不在虚拟机里，直接是本地内存</strong></p></li></ul><hr><h2 id="如何通过栈上的引用对象访问堆上的实例呢"><a href="#如何通过栈上的引用对象访问堆上的实例呢" class="headerlink" title="如何通过栈上的引用对象访问堆上的实例呢"></a>如何通过栈上的引用对象访问堆上的实例呢</h2><blockquote><ul><li><strong>主流有两种访问方式，一个是句柄池，另一个是直接指针</strong><ul><li><strong>句柄池：在java堆中划分一部分内存作为句柄池，包含指向实例数据和对象类型数据的指针，reference存储句柄池的地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/193984/7/13445/63957/60f28159E949248bb/1a210ba372c20357.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>直接指针：reference直接存储对象地址，实例对象包含对象类型数据的地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/172188/22/20053/78857/60f2833cE26949bb1/e6e29c6b872144d2.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-2-JVM体系结构概览&quot;&gt;&lt;a href=&quot;#2-2-JVM体系结构概览&quot; class=&quot;headerlink&quot; title=&quot;2.2 JVM体系结构概览&quot;&gt;&lt;/a&gt;2.2 JVM体系结构概览&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=&quot;lazyload pl</summary>
      
    
    
    
    <category term="《深入理解Java虚拟机》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java虚拟机" scheme="https://mactql.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>第2章 Java并行程序基础</title>
    <link href="https://mactql.github.io/posts/1877506347.html"/>
    <id>https://mactql.github.io/posts/1877506347.html</id>
    <published>2021-07-08T07:27:00.000Z</published>
    <updated>2021-07-08T07:32:31.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-1-进程和线程"><a href="#2-1-进程和线程" class="headerlink" title="2.1 进程和线程"></a>2.1 进程和线程</h2><ul><li><strong>进程是独立运行、资源分配的基本单位，程序运行起来就是进程</strong></li><li><strong>线程是资源调度的基本单位，一个进程可以有多个线程</strong></li></ul><h3 id="线程的生命周期如下："><a href="#线程的生命周期如下：" class="headerlink" title="线程的生命周期如下："></a>线程的生命周期如下：</h3><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/183619/38/12549/74295/60e2632cEb819b275/319a62e48ed7704f.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><blockquote><ul><li><strong>New状态表示刚刚创建的线程，还没开始执行，要start（）方法调用后才执行</strong></li><li><strong>线程执行时是RUNNABLE状态，表示一切资源都准备好了</strong></li><li><strong>如果遇到synchronized同步块，则会被阻塞BLOCKED</strong></li><li><strong>当线程中调用wait、join方法时，当前线程就会进入等待态WAITING，等待notify方法唤醒</strong></li><li><strong>当线程中调用wait(time)等方法时，当前线程就会进入有限时间等待态TIMED_WAITING</strong></li><li><strong>线程执行完毕后，就会进入TEAMINATED态</strong></li></ul></blockquote><hr><h2 id="新建线程的方法："><a href="#新建线程的方法：" class="headerlink" title="新建线程的方法："></a>新建线程的方法：</h2><ul><li><strong>参考文献：<a href="https://zhuanlan.zhihu.com/p/144694652">创建线程的方法</a></strong></li><li><strong>本质是两种方法</strong><ul><li><strong>继承 Thread 类 或者直接 匿名内部类</strong></li><li><strong>实现 Runnable 接口</strong></li></ul></li><li><strong>还有其他很多表现形式，但本质都是上面两种</strong><ul><li><strong>通过 ExecutorService 和 Callable 实现有返回值的线程 (这里仅作了解)</strong></li><li><strong>基于线程池的execute()，创建临时线程 (这里仅作了解)</strong></li></ul></li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line">ThreadDemo t1 = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable 接口创建线程类 ThreadDemo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程对象,传入Runnable实现类实例</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo());</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h3 id="通过-ExecutorService-和-Callable-实现有返回值的线程"><a href="#通过-ExecutorService-和-Callable-实现有返回值的线程" class="headerlink" title="通过 ExecutorService 和 Callable 实现有返回值的线程"></a><strong>通过 ExecutorService 和 Callable 实现有返回值的线程</strong></h3><ul><li><strong>我们需要在主线程中开启多个线程去执行一个任务，然后收集各个线程的返回结果并将最终结果进行汇总，这时就需要用到 Callable 接口</strong></li><li><strong>如果不需要返回值，仍然可以用Runnable</strong></li><li><strong>线程的返回结果为Future对象，isDone方法判断线程是否完成，get方法获取结果</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过实现Callable接口来创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CThread</span><span class="params">(String name )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写call()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建接收结果的列表集合</span></span><br><span class="line">List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">    <span class="comment">//创建线程对象</span></span><br><span class="line">    Callable c = <span class="keyword">new</span> CThread(<span class="string">&quot;线程&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将线程对象提交到线程池中，并将返回结果接收</span></span><br><span class="line">    Future future = pool.submit(c);</span><br><span class="line">    System.out.println(<span class="string">&quot;线程&quot;</span>+i+<span class="string">&quot;已经加入线程池&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将返回结果加入集合</span></span><br><span class="line">    list.add(future);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印返回结果</span></span><br><span class="line"><span class="keyword">for</span> (Future future : list) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get().toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="启动线程："><a href="#启动线程：" class="headerlink" title="启动线程："></a>启动线程：</h3><blockquote><ul><li><strong>start方法是新建线程并启动线程</strong></li><li><strong>run方法是启动当前线程，不会开启新线程</strong></li></ul></blockquote><hr><h2 id="线程终止和中断"><a href="#线程终止和中断" class="headerlink" title="线程终止和中断"></a>线程终止和中断</h2><ul><li><strong>终止线程不要用stop方法，会出现数据不一致问题</strong></li><li><strong>线程中断的方法：</strong><ul><li><strong>用interrupt，并且在while循环中通过if判断中断标志位即可</strong></li><li><strong>Thread.sleep(time)，让线程休眠</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程被中断。&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="2-3-初识volatile"><a href="#2-3-初识volatile" class="headerlink" title="2.3 初识volatile"></a>2.3 初识volatile</h2><blockquote><p><strong>作用：</strong></p><ul><li><strong>volatile是同步机制。读volatile变量之前，会让本地缓存失效，必须去主存中读最新值。写volatile变量会直接刷新到主存</strong></li><li><strong>volatile可以禁止指令重排</strong></li></ul><p><strong>缺点：不能保证i++的原子性</strong></p></blockquote><hr><h2 id="2-5-守护线程"><a href="#2-5-守护线程" class="headerlink" title="2.5 守护线程"></a>2.5 守护线程</h2><ul><li><strong>在线程start之前，setDaemon(true)方法可以设置守护线程</strong></li><li><strong>守护线程会在父线程结束后自动结束</strong></li></ul><hr><h2 id="2-7-初识synchronized"><a href="#2-7-初识synchronized" class="headerlink" title="2.7 初识synchronized"></a>2.7 初识synchronized</h2><h3 id="synchronized的作用："><a href="#synchronized的作用：" class="headerlink" title="synchronized的作用："></a>synchronized的作用：</h3><blockquote><ul><li><strong>和volatile一样都是为了实现线程安全，但是volatile不能真正做到线程安全，因为不能保证原子性</strong></li><li><strong>于是就有了synchronzied，用来实现线程同步。会对同步的代码加锁，只允许一个线程进入同步块</strong></li></ul></blockquote><h3 id="synchronized怎么用？"><a href="#synchronized怎么用？" class="headerlink" title="synchronized怎么用？"></a>synchronized怎么用？</h3><ul><li><p><strong>synchronized有三种用法：</strong></p><ul><li><p><strong>给对象加锁:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>给实例非静态方法加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(); <span class="comment">//在run方法内部调用synchronized非静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>给静态方法加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(); <span class="comment">//在run方法内部调用synchronized静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>synchrozied三种用法总结：</strong></p><ul><li><strong>对象锁和非静态方法都要用同一个Runnable实例创建线程，这样对同一个实例对象加锁，才能实现多线程的同步</strong></li><li><strong>静态方法实际上是对类加锁，所以即使是不同的Runnable实例，只要是同一个类，即可完成线程同步</strong></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-1-进程和线程&quot;&gt;&lt;a href=&quot;#2-1-进程和线程&quot; class=&quot;headerlink&quot; title=&quot;2.1 进程和线程&quot;&gt;&lt;/a&gt;2.1 进程和线程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程是独立运行、资源分配的基本单位，程序运行起来就是进程</summary>
      
    
    
    
    <category term="《Java高并发程序设计》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java并发" scheme="https://mactql.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第1章 走进并行世界</title>
    <link href="https://mactql.github.io/posts/2486601876.html"/>
    <id>https://mactql.github.io/posts/2486601876.html</id>
    <published>2021-07-04T08:42:00.000Z</published>
    <updated>2021-07-04T08:48:59.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-2-1-同步-异步、阻塞-非阻塞式调用"><a href="#1-2-1-同步-异步、阻塞-非阻塞式调用" class="headerlink" title="1.2.1 同步/异步、阻塞/非阻塞式调用"></a>1.2.1 同步/异步、阻塞/非阻塞式调用</h2><blockquote><ul><li><strong>同步异步关注的是调用完成时消息的通知方式</strong><ul><li><strong>同步是调用方一直问询发现完成</strong></li><li><strong>异步是一调用就立即返回，被调用方完成后会通知调用方已完成</strong></li></ul></li></ul></blockquote><p><strong><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-c8953552c4bbe4ab31d570b31680726e_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><blockquote><ul><li><strong>阻塞非阻塞关注的是发出请求到调用完成之间调用方的状态</strong><ul><li><strong>等待数据返回时设置为挂起态则为阻塞，不是挂起态则非阻塞</strong></li></ul></li></ul></blockquote><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-6507ab3517814b1b84fbff9a3eb31842_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><blockquote><ul><li><strong>举个例子：</strong><ul><li><strong>老张把水壶放到火上，立等水开。（同步阻塞）</strong></li><li><strong>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）</strong></li><li><strong>老张把响水壶放到火上，立等水开。（异步阻塞）</strong></li><li><strong>老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</strong></li></ul></li></ul></blockquote><hr><h2 id="1-2-2-并发和并行"><a href="#1-2-2-并发和并行" class="headerlink" title="1.2.2 并发和并行"></a>1.2.2 并发和并行</h2><ul><li><strong>并发指的是多个进程宏观上同时进行，微观上交替进行</strong></li><li><strong>并行是真的多个进程同时执行，只存在于多CPU的系统中，有几个CPU就能并行几个线程</strong></li></ul><hr><h2 id="1-2-3-临界区"><a href="#1-2-3-临界区" class="headerlink" title="1.2.3 临界区"></a>1.2.3 临界区</h2><ul><li><strong>临界区是访问临界资源的代码段，每一次只能一个线程使用，其他线程等待</strong></li></ul><hr><h2 id="1-2-5-死锁、饥饿、活锁"><a href="#1-2-5-死锁、饥饿、活锁" class="headerlink" title="1.2.5 死锁、饥饿、活锁"></a>1.2.5 死锁、饥饿、活锁</h2><ul><li><strong>死锁：至少两个进程/线程一起死锁，都处于阻塞态</strong></li><li><strong>饥饿：进程/线程一直无法获得资源，例如优先级太低一直排不到它</strong></li></ul><hr><h2 id="1-5-java内存模型（JMM）"><a href="#1-5-java内存模型（JMM）" class="headerlink" title="1.5 java内存模型（JMM）"></a>1.5 java内存模型（JMM）</h2><ul><li><strong>原子性：多线程执行时，每个线程执行完之前不能被其他线程干扰（例如在32位系统多线程写long数据）</strong></li><li><strong>可见性：一个线程修改了共享变量的值，其他线程能否立即知道这个修改</strong></li><li><strong>有序性：在并发时，指令重排导致程序的执行可能就会出现乱序</strong></li></ul><h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/179590/20/12542/217760/60e166d7E2012bb7e/572e1bf3a2494979.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>堆：运行时动态的分配内存大小，垃圾回收</strong></li><li><strong>栈：存在栈中的数据可以共享，主要存放基本数据类型</strong></li><li><strong>如图所示，如果两个线程同时调用了同一个对象Object3，都可以访问这个对象的成员变量，但是线程拥有的是对象的私有拷贝，保存在线程的本地内存中，然后再写回内存中，但是这样会出错，需要保证原子性可见性有序性，需要JMM</strong></li></ul><hr><h2 id="1-5-4-Happen-Before规则"><a href="#1-5-4-Happen-Before规则" class="headerlink" title="1.5.4 Happen-Before规则"></a>1.5.4 Happen-Before规则</h2><p><strong>参考文献：</strong>   <a href="https://zhuanlan.zhihu.com/p/126275344">知乎原文</a></p><ol><li><strong>程序顺序原则：一个线程内根据代码顺序执行</strong></li><li><strong>锁原则：解锁（unlock）要在加锁（lock）之前</strong></li></ol><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/178159/15/12705/185557/60e16f07Eb88abc9f/db76f74baff73153.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ol start="3"><li><strong>volatile规则：volatile变量的写要在读之前，结合第四条传递性一起看</strong></li><li><strong>传递性：A先于B，B先于C，则A必然先于C</strong></li></ol><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/190326/18/11645/76630/60e170b2E2dc2acb6/5a441ab952fe5a9b.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><br><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/185824/18/12742/225582/60e17159Ef4a811f4/eea05b6cd1ea0969.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ol start="5"><li><strong>start()原则：主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作</strong></li><li><strong>join()原则：线程 A 调用线程 B.join()让线程B插到A前面，那么线程B的任何操作都要先于A</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-2-1-同步-异步、阻塞-非阻塞式调用&quot;&gt;&lt;a href=&quot;#1-2-1-同步-异步、阻塞-非阻塞式调用&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 同步/异步、阻塞/非阻塞式调用&quot;&gt;&lt;/a&gt;1.2.1 同步/异步、阻塞/非阻塞式调用&lt;/</summary>
      
    
    
    
    <category term="《Java高并发程序设计》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java并发" scheme="https://mactql.github.io/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第7章 确保Web安全的HTTPS</title>
    <link href="https://mactql.github.io/posts/976065235.html"/>
    <id>https://mactql.github.io/posts/976065235.html</id>
    <published>2021-07-03T00:54:00.000Z</published>
    <updated>2021-07-03T00:59:34.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-1-HTTP的缺点："><a href="#7-1-HTTP的缺点：" class="headerlink" title="7.1 HTTP的缺点："></a>7.1 HTTP的缺点：</h2><blockquote><ul><li><strong>用明文通信（不加密），有可能会被窃听</strong></li><li><strong>不验证身份，可能伪装</strong></li><li><strong>无法保证报文的完整性，可能被篡改</strong></li></ul></blockquote><hr><h2 id="7-2-HTTP-加密-认证-完整性保护-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="7.2 HTTP+加密+认证+完整性保护=HTTPS"></a>7.2 HTTP+加密+认证+完整性保护=HTTPS</h2><h3 id="7-2-3-HTTPS是怎么加密的？"><a href="#7-2-3-HTTPS是怎么加密的？" class="headerlink" title="7.2.3 HTTPS是怎么加密的？"></a>7.2.3 HTTPS是怎么加密的？</h3><blockquote><ul><li><strong>对称加密：加密和解密使用同一密钥</strong><ul><li><strong>优点：运算速度快</strong></li><li><strong>缺点：无法安全地将密钥传输给通信方</strong></li></ul></li><li><strong>非对称加密：公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密</strong><ul><li><strong>优点：可以更安全地将公开密钥传输给通信发送方</strong></li><li><strong>缺点：运算速度慢</strong></li></ul></li><li><strong>HTTPS使用的是混合加密方式，有对称加密和非对称加密</strong><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/179946/21/12811/146203/60dfb051Ee0f63dc7/6602dc2628972ddf.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li></ul></blockquote><h2 id="7-2-4-认证"><a href="#7-2-4-认证" class="headerlink" title="7.2.4 认证"></a>7.2.4 认证</h2><h4 id="首先为什么要认证？"><a href="#首先为什么要认证？" class="headerlink" title="首先为什么要认证？"></a>首先为什么要认证？</h4><ul><li><strong>为了保证对称加密的公开密钥没有被攻击者替换，这就要用到认证</strong></li></ul><h4 id="如何认证？"><a href="#如何认证？" class="headerlink" title="如何认证？"></a>如何认证？</h4><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/173987/39/17987/253550/60dfb2abEcc926303/7afefaf1b5014ae7.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;7-1-HTTP的缺点：&quot;&gt;&lt;a href=&quot;#7-1-HTTP的缺点：&quot; class=&quot;headerlink&quot; title=&quot;7.1 HTTP的缺点：&quot;&gt;&lt;/a&gt;7.1 HTTP的缺点：&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用明文</summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第4章 返回结果的HTTP状态码</title>
    <link href="https://mactql.github.io/posts/1773229755.html"/>
    <id>https://mactql.github.io/posts/1773229755.html</id>
    <published>2021-07-02T07:10:00.000Z</published>
    <updated>2021-07-02T07:14:52.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-状态码的分类"><a href="#4-1-状态码的分类" class="headerlink" title="4.1 状态码的分类"></a>4.1 状态码的分类</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/186965/26/11407/111567/60deaf6bE2a15aa4e/598cf017ef7700cc.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 <code>2XX</code> 成功</h2><ul><li><strong><code>200</code> ：表示从客户端发来的请求被正常处理，并返回数据</strong></li><li><strong><code>204</code> ：和<code>200</code>一样，但是不返回任何数据，只返回是否成功</strong></li><li><strong><code>206</code> ：表示客户端进行的范围请求被正常处理，并返回数据</strong></li></ul><hr><h2 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 <code>3XX</code> 重定向</h2><ul><li><strong><code>301</code> ：永久性重定向，请求的资源被分配到新的URI，浏览器输入的网址会瞬间跳转到新URI，原先的网址不可用</strong></li><li><strong><code>302</code> ：临时性重定向，请求的资源被分配到新的URI，浏览器输入的网址会瞬间跳转到新URI，原先的网址仍可用</strong></li><li><strong><code>303</code> ：把POST提交重定向到GET，例如POST一份个人信息，服务器返回<code>303</code>，重定向到一个上传成功的页面</strong></li><li><strong><code>307</code> ：和<code>302</code>一摸一样，但是不允许POST到GET的重定向</strong></li></ul><hr><h2 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 <code>4XX</code> 客户端错误</h2><ul><li><strong><code>400</code> ：表示HTTP请求报文中有语法错误</strong></li><li><strong><code>401</code> ：表示HTTP请求需要登陆认证，或者认证失败</strong></li><li><strong><code>403</code> ：表示需要的资源没有权限访问</strong></li><li><strong><code>404</code> ：表示需要访问的资源不存在</strong></li></ul><hr><h2 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 <code>5XX</code> 服务器错误</h2><ul><li><strong><code>501</code> ：服务器执行请求时发生错误</strong></li><li><strong><code>503</code> ：服务器处于超负载或停机维护</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-1-状态码的分类&quot;&gt;&lt;a href=&quot;#4-1-状态码的分类&quot; class=&quot;headerlink&quot; title=&quot;4.1 状态码的分类&quot;&gt;&lt;/a&gt;4.1 状态码的分类&lt;/h2&gt;&lt;p&gt;&lt;img &quot;&quot; class=&quot;lazyload placeholder&quot; d</summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>第2章 简单的HTTP协议</title>
    <link href="https://mactql.github.io/posts/53019385.html"/>
    <id>https://mactql.github.io/posts/53019385.html</id>
    <published>2021-07-02T02:27:00.000Z</published>
    <updated>2021-07-02T02:29:28.926Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="2-2-HTTP请求和响应报文格式"><a href="#2-2-HTTP请求和响应报文格式" class="headerlink" title="2.2 HTTP请求和响应报文格式"></a>2.2 HTTP请求和响应报文格式</h2><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/180478/2/12183/160617/60de6ccaE6ddb17a3/758649c3c46df958.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="2-5-常用HTTP方法有哪些？"><a href="#2-5-常用HTTP方法有哪些？" class="headerlink" title="2.5 常用HTTP方法有哪些？"></a>2.5 常用HTTP方法有哪些？</h2><blockquote><ul><li><strong>GET：请求访问服务器某个资源</strong></li><li><strong>POST：和GET对应，传输某个资源</strong></li><li><strong>PUT：传输某个文件</strong></li><li><strong>HEAD：与GET相同，但只想获得报文首部，不返回数据，例如想要查询某个资源是否存在，不需要获取数据</strong></li><li><strong>DELETE：删除服务器某个资源</strong></li><li><strong>OPTIONS：查询URI某个资源支持的方法，例如返回GET、POST</strong></li></ul></blockquote><hr><h2 id="2-8-Cookie"><a href="#2-8-Cookie" class="headerlink" title="2.8 Cookie"></a>2.8 Cookie</h2><h3 id="为什么要cookie？"><a href="#为什么要cookie？" class="headerlink" title="为什么要cookie？"></a>为什么要cookie？</h3><p>要求登陆认证的web页面无法保存登陆状态，每次跳转页面都要再次登陆，为了避免这种频繁登陆，需要cookie保存登陆状态</p><h3 id="怎么使用cookie？"><a href="#怎么使用cookie？" class="headerlink" title="怎么使用cookie？"></a>怎么使用cookie？</h3><ul><li><strong>第一次登陆后，服务器返回响应，响应报文中添加一个cookie通知客户端保存cookie</strong></li><li><strong>以后每次请求，在报文中都添加一个cookie值，服务器检查cookie值的记录，有的话就不需要登陆了</strong></li></ul><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/190040/20/11105/187775/60de788dE6941cef1/6043b1e603cef490.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;2-2-HTTP请求和响应报文格式&quot;&gt;&lt;a href=&quot;#2-2-HTTP请求和响应报文格式&quot; class=&quot;headerlink&quot; title=&quot;2.2 HTTP请求和响应报文格式&quot;&gt;&lt;/a&gt;2.2 HTTP请求和响应报文格式&lt;/h2&gt;&lt;p&gt;&lt;img </summary>
      
    
    
    
    <category term="《图解HTTP》读书笔记" scheme="https://mactql.github.io/categories/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://mactql.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
