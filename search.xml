<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第15章 泛型</title>
      <link href="/2021/06/18/%E7%AC%AC15%E7%AB%A0%20%E6%B3%9B%E5%9E%8B/"/>
      <url>/2021/06/18/%E7%AC%AC15%E7%AB%A0%20%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="15-2-简单泛型"><a href="#15-2-简单泛型" class="headerlink" title="15.2 简单泛型"></a>15.2 简单泛型</h2><p><strong>在没有泛型之前，采用的是继承机制来实现泛型，但是需要强制类型转换，会有风险</strong></p><h3 id="创建泛型类："><a href="#创建泛型类：" class="headerlink" title="创建泛型类："></a>创建泛型类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">T ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建泛型对象</span></span><br><span class="line">A&lt;..&gt; a = <span class="keyword">new</span> A&lt;&gt;();</span><br></pre></td></tr></table></figure><hr><h3 id="15-2-1-使用泛型创建多维元祖，实现一次调用返回多个对象"><a href="#15-2-1-使用泛型创建多维元祖，实现一次调用返回多个对象" class="headerlink" title="15.2.1 使用泛型创建多维元祖，实现一次调用返回多个对象"></a>15.2.1 使用泛型创建多维元祖，实现一次调用返回多个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>,...&gt;</span>&#123;<span class="comment">//A,B,C是泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second; <span class="comment">// 使用final使得客户端程序员无法修改，相当于private+getset方法</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(A a,B b)</span></span>&#123;first = a;second = b;&#125; <span class="comment">//构造器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="15-3-泛型接口"><a href="#15-3-泛型接口" class="headerlink" title="15.3 泛型接口"></a>15.3 泛型接口</h2><p><strong><code>public interface Generator&lt;T&gt; &#123;T next();&#125;</code></strong></p><h3 id="实现接口："><a href="#实现接口：" class="headerlink" title="实现接口："></a>实现接口：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Integer</span>&gt;</span>&#123; <span class="comment">//指定泛型T具体类型，可以是包装类数据类型也可以是自定义类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span></span>&#123; <span class="comment">// 重写接口中的方法</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-4-泛型方法"><a href="#15-4-泛型方法" class="headerlink" title="15.4 泛型方法"></a>15.4 泛型方法</h2><h3 id="为什么要用泛型方法？"><a href="#为什么要用泛型方法？" class="headerlink" title="为什么要用泛型方法？"></a>为什么要用泛型方法？</h3><ul><li><strong>因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活</strong></li><li><strong>使用泛型类，创建对象时必须指定泛型具体类型；而使用泛型方法，则不必指定，编译器会根据参数自动判断</strong></li></ul><h3 id="泛型方法定义"><a href="#泛型方法定义" class="headerlink" title="泛型方法定义"></a>泛型方法定义</h3><p><strong>泛型参数列表必须置于返回值之前前，泛型方法的类可以是泛型类也可以不是</strong></p><blockquote><ul><li><strong><code>public &lt;T&gt; void f(T x)&#123;...&#125;</code></strong></li><li><strong><code>public &lt;T,E&gt; E f(T a, E b) &#123;...&#125;</code></strong></li><li><strong><code>public  static &lt;T&gt; T f(T a)&#123;&#125;</code>  //泛型静态方法定义</strong></li></ul></blockquote><p><strong>显式指定类型调用泛型方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T x)</span></span>&#123;<span class="comment">//泛型方法</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">staticfun</span><span class="params">(T x)</span></span>&#123; <span class="comment">//静态泛型方法</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> main&#123;</span><br><span class="line">    A&lt;Integer&gt; a = <span class="keyword">new</span> A&lt;&gt;();</span><br><span class="line">        a.&lt;String&gt;fun(<span class="string">&quot;abc&quot;</span>); <span class="comment">//指定泛型具体类型调用泛型方法</span></span><br><span class="line">        A.&lt;String&gt;staticfun(<span class="string">&quot;abc&quot;</span>); <span class="comment">//指定泛型具体类型调用静态泛型方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="15-7-擦除"><a href="#15-7-擦除" class="headerlink" title="15.7 擦除"></a>15.7 擦除</h2><h3 id="什么是擦除："><a href="#什么是擦除：" class="headerlink" title="什么是擦除："></a>什么是擦除：</h3><ul><li><p><strong>泛型具体类型不同擦除后会变成原生类 如List<String> 和List<Integer>是一种类型，最后都会擦除成List</strong></p></li><li><p><strong>泛型只是用来检查类型正确性，一旦运行就会被擦除</strong></p><h3 id="擦除的结果："><a href="#擦除的结果：" class="headerlink" title="擦除的结果："></a>擦除的结果：</h3></li><li><p><strong><code>List&lt;T&gt;</code>被擦除为<code>List</code>  、  <code>List&lt;String&gt;</code>被擦除为<code>List&lt;Object&gt;</code></strong></p></li><li><p><strong><code>&lt;T extends  A&gt;</code>擦除为<code>&lt;A&gt;</code></strong></p></li></ul><h3 id="什么是边界："><a href="#什么是边界：" class="headerlink" title="什么是边界："></a>什么是边界：</h3><ul><li><strong>运行后泛型会被擦除到上边界</strong></li><li><strong><code>class A&lt;T extends B&gt;</code>擦除到<code>&lt;B&gt;</code></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第13章 字符串</title>
      <link href="/2021/06/16/%E7%AC%AC13%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/06/16/%E7%AC%AC13%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="13-1-不可变String"><a href="#13-1-不可变String" class="headerlink" title="13.1 不可变String"></a>13.1 不可变String</h2><p><strong>String类中修改String的方法都是创建新的String，最初的String不变</strong></p><h2 id="13-2-String中’-’-和StringBuilder"><a href="#13-2-String中’-’-和StringBuilder" class="headerlink" title="13.2 String中’+’ 和StringBuilder"></a>13.2 String中’+’ 和StringBuilder</h2><p><strong>String中的 ‘+’ 每次编译器会自动优化创建一个StringBuilder对象，使用其append（）方法。</strong></p><blockquote><p><strong>‘+’ 和StringBuilder使用场景：</strong></p><ul><li><strong>若对字符串操作比较简单，可以用 ‘+’ ，信赖编译器自动优化</strong></li><li><strong>若需要用循环对字符串进行操作，最好自己创建StringBuilder对象</strong></li></ul></blockquote><h3 id="StringBuilder常用方法"><a href="#StringBuilder常用方法" class="headerlink" title="StringBuilder常用方法"></a>StringBuilder常用方法</h3><blockquote><ul><li><strong>Stringbuilder insert(int offset , String s/char c)          在位置之前插入String或char</strong></li><li><strong>Stringbuilder append(String s)                                  字符串拼接</strong></li><li><strong>Stringbuilder replace(int start , int end , String s)       替换[ , ) 字符串</strong></li><li><strong>Stringbuilder delete(int start , int end)                       删除[ , ) 字符串</strong></li><li><strong>String toString()                                                      返回字符串</strong></li></ul></blockquote><h2 id="13-4-String常用方法"><a href="#13-4-String常用方法" class="headerlink" title="13.4 String常用方法"></a>13.4 String常用方法</h2><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/181445/2/9464/261049/60c94bfdE276da18f/707e4518ef45b22c.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第14章 反射</title>
      <link href="/2021/06/16/%E7%AC%AC14%E7%AB%A0%20%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/06/16/%E7%AC%AC14%E7%AB%A0%20%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p><strong>反射是在运行时动态访问类和对象的技术</strong></p><h2 id="为什么要用反射？"><a href="#为什么要用反射？" class="headerlink" title="为什么要用反射？"></a>为什么要用反射？</h2><blockquote><ul><li><strong>实例化对象用new关键字，但是这样就把实例化的工作固定在程序中，不灵活会出现各种问题。</strong></li><li><strong>反射可以将创建对象的时机从编译时延迟到程序运行时</strong></li><li><strong>当添加新的功能时，如果不用反射将需要修改代码，修改完需要重新上线非常麻烦，而用反射则没有这个问题</strong></li></ul></blockquote><h2 id="14-2-Class对象"><a href="#14-2-Class对象" class="headerlink" title="14.2 Class对象"></a>14.2 Class对象</h2><blockquote><p><strong>在程序运行时，Class对象保存了类和对象的具体信息。</strong><br><strong>每个类都有一个Class对象，每当编译一个类，即.java编译成.class文件，就会产生一个Class对象保存在.class文件中</strong></p></blockquote><h2 id="类加载器："><a href="#类加载器：" class="headerlink" title="类加载器："></a>类加载器：</h2><blockquote><p><strong>java程序在运行之前并非完全加载：</strong></p><ul><li><strong>第一次使用这个类，就动态加载到JVM中。当创建第一个对类的静态成员的引用或者构造器时就会加载这个类</strong></li></ul></blockquote><blockquote><p><strong>类加载器工作步骤：</strong></p><ol><li><strong>首先检查一个类的Class对象（或理解.class文件）是否已被加载</strong></li><li><strong>如果尚未加载，默认的类加载器就会根据类名查找.class文件</strong></li><li><strong>一旦Class对象（.class文件）被加载了（载入jvm），它就被用来创建这个类的所有对象</strong></li></ol></blockquote><h3 id="获取Class对象的引用"><a href="#获取Class对象的引用" class="headerlink" title="获取Class对象的引用"></a>获取Class对象的引用</h3><blockquote><p><code>**Class对象 = Class.forName(&quot;...&quot; )**</code><strong>可以返回指定Class对象的引用，并且若指定的类没有被加载，就加载它</strong><br><strong>如果没有Class对象，可以用forName获取。如果已经有一个Class对象，则可以用<code>getClass（)</code> 方法获取Class引用</strong></p></blockquote><hr><h2 id="Class常用方法"><a href="#Class常用方法" class="headerlink" title="Class常用方法"></a>Class常用方法</h2><blockquote><ul><li><strong>Class.forName(“Class path”)           获取指定Class对象</strong></li><li>**Class对象.newInstance()                  使用默认构造器构造对象 **</li><li><strong>Class对象.getConstructor()              获取指定的 public修饰构造方法 Constructor对象</strong></li><li><strong>Class对象.getMethod()                    获取指定的 public修饰方法 Method对象</strong></li><li><strong>Class对象.getField()                        获取指定的 public修饰成员变量 Field对象</strong></li></ul></blockquote><h2 id="使用带参构造方法创建对象（反射）"><a href="#使用带参构造方法创建对象（反射）" class="headerlink" title="使用带参构造方法创建对象（反射）"></a>使用带参构造方法创建对象（反射）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="class"><span class="keyword">class</span>对象 </span>= Class.forName(<span class="string">&quot; Class路径 &quot;</span>);</span><br><span class="line">Constructor constructor = <span class="class"><span class="keyword">class</span>对象.<span class="title">getConstructor</span>(<span class="title">new</span> <span class="title">Class</span>[]</span>&#123; <span class="comment">//通过构造器的参数获取构造器对象</span></span><br><span class="line"><span class="comment">//带参构造器的参数</span></span><br><span class="line">    String.class , Float.class,...</span><br><span class="line">&#125;);</span><br><span class="line">E 类的对象 = (E) constructor.newInstance(<span class="keyword">new</span> Object[]&#123; <span class="comment">//通过构造器对象</span></span><br><span class="line">    <span class="comment">//传递参数给带参构造器</span></span><br><span class="line">    <span class="string">&quot;...&quot;</span>,...,<span class="string">&quot;...&quot;</span>,...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="使用反射调用方法"><a href="#使用反射调用方法" class="headerlink" title="使用反射调用方法"></a>使用反射调用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="class"><span class="keyword">class</span>对象 </span>= Class.forName(<span class="string">&quot; Class路径 &quot;</span>);</span><br><span class="line">Method method = <span class="class"><span class="keyword">class</span>对象.<span class="title">getMethod</span>(&quot;方法名&quot;,<span class="title">new</span> <span class="title">Class</span>[]</span>&#123;</span><br><span class="line"><span class="comment">//构造器的参数</span></span><br><span class="line">    String.class , Float.class,...</span><br><span class="line">&#125;); <span class="comment">//通过方法名和方法的参数获取方法并返回方法对象</span></span><br><span class="line">method.invoke(类的对象,参数...);<span class="comment">//通过哪个类的对象调用这个方法以及方法参数来执行方法</span></span><br></pre></td></tr></table></figure><h2 id="使用反射获取成员对象"><a href="#使用反射获取成员对象" class="headerlink" title="使用反射获取成员对象"></a>使用反射获取成员对象</h2><p><strong>获取到成员对象后可以通过get或者set获取数据或修改数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="class"><span class="keyword">class</span>对象 </span>= Class.forName(<span class="string">&quot; Class路径 &quot;</span>);</span><br><span class="line">Field field = <span class="class"><span class="keyword">class</span>对象.<span class="title">getField</span>(&quot;成员对象名&quot;)</span>; <span class="comment">// 通过变量名获取成员对象</span></span><br><span class="line">print(field.get(类的对象)); <span class="comment">// 通过哪个类的对象获取变量</span></span><br><span class="line">field.set(类的对象,需要修改的值); <span class="comment">//修改变量</span></span><br></pre></td></tr></table></figure><p><strong>如果要获取非public则都采用getDeclaredXXX</strong></p>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第11章 持有对象</title>
      <link href="/2021/06/15/%E7%AC%AC11%E7%AB%A0%20%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/06/15/%E7%AC%AC11%E7%AB%A0%20%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="11-2-基本概念"><a href="#11-2-基本概念" class="headerlink" title="11.2 基本概念"></a>11.2 基本概念</h2><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/194804/21/8107/119987/60c80d9eE646309f6/14b69fd5d3d42e6d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><blockquote><p><strong>Collection接口：</strong></p><ul><li><strong>List接口：</strong><ul><li><strong>LinkedList：链表，没有同步，线程不安全</strong></li><li><strong>ArrayList：数组，没有同步，线程不安全</strong></li><li><strong>Vector：数组，同步，线程安全</strong><ul><li><strong>Stack：继承Vector，线程安全</strong></li></ul></li></ul></li><li><strong>Set接口：不可重复，内部排序</strong><ul><li><strong>HashSet：散列函数</strong><ul><li><strong>LinkedHashSet：链表维护元素的插入次序</strong></li></ul></li><li><strong>TreeSet：底层为红黑树，自动升序排序保存</strong></li></ul></li></ul></blockquote><blockquote><p><strong>Map接口：</strong></p><ul><li><strong>HashMap：查找最快，无顺序 ，没有同步， 线程不安全</strong><ul><li><strong>LinkedHashMap：保留HashMap的速度，按照插入顺序保存</strong></li></ul></li><li><strong>TreeMap：红黑树，自动升序排序保存</strong></li><li><strong>Hashtable：接口实现类， 同步， 线程安全</strong></li></ul></blockquote><h2 id="11-3-Collection接口方法"><a href="#11-3-Collection接口方法" class="headerlink" title="11.3 Collection接口方法"></a>11.3 Collection接口方法</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/179128/17/9179/165707/60c74ba0E32f5b85a/9a68e43c3f21496a.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="11-5-List接口"><a href="#11-5-List接口" class="headerlink" title="11.5 List接口"></a>11.5 List接口</h2><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/177265/15/8483/192890/60c80984Ec5274ff2/a5c5d7852650e1ad.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="11-6-迭代器Iterator"><a href="#11-6-迭代器Iterator" class="headerlink" title="11.6 迭代器Iterator"></a>11.6 迭代器Iterator</h2><blockquote><p><strong>Iterator：</strong></p><ul><li><strong>iterator（） 返回一个iterator，将准备好返回序列第一个元素</strong></li><li><strong>next（） 获得序列下一个元素</strong></li><li><strong>hasNext（） 判断序列是否还有元素</strong></li><li><strong>remove（）将迭代器返回的元素删除</strong></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;...&gt; it = a.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">print(it.next());</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果只想遍历List，不想修改，应该用foreach</strong></p><h3 id="11-6-1-ListIterator"><a href="#11-6-1-ListIterator" class="headerlink" title="11.6.1 ListIterator"></a>11.6.1 ListIterator</h3><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/174547/24/14667/332001/60c81452E423a1227/7973fcdf1a3097f0.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="11-9-Set"><a href="#11-9-Set" class="headerlink" title="11.9 Set"></a>11.9 Set</h2><blockquote><p><strong>Set和List的区别：</strong></p><ul><li><strong>List元素可以重复，Set不能重复</strong></li><li><strong>List可以根据索引操作元素，Set不能</strong></li><li><strong>List按照插入顺序保存，Set不一定</strong></li></ul></blockquote><hr><h2 id="11-10-Map"><a href="#11-10-Map" class="headerlink" title="11.10 Map"></a>11.10 Map</h2><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/195266/31/8254/290736/60c84667E2b4c4f75/101c49f5fe6ff436.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="11-11-Queue"><a href="#11-11-Queue" class="headerlink" title="11.11 Queue"></a>11.11 Queue</h2><p><strong>Collection-》Queue-》LinkedList</strong><br><strong>创建一个队列：<code>Queue&lt;...&gt; queue = new LinkedList&lt;...&gt;()</code></strong></p><h3 id="Queue方法"><a href="#Queue方法" class="headerlink" title="Queue方法"></a>Queue方法</h3><blockquote><ul><li><strong>继承自Collection，特殊方法如下：</strong><ul><li><strong>boolean offer（） 将元素插入队尾，或返回false</strong></li><li><strong>E peek（） 返回队头，若队列为空则返回null</strong></li><li><strong>E poll（） 删除队头并返回，若队列为空返回null</strong></li></ul></li></ul></blockquote><h3 id="11-11-1-PriorityQueue"><a href="#11-11-1-PriorityQueue" class="headerlink" title="11.11.1 PriorityQueue"></a>11.11.1 PriorityQueue</h3><ul><li><strong>自定义优先级比较器，作为优先队列构造器的参数。</strong></li><li><strong>优先队列继承自Queue，有同样的方法。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义比较器，降序排列</span></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Integer&gt; cmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer e1, Integer e2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e2 - e1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不用比较器，默认升序排列</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        q.add(<span class="number">3</span>);</span><br><span class="line">        q.add(<span class="number">2</span>);</span><br><span class="line">        q.add(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(q.poll()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果</span></span><br><span class="line"><span class="comment">         * 2 3 4</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//使用自定义比较器，降序排列</span></span><br><span class="line">        Queue&lt;Integer&gt; qq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);</span><br><span class="line">        qq.add(<span class="number">3</span>);</span><br><span class="line">        qq.add(<span class="number">2</span>);</span><br><span class="line">        qq.add(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">while</span>(!qq.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(qq.poll()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第12章 异常</title>
      <link href="/2021/06/15/%E7%AC%AC12%E7%AB%A0%20%E5%BC%82%E5%B8%B8/"/>
      <url>/2021/06/15/%E7%AC%AC12%E7%AB%A0%20%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="异常类型："><a href="#异常类型：" class="headerlink" title="异常类型："></a>异常类型：</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/193416/23/8345/103204/60c85e4cEf4c28547/920bb04309c42c67.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="12-4-创建自定义异常"><a href="#12-4-创建自定义异常" class="headerlink" title="12.4 创建自定义异常"></a>12.4 创建自定义异常</h2><blockquote><p><strong>创建自定义异常类并继承Throwable类或其子类</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">newException</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//无参构造器 会自动产生最方便</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">newException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-6-printStackTrace-："><a href="#12-6-printStackTrace-：" class="headerlink" title="12.6 printStackTrace()："></a>12.6 printStackTrace()：</h2><blockquote><p><strong>将打印“从方法调用处直到异常抛出处”的方法调用序列</strong><br><strong>printStackTrace（）信息可由getStackTrace（）直接访问</strong></p><ul><li><strong>返回一个栈数组，栈顶是最后一个调用的方法，栈底是第一个调用的方法</strong></li></ul></blockquote><h3 id="12-6-3-异常链"><a href="#12-6-3-异常链" class="headerlink" title="12.6.3 异常链"></a>12.6.3 异常链</h3><blockquote><p><strong>在捕获一个异常后抛出另一个异常，把原始异常信息保存起来，为异常链</strong><br><strong>异常链写法：</strong></p><ol><li><strong>将catch到的异常对象作为cause参数放入构造器传递给下一个异常</strong></li><li><strong>创建异常对象实例化后用initCause（原始异常对象）</strong></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testOne</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;第一个异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">testOne();</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;第二个异常&quot;</span>,e);</span><br><span class="line">        <span class="comment">/*    写法二：</span></span><br><span class="line"><span class="comment">        Exception e1 = new IOException(&quot;第二个异常&quot;);</span></span><br><span class="line"><span class="comment">        e1.initCause(e);</span></span><br><span class="line"><span class="comment">        throw e1;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">testTwo();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="12-8-finally"><a href="#12-8-finally" class="headerlink" title="12.8 finally"></a>12.8 finally</h2><p><strong>除了System.exit(1)以外，其他任何情况都会执行finally，甚至跳过break，continue，return等语句。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第10章 内部类</title>
      <link href="/2021/06/13/%E7%AC%AC10%E7%AB%A0%20%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2021/06/13/%E7%AC%AC10%E7%AB%A0%20%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="内部类的好处："><a href="#内部类的好处：" class="headerlink" title="内部类的好处："></a>内部类的好处：</h2><ul><li><strong>将类的代码隐藏在其他类内部。</strong></li><li><strong>内部类对象可以访问外部类的所有元素</strong> <strong>。</strong></li><li><strong>解决多继承的问题。</strong></li><li><strong>内部类可以有多个实例，与外部类独立。</strong></li><li><strong>单个外部类可以让多个内部类实现同一个接口或继承同一个类。</strong></li></ul><h2 id="一、成员内部类"><a href="#一、成员内部类" class="headerlink" title="一、成员内部类:"></a>一、成员内部类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取内部类对象实例的方式"><a href="#获取内部类对象实例的方式" class="headerlink" title="获取内部类对象实例的方式"></a>获取内部类对象实例的方式</h3><ul><li><strong>普通内部类对象隐式的保存了一个指向外部类对象的引用。</strong></li><li><strong>new 外部类 . new 内部类。</strong></li><li><strong>外部类对象 . new 内部类。</strong></li><li><strong>外部类对象 . get方法。</strong></li></ul><h3 id="10-3-使用-this和-new"><a href="#10-3-使用-this和-new" class="headerlink" title="10.3 使用.this和.new"></a>10.3 使用.this和.new</h3><ul><li><strong>内部类中获取外部类对象的引用：外部类.this 。</strong></li><li><strong>外部类中访问内部类对象的引用：new 内部类()。</strong></li><li><strong>外部类中创建内部类对象必须使用外部类对象来创建内部类对象。</strong><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/186931/40/8122/34987/60c75aa2Ec2f56c51/0e6a607f34a6dd50.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"></strong></li></ul></li></ul><h3 id="10-4-内部类和向上转型"><a href="#10-4-内部类和向上转型" class="headerlink" title="10.4 内部类和向上转型"></a>10.4 内部类和向上转型</h3><p><strong>内部类也可以和普通类一样拥有向上转型的特性。将内部类向上转型为基类型，尤其是接口时，内部类就有了用武之地。如果内部类是private的，只可以被它的外部类问，从而完全隐藏实现的细节。</strong></p><hr><h2 id="二、10-5-方法内部类"><a href="#二、10-5-方法内部类" class="headerlink" title="二、10.5 方法内部类"></a>二、10.5 方法内部类</h2><ul><li><p><strong>方法中创建类。</strong></p></li><li><p><strong>类前不能加访问说明符，类中不能有静态成员。</strong></p></li><li><p><strong>可以访问代码块内的常量和外部类的所有成员。</strong></p><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3></li><li><p><strong>实现了某接口，创建并返回对其的引用。</strong></p></li><li><p><strong>需要创建一个类辅助解决问题，但不希望这个类公共可用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object getInner&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="三、10-6-匿名内部类"><a href="#三、10-6-匿名内部类" class="headerlink" title="三、10.6 匿名内部类"></a>三、10.6 匿名内部类</h2><h3 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li><strong>只用到类的一个实例，因为不会有对象名称，无法再次调用。</strong></li><li><strong>实例化的同时重写方法，等同于创建子类继承父类并重写方法或实现接口。</strong></li><li><strong>没有静态成员</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.getRead(<span class="keyword">new</span> Person()&#123; <span class="comment">//实例化的同时重写方法，等同于创建子类继承父类并重写方法。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="四、10-7-静态内部类（嵌套类）"><a href="#四、10-7-静态内部类（嵌套类）" class="headerlink" title="四、10.7 静态内部类（嵌套类）"></a>四、10.7 静态内部类（嵌套类）</h2><h3 id="使用场景：-2"><a href="#使用场景：-2" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li><p><strong>不需要内部类对象与外部类有联系。</strong></p><h3 id="与普通内部类的区别："><a href="#与普通内部类的区别：" class="headerlink" title="与普通内部类的区别："></a>与普通内部类的区别：</h3></li><li><p><strong>普通内部类对象隐式的保存了一个指向外部类对象的引用，而静态内部类没有。</strong></p></li><li><p><strong>静态内部类创建对象不需要外部类对象。</strong></p></li><li><p><strong>普通内部类不能有static成员，而静态内部类可以。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态内部类中，不能通过对象访问非静态的外部类对象。</strong></p></li><li><p><strong>创建静态内部类对象：外部类.内部类 类名 = new 外部类.内部类();</strong></p></li></ul><h3 id="10-7-1-接口内部可以放静态内部类"><a href="#10-7-1-接口内部可以放静态内部类" class="headerlink" title="10.7.1 接口内部可以放静态内部类"></a>10.7.1 接口内部可以放静态内部类</h3><p><strong>正常情况接口内部不能放代码，但是静态内部类可以放，自动的public和static。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="10-9-内部类的继承"><a href="#10-9-内部类的继承" class="headerlink" title="10.9 内部类的继承"></a>10.9 内部类的继承</h3><p><strong>内部类对象隐式的包含对外部类对象的引用，所以在继承内部类的同时，构造器需要通过特殊语法初始化这个引用。</strong></p><ul><li><strong>外部类对象 . super()</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Outer</span>,<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="comment">// A()&#123;&#125;不能通过编译。 必须通过外部类对象.super初始化内部类对象对外部类对象的引用。</span></span><br><span class="line">A(Outer o)&#123;</span><br><span class="line">    o.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章 接口</title>
      <link href="/2021/06/12/%E7%AC%AC9%E7%AB%A0%20%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/06/12/%E7%AC%AC9%E7%AB%A0%20%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="9-1-抽象类和抽象方法"><a href="#9-1-抽象类和抽象方法" class="headerlink" title="9.1 抽象类和抽象方法"></a>9.1 抽象类和抽象方法</h2><p><strong>含有抽象方法的类叫做抽象类</strong> <strong>。</strong><br><strong><code>abstract class name&#123;...``&#125;</code></strong></p><h3 id="抽象方法的特征"><a href="#抽象方法的特征" class="headerlink" title="抽象方法的特征"></a>抽象方法的特征</h3><ul><li><strong>抽象方法不允许有方法体，只能以分号“;”结尾</strong> 。</li><li><strong>抽象方法只能声明在抽象类中</strong> 。</li><li><strong>抽象类中可以包含0个或多个抽象方法。</strong></li><li><strong>抽象方法必须被子类实现</strong> 。</li><li><strong>如果子类不能实现父类中的抽象方法，那么子类也必须是抽象类</strong> 。<h3 id="什么情况下使用抽象方法和抽象类"><a href="#什么情况下使用抽象方法和抽象类" class="headerlink" title="什么情况下使用抽象方法和抽象类"></a>什么情况下使用抽象方法和抽象类</h3></li></ul><p><strong>父类的名称比较抽象，创建对象无意义。</strong></p><h2 id="9-2-接口"><a href="#9-2-接口" class="headerlink" title="9.2 接口"></a>9.2 接口</h2><p><strong>比抽象类更抽象。</strong><br><strong><code>interface A&#123;...&#125;</code></strong><br><strong><code>class B implements A&#123;...&#125;</code></strong><br><strong>接口中的变量隐式的指定为static和final</strong> ， <strong>没有方法体 。</strong></p><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul><li><strong>抽象类只能单继承,接口能多实现</strong> 。</li><li><strong>抽象类是一个类,可以被任意权限修饰符修饰,静态和非静态属性，final和非final属性，可以有抽象方法和非抽象方法</strong></li><li><strong>接口只能被public,final修饰,只能有静态方法,即使没有显示的声明，而且是不可修改的；</strong></li><li><strong>抽象类是对类的抽象，接口是对行为的抽象。</strong></li><li><strong>设计抽象类是自下而上的过程,我子类需要,所以我定义抽象类；而设计接口是自上而下的过程,我接口规范某一行为,我某类需要这个行为,我实现某接口；</strong></li></ul><p><strong>核心区别:</strong><br><strong>调用者使用动机不同,实现接口是为了使用他规范的某一个行为；</strong><br><strong>继承抽象类是为了使用这个类属性和行为.</strong></p><p><strong>再简单点说:</strong><br><strong>我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的规则而已。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第8章 多态</title>
      <link href="/2021/06/11/%E7%AC%AC8%E7%AB%A0%20%E5%A4%9A%E6%80%81/"/>
      <url>/2021/06/11/%E7%AC%AC8%E7%AB%A0%20%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="8-2-绑定"><a href="#8-2-绑定" class="headerlink" title="8.2 绑定"></a>8.2 绑定</h2><p><strong>静态绑定和动态绑定</strong></p><ul><li><strong>绑定：一个方法的调用与方法所在的类关联起来。</strong></li><li><strong>静态绑定：在编译过程中就已经知道这个方法到底是哪个类中的方法。</strong></li><li><strong>动态绑定：运行时根据对象的类进行绑定。</strong></li></ul><p><strong>java中除了static和final方法（包括private），其他方法都是动态绑定</strong> <strong>。</strong></p><h3 id="8-2-1-向上转型"><a href="#8-2-1-向上转型" class="headerlink" title="8.2.1 向上转型"></a>8.2.1 向上转型</h3><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/185948/12/9082/119939/60c7597dE1e65c954/7e73954f040131b6.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"> <br>  <strong>s.draw()调用的是circle的draw()</strong></p><ul><li><strong>多态 = 向上转型 = 动态绑定 。</strong><ul><li><strong>静态方法不具有多态性</strong> 。<img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/137541/24/19032/220254/60c759bbE03940af0/571a93e46206a98c.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><h2 id="8-3-带main方法的类构造器继承调用顺序"><a href="#8-3-带main方法的类构造器继承调用顺序" class="headerlink" title="8.3 带main方法的类构造器继承调用顺序"></a>8.3 带main方法的类构造器继承调用顺序</h2><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/189817/35/8121/74886/60c75a10E93f2cc8c/dc80047544e3a2fb.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><br><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/180763/28/9192/151689/60c75a29E195d704b/2c878cc1a1720461.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章 复用类</title>
      <link href="/2021/06/11/%E7%AC%AC7%E7%AB%A0%20%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
      <url>/2021/06/11/%E7%AC%AC7%E7%AB%A0%20%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-当需要String时，编译器会自动调用toString"><a href="#7-1-当需要String时，编译器会自动调用toString" class="headerlink" title="7.1 当需要String时，编译器会自动调用toString()"></a>7.1 <strong>当需要String时，编译器会自动调用toString()</strong></h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/187768/8/8156/173809/60c758caE0235709d/c47a625b496f5f12.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="7-2-导出类构造器和基类构造器"><a href="#7-2-导出类构造器和基类构造器" class="headerlink" title="7.2 导出类构造器和基类构造器"></a>7.2 导出类构造器和基类构造器</h2><p><strong>所有的类都可以含有main方法，无需删除，方便单元测试。</strong></p><ul><li><strong>创建从基类继承的类的对象会先执行基类构造器，然后再执行继承类的构造器<strong><strong>，所以导出类构造器中必须带有基类构造器</strong></strong>。</strong><ul><li><strong>若想要在继承类中调用基类的带参数的构造器，需要使用super关键字****。</strong></li><li><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/193139/8/8169/55490/60c758e4E6a6e76af/a9bf8344bb31fa8d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><h2 id="7-6-protected-关键字"><a href="#7-6-protected-关键字" class="headerlink" title="7.6 protected 关键字"></a>7.6 protected 关键字</h2><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/187016/1/8186/58893/60c7591bEee00236c/a0654b60d7f66a72.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><h2 id="7-7-向上转型"><a href="#7-7-向上转型" class="headerlink" title="7.7 向上转型"></a>7.7 向上转型</h2></li></ul></li></ul><p><strong>导出类对象自动提升到基类对象，向上转型是安全的，只会丢失方法。</strong><br><strong><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/184299/24/9164/118703/60c75937E35962a8e/609ac1042d2790ce.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><br>**</p><h3 id="7-7-2-再论继承与组合"><a href="#7-7-2-再论继承与组合" class="headerlink" title="7.7.2 再论继承与组合"></a>7.7.2 再论继承与组合</h3><p><strong>使用继承还是组合最清晰的办法就是要不要向上转型。如果要向上转型，那继承是必要的。如果不需要，再好好考虑</strong> <strong>。</strong></p><h2 id="7-8-final关键字"><a href="#7-8-final关键字" class="headerlink" title="7.8 final关键字"></a>7.8 final关键字</h2><h3 id="7-8-1-final-数据"><a href="#7-8-1-final-数据" class="headerlink" title="7.8.1 final 数据"></a>7.8.1 final 数据</h3><ul><li><p><strong>若是基本数据类型则值不变</strong> 。</p></li><li><p><strong>若是对象引用则引用不变，一旦被初始化，则无法再指向另一个对象，对象自身可以修改</strong> <strong>。</strong></p></li><li><p><strong>既是static又是final的变量用大写表示。</strong></p><h3 id="final-参数"><a href="#final-参数" class="headerlink" title="final 参数"></a>final 参数</h3></li><li><p><strong>方法的参数列表指定为final。基本数据类型值不能修改，引用对象不能更换指向。</strong></p><h3 id="7-8-2-final-方法"><a href="#7-8-2-final-方法" class="headerlink" title="7.8.2 final 方法"></a>7.8.2 final 方法</h3></li><li><p><strong>final方法不能重写</strong> <strong>。</strong></p></li><li><p><strong>private方法已经隐式的指定为final，不能重写。</strong></p></li><li><p>final方法可以关闭动态绑定 。</p><h3 id="7-8-3-final-类"><a href="#7-8-3-final-类" class="headerlink" title="7.8.3 final 类"></a>7.8.3 final 类</h3></li><li><p><strong>final类不能继承</strong> <strong>。</strong></p></li><li><p>final类中的变量可以选择final或者不final，但是方法不能重写 。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章 访问权限控制</title>
      <link href="/2021/06/10/%E7%AC%AC6%E7%AB%A0%20%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2021/06/10/%E7%AC%AC6%E7%AB%A0%20%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/181179/18/9114/48938/60c7583eE281939e9/7e2ddeae94364274.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>public：可以被所有其他类所访问。</strong></li><li><strong>private：只能被自己访问和修改。</strong></li><li><strong>protected：自身、子类及同一个包中类可以访问。</strong></li><li><strong>default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。</strong></li><li><strong>为了继承，通常把数据指定为private，方法为public</strong> <strong>。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 控制执行流程</title>
      <link href="/2021/06/07/%E7%AC%AC4%E7%AB%A0%20%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/06/07/%E7%AC%AC4%E7%AB%A0%20%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="4-4-foreach与for循环"><a href="#4-4-foreach与for循环" class="headerlink" title="4.4 foreach与for循环"></a>4.4 foreach与for循环</h2><ul><li><strong>foreach和for循环在数组遍历上，速度相当，for循环稍快。</strong></li><li><strong>在链表遍历上，foreach比for循环快很多。</strong></li><li><strong>foreach不能插入和删除操作。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章 初始化与清理</title>
      <link href="/2021/06/07/%E7%AC%AC5%E7%AB%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
      <url>/2021/06/07/%E7%AC%AC5%E7%AB%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-构造器"><a href="#5-1-构造器" class="headerlink" title="5.1 构造器"></a>5.1 构造器</h2><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/186178/13/9202/31200/60c757f8E20e3c80e/ae27efe8cf40900e.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="5-2-重载"><a href="#5-2-重载" class="headerlink" title="5.2 重载"></a>5.2 重载</h2><ul><li><strong>重载方法必须拥有独一无二的参数列表，返回值不同不能作为区分重载的标志。</strong></li><li><strong>传入数据类型小于方法中的参数类型，会自动提升。如果没有char类型，会自动提升到int型。</strong></li><li><strong>传入数据类型大于方法中的参数类型，必须强制转换。</strong></li></ul><blockquote><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><ul><li><strong>重载：在同一个类中相同名字的方法，参数列表不同。</strong></li><li><strong>重写：子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了。</strong></li></ul></blockquote><h2 id="5-3-默认构造器"><a href="#5-3-默认构造器" class="headerlink" title="5.3 默认构造器"></a>5.3 默认构造器</h2><ul><li><strong>没有写构造器会自动创建无参构造器。</strong></li><li><strong>写了构造器，就不会自动创建构造器。</strong></li></ul><h2 id="5-4-this关键字"><a href="#5-4-this关键字" class="headerlink" title="5.4 this关键字"></a>5.4 this关键字</h2><ul><li><strong>在方法内部使用，表示调用该方法的那个对象的引用。</strong></li><li><strong>在方法中调用同一个类的另一个方法不需要用this，只有当需要明确指出对当前对象的引用时才用this。</strong><ul><li><strong>例如return this 或者作为参数传递给外部函数。</strong></li></ul></li><li><strong>在构造器中使用this调用另一个构造器。</strong></li></ul><h2 id="5-7-初始化顺序"><a href="#5-7-初始化顺序" class="headerlink" title="5.7 初始化顺序"></a>5.7 初始化顺序</h2><ul><li><strong>静态变量（只初始化一次）-》非静态变量-》构造器</strong></li></ul><h2 id="5-8-数组初始化"><a href="#5-8-数组初始化" class="headerlink" title="5.8 数组初始化"></a>5.8 数组初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组初始化三种形式</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-8-1-可变参数列表"><a href="#5-8-1-可变参数列表" class="headerlink" title="5.8.1 可变参数列表"></a>5.8.1 可变参数列表</h3><ul><li><strong>用Object数组或Object… args作为参数即可。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 操作符</title>
      <link href="/2021/06/06/%E7%AC%AC3%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2021/06/06/%E7%AC%AC3%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="3-2-和equals"><a href="#3-2-和equals" class="headerlink" title="3.2 ==和equals"></a>3.2 ==和equals</h2><ul><li><p><strong>==的含义：</strong></p><ul><li><strong>比较基本数据类型的值是否相同。</strong></li><li><strong>比较引用数据类型的地址是否相同。</strong></li></ul></li><li><p><strong>equals的含义：</strong></p><ul><li><strong>Object中的equals和==一样，都是比较对象的地址。</strong></li><li><strong>String在Object的基础上重写了equals，比较的是字符串的内容。</strong></li></ul></li><li><p><strong>String的equals源码</strong><br><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/182134/35/9178/113522/60c757a1Ed15aa1e2/f61d1016c4fe6fcb.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"> </p><h2 id="3-15-类型转换"><a href="#3-15-类型转换" class="headerlink" title="3.15 类型转换"></a>3.15 类型转换</h2></li><li><p><strong>编译器会在必要的时候自动将int转换到long。</strong></p></li><li><p><strong>小数据类型会自动转换为大数据类型。</strong></p><ul><li><strong>如：char、byte、short在运算时会自动转换为int。</strong></li></ul></li><li><p><strong>大数据类型到小数据类型需要强制转换。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 导论</title>
      <link href="/2021/06/05/%E7%AC%AC1%E7%AB%A0%20%E5%AF%BC%E8%AE%BA/"/>
      <url>/2021/06/05/%E7%AC%AC1%E7%AB%A0%20%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><p><strong>每一个对象在内存中都有一个唯一的地址，new的对象在堆中。</strong></p><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h2><p><strong>高内聚、低耦合：模块之间紧密联系，并且保持独立性。</strong></p><h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><ul><li><strong>public、private、protected</strong><ul><li><strong>private: 除类型创建者和类型的内部方法之外的任何人都不能访问。</strong></li><li><strong>protected：与 private作用相当，差别仅在于继承的类可以访问 protected成员，但是不能访问private成员。</strong></li></ul></li></ul><h2 id="1-5-组合"><a href="#1-5-组合" class="headerlink" title="1.5 组合"></a>1.5 组合</h2><ul><li><strong>组合：由类的对象组合成新类</strong>。<ul><li><strong>has-a（拥有）关系的时候用组合</strong> <strong>。</strong></li><li><strong>新类的成员对象通常都被声明为 private，使得可以在不干扰现有客户端代码的情况下，修改这些成员，也可以在运行时修改这些成员对象，以实现动态修改程序的行为。</strong></li><li><strong>通常用于在新类中使用现有类的功能而非接口的情况，即在新类中嵌入现有类的private对象</strong> <strong>。</strong></li></ul></li></ul><h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6 继承"></a>1.6 继承</h2><p><strong>is-a（是一个）或者like-a（像是一个）的时候用继承</strong> <strong>。</strong><br><strong>有两种方法可以使基类与导出类产生差异：extends关键字、覆盖基类的方法。</strong><br><strong>判断用组合还是继承，先看看要不要向上转型</strong> 。</p><h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p><strong>所有类继承于Object。</strong><br><strong>所有对象都在堆上创建（new）。</strong></p><h2 id="1-10-生命周期"><a href="#1-10-生命周期" class="headerlink" title="1.10 生命周期"></a>1.10 生命周期</h2><ul><li><strong>java完全采用动态内存分配方式。</strong><ul><li><strong>在堆栈上创建对象，编译器可以确定对象存活时间，自动销毁。但是在堆上创建对象，编译器对其生命周期一无所知</strong>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 对象</title>
      <link href="/2021/06/05/%E7%AC%AC2%E7%AB%A0%20%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/06/05/%E7%AC%AC2%E7%AB%A0%20%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="2-2-基本数据类型"><a href="#2-2-基本数据类型" class="headerlink" title="2.2 基本数据类型"></a>2.2 基本数据类型</h2><p><strong>string不是基本数据类型。</strong><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/195661/8/8079/206780/60c755f6E54758dcd/ffdb69980ac7b6c1.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="2-2-2-高精度数字"><a href="#2-2-2-高精度数字" class="headerlink" title="2.2.2 高精度数字"></a>2.2.2 高精度数字</h3><ul><li><strong>高精度数字：BigInteger、BigDecimal</strong><ul><li><strong>BigInteger：支持任意精度的整数。</strong></li><li><strong>BigDecimal：支持任意精度的定点数。</strong></li></ul></li></ul><h3 id="2-2-3-创建数组对象就是创建一个引用数组。"><a href="#2-2-3-创建数组对象就是创建一个引用数组。" class="headerlink" title="2.2.3 创建数组对象就是创建一个引用数组。"></a>2.2.3 创建数组对象就是创建一个引用数组。</h3><h2 id="2-3-生命周期"><a href="#2-3-生命周期" class="headerlink" title="2.3 生命周期"></a>2.3 生命周期</h2><p><strong>java对象生命周期和基本类型不一样。用new创建的对象可以存活于作用域之外。</strong><br><strong>java垃圾回收器会监视new的对象，辨别不会再被引用的对象并释放内存空间。</strong></p><h2 id="2-4-初始值"><a href="#2-4-初始值" class="headerlink" title="2.4 初始值"></a>2.4 初始值</h2><p><strong>变量作为类的成员或全局变量会有初始默认值，局部变量没有初始值。</strong><br><strong><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/182601/20/9214/90450/60c756c2E31138148/e3d464be6e09303d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h2 id="2-5-java函数可以返回数组，c-c-不能"><a href="#2-5-java函数可以返回数组，c-c-不能" class="headerlink" title="2.5 java函数可以返回数组，c/c++不能"></a>2.5 java函数可以返回数组，c/c++不能</h2><h2 id="2-6-java库函数-java-util"><a href="#2-6-java库函数-java-util" class="headerlink" title="2.6 java库函数 java.util.*"></a>2.6 java库函数 <code>java.util.*</code></h2><h3 id="2-6-3-static-关键字"><a href="#2-6-3-static-关键字" class="headerlink" title="2.6.3 static 关键字"></a>2.6.3 static 关键字</h3><ul><li><strong>static适用于两种情况</strong><ul><li><strong>分配单一存储空间，不考虑创建多少对象或者不创建对象。</strong></li><li><strong>创建的方法不与包含它的类的对象关联起来</strong></li></ul></li><li><strong>创建static事物后，即使没有创建对象也可以调用static方法或static域。</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/185967/29/9177/76016/60c756eeE4ec4eae5/e3b719fb7e5add2e.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>static变量或static方法可以通过类名直接引用，而且是首选方式</strong> <strong>。</strong></li><li><strong>static方法内部不能调用非static方法，非static方法可以调用static方法</strong> 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
