<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初识贝叶斯网络与遗传算法</title>
      <link href="/posts/1117388134.html"/>
      <url>/posts/1117388134.html</url>
      
        <content type="html"><![CDATA[<p><strong>本笔记是对《贝叶斯网络结构学习算法研究》论文进行学习时所写</strong></p><h2 id="首先通过摘要"><a href="#首先通过摘要" class="headerlink" title="首先通过摘要"></a>首先通过摘要</h2><p><strong>可以了解到该论文研究的方向，即在大数据情况下基于遗传算法的贝叶斯网络结构算法执行效率问题</strong><br><strong>作者将混合方式的 BN 结构学习算法与 Spark 分布式计算平台结合</strong><br><strong>在构建超结构、评分计算和 GA 的进化操作三个流程上进行了并行化工作</strong><br><strong>同时引入Redis对中间数据进行存储以便在评分计算过程中高效复用数据</strong></p><hr><h2 id="故对该论文需要学习的内容如下：（本文只解决前3个问题）"><a href="#故对该论文需要学习的内容如下：（本文只解决前3个问题）" class="headerlink" title="故对该论文需要学习的内容如下：（本文只解决前3个问题）"></a>故对该论文需要学习的内容如下：（本文只解决前3个问题）</h2><ul><li><strong>什么是BN结构学习算法？</strong></li><li><strong>什么是GA算法？</strong></li><li><strong>怎么使用GA算法来得到BN结构？</strong></li><li><strong>什么是Spark分布式计算平台？</strong></li><li><strong>什么是Redis？</strong></li><li><strong>如何并行化构造超结构？</strong></li><li><strong>如何基于Spark实现GA算法？</strong></li><li><strong>如何基于Spark实现评分计算？</strong></li></ul><hr><h2 id="第1个问题，什么是BN结构学习算法？"><a href="#第1个问题，什么是BN结构学习算法？" class="headerlink" title="第1个问题，什么是BN结构学习算法？"></a>第1个问题，什么是BN结构学习算法？</h2><h3 id="首先回答什么是BN结构？"><a href="#首先回答什么是BN结构？" class="headerlink" title="首先回答什么是BN结构？"></a>首先回答什么是BN结构？</h3><ul><li><strong>BN，即贝叶斯网络，是一种反应世界上一些事物的可能的情况的发生概率的模型，可模拟任何系统</strong></li><li><strong>BN结构，是由有向无环图(DAG)和一组条件概率表组成</strong><ul><li><strong>其中DAG每个节点表示随机变量，有向边表示一个变量对另一个变量的影响</strong></li><li><strong>条件概率表表示每个节点x在其父节点的所有可能的联合赋值条件下的x的概率分布，例如下图节点A在父节点E、B所有可能的联合赋值条件下的概率</strong></li></ul></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h3 id="现在可以回答BN结构学习算法了"><a href="#现在可以回答BN结构学习算法了" class="headerlink" title="现在可以回答BN结构学习算法了"></a>现在可以回答BN结构学习算法了</h3><ul><li><strong>我们使用BN的目的就是为了得到那一组条件概率表，那么首先得构建一个BN网络，即那个有向无环图</strong></li><li><strong>那么怎么构造呢，很复杂的关系没办法手动构造吧，那么就是这里讨论的BN结构学习算法了</strong></li></ul><p><strong>当然啦，那个概率表也是要训练的才行的，不过这里讨论的是BN结构哈</strong></p><ul><li><strong>该论文指出BN结构学习算法主要是三种，基于评分、基于约束、约束和评分混合</strong></li></ul><h4 id="首先是基于评分，第一步定义评分函数、第二步采用搜索策略"><a href="#首先是基于评分，第一步定义评分函数、第二步采用搜索策略" class="headerlink" title="首先是基于评分，第一步定义评分函数、第二步采用搜索策略"></a>首先是基于评分，第一步定义评分函数、第二步采用搜索策略</h4><p><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>该论文采用BIC评分函数，由BN结构的对数似然度和惩罚项函数组成。前者表示数据集和BN结构的拟合程度，后者防止结构模型过于复杂、参数过多，导致过拟合问题。BIC评分计算方法见如下图，这里仅作了解</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>搜索策略就是在搜索空间中找得分最高的BN结构，也就是对数据集拟合程度最高的BN结构，该论文用的GA算法，下面就会介绍</strong></li></ul><h4 id="然后是基于约束，就是计算各节点间条件是否独立，并通过构造条件独立性集合来建立BN"><a href="#然后是基于约束，就是计算各节点间条件是否独立，并通过构造条件独立性集合来建立BN" class="headerlink" title="然后是基于约束，就是计算各节点间条件是否独立，并通过构造条件独立性集合来建立BN"></a>然后是基于约束，就是计算各节点间条件是否独立，并通过构造条件独立性集合来建立BN</h4><ul><li><strong>比如对于一个节点x，我们要求他的B(x)，即与他有条件联系的节点集合，即互信息。再用CI测试给边定向</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h4 id="最后是混合算法，即首先通过基于约束的方法构造无向图减少冗余搜索空间，然后通过基于评分搜索的方法得到评分最高的BN结构"><a href="#最后是混合算法，即首先通过基于约束的方法构造无向图减少冗余搜索空间，然后通过基于评分搜索的方法得到评分最高的BN结构" class="headerlink" title="最后是混合算法，即首先通过基于约束的方法构造无向图减少冗余搜索空间，然后通过基于评分搜索的方法得到评分最高的BN结构"></a>最后是混合算法，即首先通过基于约束的方法构造无向图减少冗余搜索空间，然后通过基于评分搜索的方法得到评分最高的BN结构</h4><hr><h2 id="第2个问题，什么是GA算法？"><a href="#第2个问题，什么是GA算法？" class="headerlink" title="第2个问题，什么是GA算法？"></a>第2个问题，什么是GA算法？</h2><h3 id="GA算法，即遗传算法。有以下几个概念："><a href="#GA算法，即遗传算法。有以下几个概念：" class="headerlink" title="GA算法，即遗传算法。有以下几个概念："></a>GA算法，即遗传算法。有以下几个概念：</h3><ul><li><strong>染色体：数学问题的每一个可行解就是一条染色体</strong></li><li><strong>基因：染色体上的元素就是基因，比如染色体[1,2,3]，那么每个数都是一个基因</strong></li><li><strong>适应度函数：每次繁衍后，适应度函数给生成的下一代所有的染色体打分，分数高的更有可能保留下去，分数低的淘汰</strong></li><li><strong>交叉：下一代染色体由父母两条染色体交叉形成，如下图所示。爸爸妈妈染色体的选择一般用轮盘赌算法，适应度高的更容易被选中</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E5%88%9D%E8%AF%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E4%B8%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>变异：交叉每次选择都是在原有数据集上选择，容易达到局部最优，但不能全局最优。变异就是在交叉后，对染色体上的若干个基因随机修改，从而达到全局最优</strong></li></ul><h3 id="GA算法执行流程？"><a href="#GA算法执行流程？" class="headerlink" title="GA算法执行流程？"></a>GA算法执行流程？</h3><p><strong>首先设置种群大小，突变概率，交叉概率等参数，然后随机初始化个体构成初始种群。每一次通过适应度函数打分，然后交叉、变异得到下一代，不断迭代</strong></p><hr><h2 id="第3个问题，怎么使用GA算法得到BN结构？"><a href="#第3个问题，怎么使用GA算法得到BN结构？" class="headerlink" title="第3个问题，怎么使用GA算法得到BN结构？"></a>第3个问题，怎么使用GA算法得到BN结构？</h2><p><strong>将GA算法应用到BN结构学习中</strong></p><ul><li><strong>首先选择操作：将适应度函数应用到对个体的BN结构评分，评分越高说明BN结构适应度越高</strong></li><li><strong>然后交叉操作：父母BN结构进行交叉，产生下一代BN结构</strong></li><li><strong>还有变异操作：对BN结构的若干基因进行随机变异，避免达到局部最优却无法全局最优解的情况</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《贝叶斯网络结构学习算法》论文笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贝叶斯网络 </tag>
            
            <tag> 遗传算法 </tag>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 简单工厂模式</title>
      <link href="/posts/4228647784.html"/>
      <url>/posts/4228647784.html</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式是什么？用来干啥？"><a href="#简单工厂模式是什么？用来干啥？" class="headerlink" title="简单工厂模式是什么？用来干啥？"></a>简单工厂模式是什么？用来干啥？</h2><p><strong>设想一下，如果有很多个类，都是完成类似的工作。那么就可以写一个工厂类就像一个中间人一样，来帮助我们选择需要的类来创建对象，而不用我们自己去new，UML图如下：</strong><br><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC1%E7%AB%A0%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><br><strong>比如要做一个计算器程序，需要设计加减乘除等运算类 和 去调用这些运算并显示结果的客户端类，可以创建一个工厂类</strong><br><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC1%E7%AB%A0%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="用简单工厂模式有什么好处呢？"><a href="#用简单工厂模式有什么好处呢？" class="headerlink" title="用简单工厂模式有什么好处呢？"></a>用简单工厂模式有什么好处呢？</h2><p><strong>工厂类可以通过逻辑判断，来决定在什么时候创建哪一个产品类的实例，这样客户端可以不用自己去new对象了。简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。外界与具体类隔离开来，偶合性低。明确区分了各自的职责和权力，有利于整个软件体系结构的优化</strong></p><hr><h2 id="那么怎么使用简单工厂模式呢？"><a href="#那么怎么使用简单工厂模式呢？" class="headerlink" title="那么怎么使用简单工厂模式呢？"></a>那么怎么使用简单工厂模式呢？</h2><p><strong>就上述设计计算器程序为例，抽象接口及其实现类如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numA,<span class="keyword">double</span> numB)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="comment">//实现接口中的同名方法，这样客户端可以通过工厂类返回的向上转型的对象实例进行动态绑定调用具体方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getResult</span><span class="params">(<span class="keyword">double</span> numA,<span class="keyword">double</span> numB)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numA+numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他实现类同理</span></span><br></pre></td></tr></table></figure><p><strong>工厂类如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">//简单工厂类中用静态方法，返回类型为抽象接口，通过多态得到不同对象的实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String operate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(operate)&#123;</span><br><span class="line">            <span class="keyword">if</span> operate.equals(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> operate.equals(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>   ...</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过多态的向上转型和动态绑定，虽然是抽象接口的对象，但是可以使用具体实现类的具体方法</span></span><br><span class="line">Operator oper = OperatorFactory.getOperator(<span class="string">&quot;+&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> result = oper.getResult(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《大话设计模式》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven入门指南</title>
      <link href="/posts/477950076.html"/>
      <url>/posts/477950076.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要用Maven？"><a href="#为什么要用Maven？" class="headerlink" title="为什么要用Maven？"></a>为什么要用Maven？</h2><ul><li><strong>场景一：idea开发的项目没法到eclipse中运行，即不同的ide开发的项目不能互相使用</strong></li><li><strong>场景二：大型项目需要很多个jar包，要去不同的网站下载，也不方便更新，很麻烦</strong></li></ul><hr><h2 id="IDEA上怎么创建Maven项目？"><a href="#IDEA上怎么创建Maven项目？" class="headerlink" title="IDEA上怎么创建Maven项目？"></a>IDEA上怎么创建Maven项目？</h2><p><strong>创建Maven项目时需要填写以下信息</strong></p><ul><li><strong>GroupID：机构名或者逆向域名的形式</strong></li><li><strong>ArtifactID：项目名称</strong></li><li><strong>Version：版本号</strong></li></ul><p><strong>创建好了以后会自动生成Maven项目结构以及配置文件pom.xml</strong></p><hr><h2 id="Maven项目结构是什么样的？"><a href="#Maven项目结构是什么样的？" class="headerlink" title="Maven项目结构是什么样的？"></a>Maven项目结构是什么样的？</h2><p><img "" class="lazyload placeholder" data-original="/medias/Maven%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="那pom-xml文件是干啥的？"><a href="#那pom-xml文件是干啥的？" class="headerlink" title="那pom.xml文件是干啥的？"></a>那pom.xml文件是干啥的？</h2><p><strong>pom.xml文件是用来配置项目依赖的，Maven会通过这些依赖自动下载第三方组件</strong></p><h2 id="那么怎么在pom-xml中配置项目依赖呢？"><a href="#那么怎么在pom-xml中配置项目依赖呢？" class="headerlink" title="那么怎么在pom.xml中配置项目依赖呢？"></a>那么怎么在pom.xml中配置项目依赖呢？</h2><p><strong>在search.maven.org网站中搜索需要的组件，找到需要的组件的依赖后加入pom.xml的<code>&lt;dependencies&gt;&lt;/dependencies&gt;</code>中，然后maven就会自动下载这些组件了</strong></p><hr><h2 id="怎么让maven下载依赖的速度快一点呢？"><a href="#怎么让maven下载依赖的速度快一点呢？" class="headerlink" title="怎么让maven下载依赖的速度快一点呢？"></a>怎么让maven下载依赖的速度快一点呢？</h2><p><strong>Maven首先去本地仓库找，如果本地仓库没有再去中央仓库下载到本地仓库。</strong><br><strong>为了加快下载速度，可以使用私服，从私服下载到本地仓库</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以在pom.xml的&lt;version&gt;下方添加一个阿里云私服的地址配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="maven命令常用的有哪些？"><a href="#maven命令常用的有哪些？" class="headerlink" title="maven命令常用的有哪些？"></a>maven命令常用的有哪些？</h2><ul><li><strong>compile：编译，编译成功后会增加一个target目录</strong></li><li><strong>clean：删除整个target目录</strong></li><li><strong>test：在集成junit，并且有test项目和测试类</strong></li><li><strong>package：把项目打包成jar包</strong></li><li><strong>install：把打好的jar包放到本地仓库去</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Maven项目管理》课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第8章 备份与复制</title>
      <link href="/posts/147568029.html"/>
      <url>/posts/147568029.html</url>
      
        <content type="html"><![CDATA[<h2 id="备份常用的方法是什么？"><a href="#备份常用的方法是什么？" class="headerlink" title="备份常用的方法是什么？"></a>备份常用的方法是什么？</h2><p><strong>冷备、热备</strong></p><ul><li><strong>冷备是指在停止数据库后备份，直接备份数据库的物理文件即可，一般都是写个脚本</strong></li><li><strong>热备是指在数据库运行的时候直接备份，一般借用工具，如ibbackup、XtraBackup</strong></li></ul><hr><h2 id="什么是复制？"><a href="#什么是复制？" class="headerlink" title="什么是复制？"></a>什么是复制？</h2><p><strong>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库。主数据库一般是准实时的业务数据库</strong></p><ul><li><strong>用来做热备。主数据库坏了可以切换到从数据库</strong></li><li><strong>读写分离。比如报表sql很慢，会导致锁表，可以让从数据库报表，主数据库继续做业务</strong></li></ul><hr><h3 id="主从复制的原理是什么？"><a href="#主从复制的原理是什么？" class="headerlink" title="主从复制的原理是什么？"></a>主从复制的原理是什么？</h3><ul><li><strong>首先master把数据更改记录到二进制日志</strong></li><li><strong>然后slave把master的二进制日志复制到自己的中继日志</strong></li><li><strong>最后slave重做中继日志中的日志，把数据更改也用到自己数据库上，这样就和master保持一致</strong></li></ul><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC8%E7%AB%A0%E5%A4%87%E4%BB%BD%E4%B8%8E%E5%A4%8D%E5%88%B6/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 《MySQL技术内幕》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章 MySQL索引</title>
      <link href="/posts/2979735234.html"/>
      <url>/posts/2979735234.html</url>
      
        <content type="html"><![CDATA[<h2 id="InnoDB支持的索引"><a href="#InnoDB支持的索引" class="headerlink" title="InnoDB支持的索引"></a>InnoDB支持的索引</h2><ul><li><strong>B+树索引</strong></li><li><strong>全文索引</strong></li><li><strong>哈希索引（自适应）</strong></li></ul><hr><h2 id="说说B-树吧"><a href="#说说B-树吧" class="headerlink" title="说说B+树吧"></a>说说B+树吧</h2><p><strong>B+树就是一种平衡搜索树。所有的记录节点都按照键值从小到大顺序放在同一层的叶子节点上，如下图所示</strong><br><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC5%E7%AB%A0MySQL%E7%B4%A2%E5%BC%95/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h3 id="聚集索引和辅助索引"><a href="#聚集索引和辅助索引" class="headerlink" title="聚集索引和辅助索引"></a>聚集索引和辅助索引</h3><p><strong>假设有个表如下：</strong><br><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC5%E7%AB%A0MySQL%E7%B4%A2%E5%BC%95/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><br><strong>聚集索引就是用每个表的主键构造一课B+树。每个叶子节点里放表的行数据，并且每个叶子在不同的磁盘上面</strong></p><ul><li><strong>如下图所示：如果要查找id=5的数据，那么先把磁盘0读入内存，然后用二分法查找id=5的数在3和6之间，然后通过指针p1查找到磁盘2的地址，然后将磁盘2读入内存中，用二分查找方式查找到id=5的数据</strong></li></ul><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC5%E7%AB%A0MySQL%E7%B4%A2%E5%BC%95/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><br><strong>辅助索引的叶子节点里不包含一行数据的全部数据。如果要找一个完整的行数据，可以通过辅助索引找到指向主键索引的指针，然后去聚集索引里找到完整行数据</strong></p><ul><li><strong>如下图所示：如果要查找到name = 小徐，首先将磁盘0加载到内存中，然后用二分查找的方法查到在指针p1所指的地址上，然后通过指针p1所指的地址可知道在磁盘2上面，然后通过二分查找法得知小徐id=4。然后在根据id=4将磁盘0加载到内存中，用上述聚集索引的方法找到完整的行数据</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC5%E7%AB%A0MySQL%E7%B4%A2%E5%BC%95/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><hr><h3 id="如何创建和删除索引"><a href="#如何创建和删除索引" class="headerlink" title="如何创建和删除索引"></a>如何创建和删除索引</h3><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC5%E7%AB%A0MySQL%E7%B4%A2%E5%BC%95/4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>一开始创建数据库的时候，会创建主键的聚集索引，之后需要手动加入其他属性(列)的索引。对于不常查询的属性，不需要建立索引，会降低更新操作的速度</strong></li></ul><hr><h2 id="再说说自适应哈希索引吧"><a href="#再说说自适应哈希索引吧" class="headerlink" title="再说说自适应哈希索引吧"></a>再说说自适应哈希索引吧</h2><ul><li><strong>这是数据库自动创建的，不能手动创建</strong></li><li><strong>只能用于精准查找，如<code>SELECT ... FROM TABLE WHERE col_name = &#39;xxx&#39;</code></strong></li></ul><hr><h2 id="最后说说全文索引吧"><a href="#最后说说全文索引吧" class="headerlink" title="最后说说全文索引吧"></a>最后说说全文索引吧</h2><ul><li><strong><code>LIKE &#39;xxx%&#39;</code>这种是可以用B+树索引的，但是<code>LIKE &#39;%xxx%&#39;</code>就不行，所以需要全文索引</strong></li><li><strong>以前InnoDB不支持全文索引，现在的版本支持了</strong></li><li><strong>在这里仅作了解，等以后再深入研究</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《MySQL技术内幕》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 MySQL日志</title>
      <link href="/posts/4156801793.html"/>
      <url>/posts/4156801793.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL常用的日志类型有哪些？"><a href="#MySQL常用的日志类型有哪些？" class="headerlink" title="MySQL常用的日志类型有哪些？"></a>MySQL常用的日志类型有哪些？</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0MySQL%E6%97%A5%E5%BF%97/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p><strong>错误日志记录mysql在启动、运行、关闭过程中出现的问题，并会记录在错误文件中。用户可以通过<code>SHOW VARIABLES LLKE &#39;log_error‘</code>来定位错误日志文件。默认情况下文件名为主机名，查看错误文件并进行优化</strong></p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p><strong>慢查询日志可以定位可能存在问题的SQL语句，从而进行SQL语句层面的优化</strong><br><strong>例如可以在MySQL启动时设一个阈值，若运行时间超过该值的SQL语句就记录到慢查日志文件中</strong><br><strong>用户可以通过<code>SHOW VARIABLES LIKE &#39;log_slow_queries&#39;</code></strong></p><h2 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h2><p><strong>二进制日志记录了对MySQL数据库执行更改的所有操作，即不包括SHOW和SELECT这类语句</strong><br><strong>二进制日志的作用为基于时间点恢复数据、主从复制数据、审计数据（判断是否有注入攻击）</strong><br><strong>默认文件名为主机名.日志序列号，如host.00001。二进制日志默认关闭，需要手动开启</strong></p>]]></content>
      
      
      <categories>
          
          <category> 《MySQL技术内幕》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 MySQL和存储引擎</title>
      <link href="/posts/925095689.html"/>
      <url>/posts/925095689.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL存储引擎是什么？"><a href="#MySQL存储引擎是什么？" class="headerlink" title="MySQL存储引擎是什么？"></a>MySQL存储引擎是什么？</h2><ul><li><strong>MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现</strong></li></ul><hr><h2 id="MySQL存储引擎的选择"><a href="#MySQL存储引擎的选择" class="headerlink" title="MySQL存储引擎的选择"></a>MySQL存储引擎的选择</h2><ul><li><strong>5.5之前默认存储引擎是MyISAM,5.5之后默认存储引擎是Innodb</strong></li></ul><hr><h2 id="具体说说MyISAM"><a href="#具体说说MyISAM" class="headerlink" title="具体说说MyISAM"></a>具体说说MyISAM</h2><p><strong>首先MyISAM支持全文检索，不支持事务和行级锁，只有表级别锁，它适用于 OLAP 场景，也就是分析类的，基本上都是读取，不会有什么写入动作的场景</strong><br><strong>其次它的数据和索引是分离存储的，也就是不在一个文件上，并且数据库只会缓存索引文件，数据文件的缓存直接交给操作系统搞定</strong><br><strong>然后MyISAM 的索引也是 B+ 树，只是不像 InnoDB 那种叶子节点会存储完整的数据，MyISAM 的数据是独立于索引单独存储的，所以主键和非主键索引差别不大</strong><br><strong>还有一个情况就是 MyISAM 不支持崩溃后的安全恢复，而 InnoDB 有个 redolog 可以支持安全恢复</strong><br><strong>再有一点就是 MyISAM 写入性能差。因为锁的粒度太粗了，不支持行锁，只有表锁，所以写入的时候会对整张表加锁</strong></p><h2 id="具体说说Innodb"><a href="#具体说说Innodb" class="headerlink" title="具体说说Innodb"></a>具体说说Innodb</h2><p><strong>InnoDB 支持事务，实现了四种标准的隔离级别，利用 MVCC 来支持高并发，默认事务隔离级别为可重复读，支持行锁，利用行锁+间隙锁提供可重复读级别下防止幻读的能力，支持崩溃后的数据安全恢复</strong><br><strong>另外还支持外键</strong><br><strong>InnoDB 的主键索引称为聚簇索引，也就是数据和索引是放在一起的，这与 MyISAM 有所不同，并且它的辅助索引(非主键索引)只存储索引值与主键，因此当辅助索引不能覆盖查询的列时，需要通过找到的主键再去聚簇索引查询数据，这个过程称之为****回表</strong><br><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC1%E7%AB%A0MySQL%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><br><strong>它之所以能取代 MyISAM 成为默认引擎就是因为事务的支持、 Innodb的关键特性、崩溃后的数据安全恢复例如MVCC</strong></p><hr><h2 id="Innodb和MyISAM的区别"><a href="#Innodb和MyISAM的区别" class="headerlink" title="Innodb和MyISAM的区别"></a>Innodb和MyISAM的区别</h2><ul><li><strong>Innodb支持事务，MyISAM不支持事务</strong></li><li><strong>MyISAM不支持外键，InnoDB支持外键</strong></li><li><strong>MyISAM只支持表级锁，InnoDB支持行级锁和表级锁，默认是行级锁</strong></li><li><strong>MyISAM支持全文索引，InnoDB不支持全文索引</strong></li><li><strong>MyISAM支持没有主键的表存在，InnoDB不支持没有主键</strong></li><li><strong>MyISAM较简单，效率上优于InnoDB，适合小型应用</strong></li><li><strong>MyISAM使用非聚集索引，InnoDB使用聚集索引</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《MySQL技术内幕》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客SQL第1-20题</title>
      <link href="/posts/642795887.html"/>
      <url>/posts/642795887.html</url>
      
        <content type="html"><![CDATA[<h2 id="SQL1"><a href="#SQL1" class="headerlink" title="SQL1"></a>SQL1</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>第一种：适用于最晚的员工如果不止一个的情况</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>先找到最晚的hire_data，再用条件查到</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(hire_date) <span class="keyword">FROM</span> employees)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>第二种：不适用于最晚的员工如果不止一个的情况。</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>降序排序，并且只显示第一行  </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>limit(x,y)代表第x行开始共显示y行  limit x [<span class="keyword">offset</span> y]代表取前x行数据，但是跳过y行</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> LIMIT <span class="number">0</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL2"><a href="#SQL2" class="headerlink" title="SQL2"></a>SQL2</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>适用于相同时间员工不止一个的情况</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法同SQL1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>注意<span class="keyword">DISTINCT</span>去重</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> hire_date <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> LIMIT <span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>不适用于相同时间员工不止一个的情况</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法同SQL1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span> LIMIT <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL3"><a href="#SQL3" class="headerlink" title="SQL3"></a>SQL3</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>给表起别名 <span class="keyword">FROM</span> tablea t 把tablea起名为t</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>等值连接 <span class="keyword">where</span>连接两个表</span><br><span class="line"><span class="keyword">SELECT</span> s.<span class="operator">*</span> ,d.dept_no <span class="keyword">FROM</span> salaries s,dept_manager d</span><br><span class="line">  <span class="keyword">WHERE</span> s.emp_no <span class="operator">=</span> d.emp_no</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> s.emp_no</span><br></pre></td></tr></table></figure><hr><h2 id="SQL4"><a href="#SQL4" class="headerlink" title="SQL4"></a>SQL4</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>第一种：等值连接</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line">  <span class="keyword">FROM</span> employees e,dept_emp d</span><br><span class="line">  <span class="keyword">WHERE</span> e.emp_no <span class="operator">=</span> d.emp_no</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>第二种：自然连接 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span></span><br><span class="line"> <span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line">  <span class="keyword">FROM</span> employees e</span><br><span class="line">  <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> dept_emp d</span><br></pre></td></tr></table></figure><hr><h2 id="SQL5"><a href="#SQL5" class="headerlink" title="SQL5"></a>SQL5</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* INNER JOIN 两边表同时有对应的数据，即任何一边缺失数据就不显示。</span></span><br><span class="line"><span class="comment">LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</span></span><br><span class="line"><span class="comment">RIGHT JOIN 会读取右边数据表的全部数据，即便左边表无对应数据。*/</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>内外连接需要用<span class="keyword">ON</span>做条件</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line">  <span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept_emp d</span><br><span class="line">  <span class="keyword">ON</span> e.emp_no <span class="operator">=</span> d.emp_no</span><br></pre></td></tr></table></figure><hr><h2 id="SQL7"><a href="#SQL7" class="headerlink" title="SQL7"></a>SQL7</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">GROUP</span> <span class="keyword">BY</span> 可以按照属性对表分组</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>当用上 <span class="keyword">GROUP</span> <span class="keyword">BY</span>后的聚集函数是对每一个组进行聚集</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">HAVING</span>和 <span class="keyword">WHERE</span>类似，都是起到过滤作用，但是<span class="keyword">HAVING</span>是对分组进行过滤，<span class="keyword">WHERE</span>是对行进行过滤</span><br><span class="line"><span class="keyword">SELECT</span> emp_no,<span class="built_in">COUNT</span>(emp_no) <span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(emp_no) <span class="operator">&gt;</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL8"><a href="#SQL8" class="headerlink" title="SQL8"></a>SQL8</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/6.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>同SQL2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary <span class="keyword">FROM</span> salaries</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL10"><a href="#SQL10" class="headerlink" title="SQL10"></a>SQL10</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/7.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>不包含用 <span class="keyword">NOT</span> <span class="keyword">IN</span>(...)</span><br><span class="line"><span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">WHERE</span> emp_no <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> dept_manager</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><hr><h2 id="SQL11"><a href="#SQL11" class="headerlink" title="SQL11"></a>SQL11</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/8.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>等值连接<span class="operator">+</span>条件判断</span><br><span class="line"><span class="keyword">SELECT</span> emp.emp_no,man.emp_no <span class="keyword">FROM</span> dept_emp emp,dept_manager man</span><br><span class="line">  <span class="keyword">WHERE</span> emp.dept_no <span class="operator">=</span> man.dept_no <span class="operator">&amp;&amp;</span> emp.emp_no <span class="operator">!=</span> man.emp_no</span><br></pre></td></tr></table></figure><hr><h2 id="SQL12"><a href="#SQL12" class="headerlink" title="SQL12"></a>SQL12</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/9.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>首先是内连接，若不匹配直接不显示。因为两个表有两个相同属性，from_date数据不同所以不能用自然连接</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>然后用窗口函数 <span class="keyword">OVER</span>(PARITION BY... <span class="keyword">ORDER</span> <span class="keyword">BY</span>) <span class="keyword">as</span> ... 可以分组进行排序，并且不修改原来的数据只添加一个排序列</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>要求TOPN的题都可以用窗口函数嵌套上查询和<span class="keyword">where</span>条件把rank<span class="operator">=</span>N的取出来</span><br><span class="line"><span class="keyword">SELECT</span> t.dept_no,t.emp_no,t.salary</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> d.dept_no,d.emp_no,d.salary,<span class="built_in">DENSE_RANK</span>()</span><br><span class="line">          <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> d.dept_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> d.salary <span class="keyword">DESC</span>) <span class="keyword">AS</span> sal_rank</span><br><span class="line">          <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> emp.dept_no,emp.emp_no,s.salary</span><br><span class="line">                  <span class="keyword">FROM</span> dept_emp emp</span><br><span class="line">                  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries s <span class="keyword">ON</span> emp.emp_no <span class="operator">=</span> s.emp_no) d</span><br><span class="line">       ) t</span><br><span class="line">  <span class="keyword">WHERE</span> t.sal_rank <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL15"><a href="#SQL15" class="headerlink" title="SQL15"></a>SQL15</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/10.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>值不相等用<span class="operator">!=</span>，非空用 <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>字符串用<span class="string">&#x27;&#x27;</span>引上</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>多个条件用 <span class="keyword">AND</span>连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">WHERE</span> emp_no <span class="operator">%</span> <span class="number">2</span> <span class="operator">!=</span> <span class="number">0</span> <span class="keyword">AND</span> last_name <span class="operator">!=</span> <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL16"><a href="#SQL16" class="headerlink" title="SQL16"></a>SQL16</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/11.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>要对分组后的聚集函数的结果进行 <span class="keyword">ORDER</span> <span class="keyword">BY</span>，需要先对结果起个别名</span><br><span class="line"><span class="keyword">SELECT</span> t.title,<span class="built_in">AVG</span>(s.salary) <span class="keyword">AS</span> sal_avg <span class="keyword">FROM</span> titles t</span><br><span class="line">  <span class="keyword">INNER</span> <span class="keyword">JOIN</span> salaries s <span class="keyword">ON</span> t.emp_no <span class="operator">=</span> s.emp_no</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> t.title</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> sal_avg</span><br></pre></td></tr></table></figure><hr><h2 id="SQL17"><a href="#SQL17" class="headerlink" title="SQL17"></a>SQL17</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/12.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>同SQL1</span><br><span class="line"><span class="keyword">SELECT</span> emp_no,salary <span class="keyword">FROM</span> salaries</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">1</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="SQL18"><a href="#SQL18" class="headerlink" title="SQL18"></a>SQL18</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/13.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>怪题</span><br><span class="line"><span class="keyword">SELECT</span> s.emp_no, s.salary, e.last_name, e.first_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> salaries s</span><br><span class="line"><span class="keyword">WHERE</span> s.salary <span class="operator">=</span> (</span><br><span class="line">  <span class="keyword">select</span> <span class="built_in">max</span>(salary)</span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line">  <span class="keyword">where</span> salary <span class="operator">!=</span> ( <span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> salaries )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="SQL19"><a href="#SQL19" class="headerlink" title="SQL19"></a>SQL19</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%89%9B%E5%AE%A2sql%E7%AC%AC1-20%E9%A2%98/14.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>双左连接，左边有数据右边没有数据也显示</span><br><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept_emp t <span class="keyword">ON</span> e.emp_no <span class="operator">=</span> t.emp_no</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> t.dept_no <span class="operator">=</span> d.dept_no</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 牛客网SQL篇题库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 锁的优化</title>
      <link href="/posts/110256432.html"/>
      <url>/posts/110256432.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-锁的优化有哪些点？"><a href="#4-1-锁的优化有哪些点？" class="headerlink" title="4.1 锁的优化有哪些点？"></a>4.1 锁的优化有哪些点？</h2><ul><li><strong>减少锁的持有时间：尽量避免对整个方法synchronized，只在必要时进行synchronized</strong></li><li><strong>减小锁粒度：即缩小锁定对象的范围。例如ConcurrentHashMap对其中的某个段加锁，不要对整个HashMap加锁</strong></li><li><strong>使用读写锁，即ReadWriteLock</strong></li><li><strong>锁分离：把读写锁的思想作延伸，对不同的操作功能加锁。例如LinkedBlockingQueue的take()和put()方法使用不同的锁</strong></li><li><strong>锁粗化：如果对同一个锁不断地进行请求，同步和释放，这些操作本身就会占用大量的系统资源</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC4%E7%AB%A0%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>JVM对锁的优化：</strong><ul><li><strong>偏向锁：当一个线程获得锁，就进入偏向模式。再次请求锁时，无需同步</strong></li><li><strong>轻量级锁：如果偏向锁失败，则尝试轻量级锁。若加锁失败轻量级锁被其他线程争夺到，则转为重量级锁</strong></li><li><strong>自旋锁：在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取</strong></li><li><strong>锁消除：去除不可能存在共享资源竞争的锁</strong></li></ul></li></ul><hr><h2 id="4-3-ThreadLocal是与锁不同的另一个思路"><a href="#4-3-ThreadLocal是与锁不同的另一个思路" class="headerlink" title="4.3 ThreadLocal是与锁不同的另一个思路"></a>4.3 ThreadLocal是与锁不同的另一个思路</h2><ul><li><p><strong>除了锁可以保证线程安全，还可以通过增加资源来保证</strong></p></li><li><p><strong>ThreadLocal实际是Thread.ThreadLocalMap中一条记录的引用。而这个ThreadLocalMap实际上是在任何地方都可以访问到的。所以， <code>他实际是在存储全局变量，只不过这个全局变量比较特殊，每一个实例都跟一个线程绑定了。</code> 你在A线程set了这个变量进去，那这个变量只是A的，只有A线程运行时才能访问到，线程B是访问不到的，除非线程B也set一个，也就是所谓的每个线程持有一个副本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ThreadLocal的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//设置ThreadLocal的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//删除ThreadLocal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//初始化ThreadLocal的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>这里仅了解，后续会作专栏深入分析</strong></p></li></ul><hr><h2 id="4-4-CAS比较交换也是与锁不同的一种新思路"><a href="#4-4-CAS比较交换也是与锁不同的一种新思路" class="headerlink" title="4.4 CAS比较交换也是与锁不同的一种新思路"></a>4.4 CAS比较交换也是与锁不同的一种新思路</h2><ul><li><strong>CAS(V,E,N)三个参数，V表示要更新的变量，E表示预期值，N表示新值。</strong></li><li><strong>只有V=E时，才会更新V为N。否则宣布失败，并返回V当前值，并且不会被挂起，可再次尝试</strong></li><li><strong>简单的说，E就是你以为V应该是多少了，如果V不是你想的那样，说明已经被其他线程改过了，就得重新读，再次尝试就好了</strong></li></ul><h3 id="JDK并发包中的atomic包就是使用CAS理论："><a href="#JDK并发包中的atomic包就是使用CAS理论：" class="headerlink" title="JDK并发包中的atomic包就是使用CAS理论："></a>JDK并发包中的atomic包就是使用CAS理论：</h3><ul><li><strong>AtomicInteger：基于CAS理论的无锁的线程安全的整数，原理如图 incrementAndGet方法是使用CAS操作让自己+1</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC4%E7%AB%A0%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 《Java高并发程序设计》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 JDK并发包</title>
      <link href="/posts/4214418351.html"/>
      <url>/posts/4214418351.html</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-1-重入锁ReentrantLock和synchronized的区别"><a href="#3-1-1-重入锁ReentrantLock和synchronized的区别" class="headerlink" title="3.1.1 重入锁ReentrantLock和synchronized的区别"></a>3.1.1 重入锁ReentrantLock和synchronized的区别</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">    lock.lock();<span class="comment">//指定何时加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();<span class="comment">//指定何时解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ReentrantLock的特点：</strong><ul><li><strong>在等待锁的过程中，可以中断线程让他不再等待，lock.lockInterruptibly()</strong></li><li><strong>可以指定公平锁或者非公平锁</strong><ul><li><strong>公平锁的意思就是当锁可用时，先申请该锁的线程先获得锁</strong></li></ul></li><li><strong>提供了Condition类，可以实现synchronized类似wait/notify的功能</strong></li></ul></li><li><strong>当需要使用ReentrantLock这三个特点时使用，其他时候可以使用synchronized</strong></li></ul><hr><h2 id="3-1-3-信号量（Semaphore）"><a href="#3-1-3-信号量（Semaphore）" class="headerlink" title="3.1.3 信号量（Semaphore）"></a>3.1.3 信号量（Semaphore）</h2><ul><li><strong>用来指定同时可以有多少线程访问某个资源</strong></li></ul><hr><h2 id="3-1-4-ReadWriteLock读写锁"><a href="#3-1-4-ReadWriteLock读写锁" class="headerlink" title="3.1.4 ReadWriteLock读写锁"></a>3.1.4 ReadWriteLock读写锁</h2><ul><li><strong>读写锁是为了防止读操作和读操作之间不阻塞，读写锁访问约束如下图所示</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/0.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><hr><h2 id="3-1-5-倒计时器（CountDownLatch）"><a href="#3-1-5-倒计时器（CountDownLatch）" class="headerlink" title="3.1.5 倒计时器（CountDownLatch）"></a>3.1.5 倒计时器（CountDownLatch）</h2><ul><li><strong>适用场景：火箭发射</strong></li><li><strong>主线程在CountDownLatch上等待，当所有前置任务完成后，主线程再执行</strong></li></ul><hr><h2 id="3-2-线程池"><a href="#3-2-线程池" class="headerlink" title="3.2 线程池"></a>3.2 线程池</h2><h3 id="首先是线程池框架："><a href="#首先是线程池框架：" class="headerlink" title="首先是线程池框架："></a>首先是线程池框架：</h3><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h3 id="如何使用线程池？"><a href="#如何使用线程池？" class="headerlink" title="如何使用线程池？"></a>如何使用线程池？</h3><ul><li><strong>常用的线程池</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>手动创建线程池</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>线程池实现原理</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC3%E7%AB%A0JDK%E5%B9%B6%E5%8F%91%E5%8C%85/4.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>即和corePoolSize、workQueue、maximumPoolSize比较</strong></li></ul><hr><h2 id="3-3-JDK并发容器（仅了解，后续专门出专栏深入分析）"><a href="#3-3-JDK并发容器（仅了解，后续专门出专栏深入分析）" class="headerlink" title="3.3 JDK并发容器（仅了解，后续专门出专栏深入分析）"></a>3.3 JDK并发容器（仅了解，后续专门出专栏深入分析）</h2><ul><li><strong>ConcurrentHashMap</strong></li><li><strong>CopyOnWriteArrayList</strong></li><li><strong>BlockingQueue</strong></li><li><strong>ConcurrentSkipListMap</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java高并发程序设计》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章 类加载机制</title>
      <link href="/posts/1316463453.html"/>
      <url>/posts/1316463453.html</url>
      
        <content type="html"><![CDATA[<h2 id="类从被加载到JVM到卸载出内存的完整生命周期？"><a href="#类从被加载到JVM到卸载出内存的完整生命周期？" class="headerlink" title="类从被加载到JVM到卸载出内存的完整生命周期？"></a>类从被加载到JVM到卸载出内存的完整生命周期？</h2><p><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC7%E7%AB%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="说一下各个步骤？"><a href="#说一下各个步骤？" class="headerlink" title="说一下各个步骤？"></a>说一下各个步骤？</h2><h3 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h3><ul><li><strong>查找并加载类文件的二进制数据</strong></li><li><strong>会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的数据的入口</strong></li></ul><h3 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h3><ul><li><strong>把已经读入内存的类的二进制数据放到虚拟机环境中，包括以下步骤：</strong><ul><li><strong>验证：确保被加载类的正确性</strong></li><li><strong>准备：为类的静态变量分配内存，并初始化</strong></li><li><strong>解析：把常量池中的符号引用替换为直接引用</strong></li></ul></li></ul><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化：</strong></h3><ul><li><strong>为类的静态变量赋初值</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章 Class文件结构</title>
      <link href="/posts/3853486135.html"/>
      <url>/posts/3853486135.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Class文件？"><a href="#什么是Class文件？" class="headerlink" title="什么是Class文件？"></a>什么是Class文件？</h2><ul><li><strong>Class文件是一组以8字节为单位的字节流，各个数据项目按顺序紧凑排列</strong></li><li><strong>Class文件格式只有两种类型：无符号数和表</strong><ul><li><strong>无符号数是基本数据类型，如u1，u2，u4，u8代表1个字节，2个字节，4个字节，8个字节的无符号数</strong></li><li><strong>表是由多个无符号数和其他表组成的复合数据结构，一般名称以_info结尾</strong></li></ul></li></ul><hr><h2 id="具体说一下Class文件的结构？"><a href="#具体说一下Class文件的结构？" class="headerlink" title="具体说一下Class文件的结构？"></a>具体说一下Class文件的结构？</h2><ul><li><strong>首先头4个字节是魔数，有这4个字节的才是Class文件</strong></li><li><strong>后面第5、6字节是次版本号，第7、8字节是主版本号</strong></li><li><strong>第9字节开始是常量池，每个常量开头第一个字节表示常量池的某个项目标记，按照标记确定是哪个常量类型，第二个字节是长度，根据长度往后找这么多个字节表示常量</strong><ul><li><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC6%E7%AB%A0Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>常量池结束后两个字节代表访问标志，包括这个Class是类还是接口，是不是public，是不是abstract等</strong><ul><li><img "" class="lazyload placeholder" data-original="/medias/%E7%AC%AC6%E7%AB%A0Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/image-1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>访问标志之后是类索引、父类索引和接口索引集合</strong></li><li><strong>之后是字段表集合，用来描述类/接口中的变量，包括各种修饰符和引用常量池的常量</strong></li><li><strong>然后是方法表集合，和字段表几乎一样，用来描述类/接口中的方法</strong></li><li><strong>最后是属性表集合，字段表和方法表都可以拥有自己的属性表集合，例如栈深度、变量存储空间、行号等</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 垃圾回收</title>
      <link href="/posts/121600763.html"/>
      <url>/posts/121600763.html</url>
      
        <content type="html"><![CDATA[<h2 id="怎么判断对象是否需要回收？"><a href="#怎么判断对象是否需要回收？" class="headerlink" title="怎么判断对象是否需要回收？"></a>怎么判断对象是否需要回收？</h2><blockquote><ul><li><strong>引用计数法：给对象添加一个<code>引用</code>计数器，每有一个地方<code>引用</code>它就+1，<code>引用</code>失效就-1，如果是0则回收。</strong><ul><li><strong>优点：效率高；缺点：无法回收循环<code>引用</code>的对象</strong></li></ul></li><li><strong>可达性分析法：当一个对象到GC Roots对象没有任何<code>引用</code>链，则回收</strong><ul><li><strong>GC Roots对象包括虚拟机栈帧中<code>引用</code>的对象、方法区静态变量/常量<code>引用</code>的对象、Native方法<code>引用</code>的对象</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/184604/33/14082/59596/60f395a6Ecd2724bd/d1c15f01625eb0f3.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li></ul></blockquote><hr><h2 id="那么如何判断对象是否被引用呢？"><a href="#那么如何判断对象是否被引用呢？" class="headerlink" title="那么如何判断对象是否被引用呢？"></a>那么如何判断对象是否被引用呢？</h2><blockquote><ul><li><strong>强引用：类似<code>Object obj = new Object()</code> ，只要强引用存在，就不会回收掉</strong></li><li><strong>软引用：用SoftReference来实现，用来描述还有用但非必需的对象，会在内存溢出之前回收</strong></li><li><strong>弱引用：用WeakReference来实现，用来描述非必需的对象，不管内存够不够在下一次垃圾回收时一定会被回收</strong></li><li><strong>虚引用：用PhantomReference来实现，虚引用的对象无法获得实例，随时都可能回收</strong></li></ul></blockquote><hr><h2 id="垃圾回收算法？"><a href="#垃圾回收算法？" class="headerlink" title="垃圾回收算法？"></a>垃圾回收算法？</h2><blockquote><ul><li><strong>标记-清除法：标记所有要回收的对象，然后回收</strong><ul><li><strong>缺点：效率不高且会产生大量不连续的内存碎片，导致分配大对象时频繁GC</strong></li><li><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/185383/8/14522/53934/60f3d996Ef41bae8f/d83aeb330f503134.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>复制算法：<strong><strong>一般用于新生代，</strong></strong>将内存分成两块，每次只使用一块，每次回收都复制到另一块上，清除原来的空间</strong><ul><li><strong>缺点：内存缩小一半，浪费</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/176921/26/14679/62356/60f3daffEd4c25677/15d4ef96862c0ab5.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li><li><strong>标记整理法：一般用于老年代，和标记清除法一样，但是在标记后先整理，然后再回收</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/43697/29/16010/52898/60f3dc75E1aa9490e/0e7b3d567b1f6e36.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul></blockquote><hr><h2 id="如何真正实现垃圾回收？"><a href="#如何真正实现垃圾回收？" class="headerlink" title="如何真正实现垃圾回收？"></a>如何真正实现垃圾回收？</h2><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/173645/25/20673/66480/60f7b9b6Ec08b96f1/62fb3ab1ee064160.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="具体介绍一下CMS？"><a href="#具体介绍一下CMS？" class="headerlink" title="具体介绍一下CMS？"></a>具体介绍一下CMS？</h3><ul><li><strong>CMS基于标记-清除法，目标为获取最短回收停顿时间的收集器</strong></li><li><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/182782/9/15017/89966/60f7bc62Ec7fa78c8/2c08336b28b74381.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li><li><strong>共分为四个步骤：</strong><ul><li><strong>初始标记：只标记一下GC Roots能连接的对象</strong></li><li><strong>并发标记：GC Roots tracing，即可达性分析</strong></li><li><strong>重新标记：修正并发标记期间因用户线程导致产生变动的对象的标记</strong></li><li><strong>并发清理：并发垃圾回收</strong></li></ul></li><li><strong>CMS优点：不停顿，并发执行。</strong></li><li><strong>缺点：并发执行对CPU资源压力大，且无法处理在处理过程中产生的垃圾，且标记清除法会产生垃圾碎片</strong></li></ul><h3 id="具体介绍一下G1？"><a href="#具体介绍一下G1？" class="headerlink" title="具体介绍一下G1？"></a>具体介绍一下G1？</h3><ul><li><strong>G1是当前垃圾收集器最前沿成果之一，采用标记整理法，且能精确控制停顿时间</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/174570/7/20663/93930/60f7c803Ea2dcff2e/f72746522c8fde5d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><ul><li><strong>和CMS很类似，但是G1会把内存分成多个独立的区域，并根据允许回收的时间优先回收垃圾最多的区域</strong></li></ul></li></ul><hr><h2 id="具体说一下新生代和老年代的对象"><a href="#具体说一下新生代和老年代的对象" class="headerlink" title="具体说一下新生代和老年代的对象"></a>具体说一下新生代和老年代的对象</h2><ul><li><strong>首先大多数情况，对象在新生代Eden区中分配。当Eden区空间不够时，会触发一次Minor GC（新生代GC）</strong></li><li><strong>大对象直接进入到老年代</strong></li><li><strong>长期存活的对象直接进入老年代。</strong><ul><li><strong>对象在Eden区出生并经过一次Minor GC仍然存活且能被Survivor区容纳，会被移动到Survivor区，并且设置年龄为1岁。每熬过一次Minor GC年龄就+1</strong></li><li><strong>如果Survivor区中相同年龄的所有对象大小总和大于Survivor区的一半，那么年龄大于等于该年龄的对象都去老年代</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 内存分配</title>
      <link href="/posts/815353185.html"/>
      <url>/posts/815353185.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-2-JVM体系结构概览"><a href="#2-2-JVM体系结构概览" class="headerlink" title="2.2 JVM体系结构概览"></a>2.2 JVM体系结构概览</h2><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/173588/33/19717/156152/60f17a35Ee1bce496/2e168a5d18d9e86a.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h3 id="运行时数据区包含以下部分"><a href="#运行时数据区包含以下部分" class="headerlink" title="运行时数据区包含以下部分"></a>运行时数据区包含以下部分</h3><blockquote><ul><li><strong>程序计数器：（线程私有）</strong><ul><li><strong>一块较小的内存空间, 用来存储指向下一条指令的地址</strong></li><li><strong>这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域</strong></li></ul></li><li><strong>虚拟机栈：（线程私有）</strong><ul><li><strong>每个方法在执行的同时都会创建一个栈帧</strong></li><li><strong>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</strong></li></ul></li><li><strong>本地方法栈：（线程私有）</strong><ul><li><strong>和虚拟机栈类似，区别为此栈执行的是Native方法</strong></li></ul></li><li><strong>堆：（线程共享）</strong><ul><li><strong>创建的对象实例和数组都保存在堆中</strong></li><li><strong>运行时动态分配内存大小，自动垃圾回收</strong></li></ul></li><li><strong>方法区：（线程共享）</strong><ul><li><strong>用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></li></ul></li></ul></blockquote><hr><h3 id="栈、堆、方法区是怎么交互的？"><a href="#栈、堆、方法区是怎么交互的？" class="headerlink" title="栈、堆、方法区是怎么交互的？"></a>栈、堆、方法区是怎么交互的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMain</span> </span>&#123; <span class="comment">//运行时，JVM把AppMain的信息都放入方法区    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//main成员方法本身放入方法区。    </span></span><br><span class="line">        Sample test1 = <span class="keyword">new</span> Sample( <span class="string">&quot; 测试1 &quot;</span> ); <span class="comment">//test1是引用，所以放到栈区里，Sample是对象应该放到堆里         </span></span><br><span class="line">        test1.printName();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="上述代码的JVM执行流程："><a href="#上述代码的JVM执行流程：" class="headerlink" title="上述代码的JVM执行流程："></a>上述代码的JVM执行流程：</h4><ul><li><strong>首先启动了一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中。这一过程称为AppMain类的加载过程。</strong></li><li><strong>接着，JVM定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：Sample test1 = new Sample(“测试1”);</strong><ul><li><strong>Java虚拟机一看，不就是建立一个Sample类的实例吗，简单，于是就直奔方法区（方法区存放已经加载的类的相关信息，如类、静态变量和常量）而去，先找到Sample类的类型信息再说。结果呢，嘿嘿，没找到，这会儿的方法区里还没有Sample类呢（即Sample类的类信息还没有进入方法区中）。可JVM也不是一根筋的笨蛋，于是，它发扬“自己动手，丰衣足食”的作风，立马加载了Sample类， 把Sample类的相关信息存放在了方法区中。</strong></li><li><strong>Sample类的相关信息加载完成后。Java虚拟机做的第一件事情就是在堆中为一个新的Sample类的实例分配内存，这个Sample类的实例持有着指向方法区的Sample类的类型信息的引用（Java中引用就是内存地址）。这里所说的引用，实际上指的是Sample类的类型信息在方法区中的内存地址，其实，就是有点类似于C语言里的指针啦~~，而这个地址呢，就存放了在Sample类的实例的数据区中。</strong></li><li><strong>然后位于“=”前的test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，test1这个局部变量会被JVM添加到执行main()方法的主线程的Java方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，test1这个局部变量持有指向Sample类的实例的引用（即内存地址）。</strong></li></ul></li><li><strong>JVM将继续执行后续指令，执行printName()方法。当JVM执行test1.printName()方法时，JVM根据局部变量test1持有的引用，定位到堆中的Sample类的实例，再根据Sample类的实例持有的引用，定位到方法区中Sample类的类型信息（包括①类，②静态变量，③静态方法，④常量和⑤成员方法），从而获取printName()成员方法的字节码，接着执行printName()成员方法包含的指令。</strong></li></ul><hr><h2 id="从垃圾回收的角度看java堆？"><a href="#从垃圾回收的角度看java堆？" class="headerlink" title="从垃圾回收的角度看java堆？"></a>从垃圾回收的角度看java堆？</h2><ul><li><p><strong>java堆从垃圾回收的角度上可以分为新生代和老年代</strong></p><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/172817/23/19826/38200/60f27e1eEb41c1672/5997f348a7e5fef9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong><h3 id="具体说一下新生代和老年代？"><a href="#具体说一下新生代和老年代？" class="headerlink" title="具体说一下新生代和老年代？"></a>具体说一下新生代和老年代？</h3></li></ul></li><li><p><strong>新生代用来存放的是新分配的对象。经过垃圾回收没有回收掉的对象会被复制到老年代</strong></p></li><li><p><strong>老年代上的对象比新生代对象时间长，大对象直接进入老年代</strong></p></li><li><p><strong>以前的永久代已经被取代为元空间，不在虚拟机里，直接是本地内存</strong></p></li></ul><hr><h2 id="如何通过栈上的引用对象访问堆上的实例呢"><a href="#如何通过栈上的引用对象访问堆上的实例呢" class="headerlink" title="如何通过栈上的引用对象访问堆上的实例呢"></a>如何通过栈上的引用对象访问堆上的实例呢</h2><blockquote><ul><li><strong>主流有两种访问方式，一个是句柄池，另一个是直接指针</strong><ul><li><strong>句柄池：在java堆中划分一部分内存作为句柄池，包含指向实例数据和对象类型数据的指针，reference存储句柄池的地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/193984/7/13445/63957/60f28159E949248bb/1a210ba372c20357.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>直接指针：reference直接存储对象地址，实例对象包含对象类型数据的地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/172188/22/20053/78857/60f2833cE26949bb1/e6e29c6b872144d2.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 《深入理解Java虚拟机》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 Java并行程序基础</title>
      <link href="/posts/1877506347.html"/>
      <url>/posts/1877506347.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-进程和线程"><a href="#2-1-进程和线程" class="headerlink" title="2.1 进程和线程"></a>2.1 进程和线程</h2><ul><li><strong>进程是独立运行、资源分配的基本单位，程序运行起来就是进程</strong></li><li><strong>线程是资源调度的基本单位，一个进程可以有多个线程</strong></li></ul><h3 id="线程的生命周期如下："><a href="#线程的生命周期如下：" class="headerlink" title="线程的生命周期如下："></a>线程的生命周期如下：</h3><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/183619/38/12549/74295/60e2632cEb819b275/319a62e48ed7704f.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><blockquote><ul><li><strong>New状态表示刚刚创建的线程，还没开始执行，要start（）方法调用后才执行</strong></li><li><strong>线程执行时是RUNNABLE状态，表示一切资源都准备好了</strong></li><li><strong>如果遇到synchronized同步块，则会被阻塞BLOCKED</strong></li><li><strong>当线程中调用wait、join方法时，当前线程就会进入等待态WAITING，等待notify方法唤醒</strong></li><li><strong>当线程中调用wait(time)等方法时，当前线程就会进入有限时间等待态TIMED_WAITING</strong></li><li><strong>线程执行完毕后，就会进入TEAMINATED态</strong></li></ul></blockquote><hr><h2 id="新建线程的方法："><a href="#新建线程的方法：" class="headerlink" title="新建线程的方法："></a>新建线程的方法：</h2><ul><li><strong>参考文献：<a href="https://zhuanlan.zhihu.com/p/144694652">创建线程的方法</a></strong></li><li><strong>本质是两种方法</strong><ul><li><strong>继承 Thread 类 或者直接 匿名内部类</strong></li><li><strong>实现 Runnable 接口</strong></li></ul></li><li><strong>还有其他很多表现形式，但本质都是上面两种</strong><ul><li><strong>通过 ExecutorService 和 Callable 实现有返回值的线程 (这里仅作了解)</strong></li><li><strong>基于线程池的execute()，创建临时线程 (这里仅作了解)</strong></li></ul></li></ul><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line">ThreadDemo t1 = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable 接口创建线程类 ThreadDemo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//重写run()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程对象,传入Runnable实现类实例</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo());</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h3 id="通过-ExecutorService-和-Callable-实现有返回值的线程"><a href="#通过-ExecutorService-和-Callable-实现有返回值的线程" class="headerlink" title="通过 ExecutorService 和 Callable 实现有返回值的线程"></a><strong>通过 ExecutorService 和 Callable 实现有返回值的线程</strong></h3><ul><li><strong>我们需要在主线程中开启多个线程去执行一个任务，然后收集各个线程的返回结果并将最终结果进行汇总，这时就需要用到 Callable 接口</strong></li><li><strong>如果不需要返回值，仍然可以用Runnable</strong></li><li><strong>线程的返回结果为Future对象，isDone方法判断线程是否完成，get方法获取结果</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过实现Callable接口来创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CThread</span><span class="params">(String name )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写call()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建接收结果的列表集合</span></span><br><span class="line">List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">    <span class="comment">//创建线程对象</span></span><br><span class="line">    Callable c = <span class="keyword">new</span> CThread(<span class="string">&quot;线程&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将线程对象提交到线程池中，并将返回结果接收</span></span><br><span class="line">    Future future = pool.submit(c);</span><br><span class="line">    System.out.println(<span class="string">&quot;线程&quot;</span>+i+<span class="string">&quot;已经加入线程池&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将返回结果加入集合</span></span><br><span class="line">    list.add(future);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印返回结果</span></span><br><span class="line"><span class="keyword">for</span> (Future future : list) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get().toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="启动线程："><a href="#启动线程：" class="headerlink" title="启动线程："></a>启动线程：</h3><blockquote><ul><li><strong>start方法是新建线程并启动线程</strong></li><li><strong>run方法是启动当前线程，不会开启新线程</strong></li></ul></blockquote><hr><h2 id="线程终止和中断"><a href="#线程终止和中断" class="headerlink" title="线程终止和中断"></a>线程终止和中断</h2><ul><li><strong>终止线程不要用stop方法，会出现数据不一致问题</strong></li><li><strong>线程中断的方法：</strong><ul><li><strong>用interrupt，并且在while循环中通过if判断中断标志位即可</strong></li><li><strong>Thread.sleep(time)，让线程休眠</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程被中断。&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="2-3-初识volatile"><a href="#2-3-初识volatile" class="headerlink" title="2.3 初识volatile"></a>2.3 初识volatile</h2><blockquote><p><strong>作用：</strong></p><ul><li><strong>volatile是同步机制。读volatile变量之前，会让本地缓存失效，必须去主存中读最新值。写volatile变量会直接刷新到主存</strong></li><li><strong>volatile可以禁止指令重排</strong></li></ul><p><strong>缺点：不能保证i++的原子性</strong></p></blockquote><hr><h2 id="2-5-守护线程"><a href="#2-5-守护线程" class="headerlink" title="2.5 守护线程"></a>2.5 守护线程</h2><ul><li><strong>在线程start之前，setDaemon(true)方法可以设置守护线程</strong></li><li><strong>守护线程会在父线程结束后自动结束</strong></li></ul><hr><h2 id="2-7-初识synchronized"><a href="#2-7-初识synchronized" class="headerlink" title="2.7 初识synchronized"></a>2.7 初识synchronized</h2><h3 id="synchronized的作用："><a href="#synchronized的作用：" class="headerlink" title="synchronized的作用："></a>synchronized的作用：</h3><blockquote><ul><li><strong>和volatile一样都是为了实现线程安全，但是volatile不能真正做到线程安全，因为不能保证原子性</strong></li><li><strong>于是就有了synchronzied，用来实现线程同步。会对同步的代码加锁，只允许一个线程进入同步块</strong></li></ul></blockquote><h3 id="synchronized怎么用？"><a href="#synchronized怎么用？" class="headerlink" title="synchronized怎么用？"></a>synchronized怎么用？</h3><ul><li><p><strong>synchronized有三种用法：</strong></p><ul><li><p><strong>给对象加锁:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>给实例非静态方法加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(); <span class="comment">//在run方法内部调用synchronized非静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>给静态方法加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun(); <span class="comment">//在run方法内部调用synchronized静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>synchrozied三种用法总结：</strong></p><ul><li><strong>对象锁和非静态方法都要用同一个Runnable实例创建线程，这样对同一个实例对象加锁，才能实现多线程的同步</strong></li><li><strong>静态方法实际上是对类加锁，所以即使是不同的Runnable实例，只要是同一个类，即可完成线程同步</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java高并发程序设计》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 走进并行世界</title>
      <link href="/posts/2486601876.html"/>
      <url>/posts/2486601876.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-2-1-同步-异步、阻塞-非阻塞式调用"><a href="#1-2-1-同步-异步、阻塞-非阻塞式调用" class="headerlink" title="1.2.1 同步/异步、阻塞/非阻塞式调用"></a>1.2.1 同步/异步、阻塞/非阻塞式调用</h2><blockquote><ul><li><strong>同步异步关注的是调用完成时消息的通知方式</strong><ul><li><strong>同步是调用方一直问询发现完成</strong></li><li><strong>异步是一调用就立即返回，被调用方完成后会通知调用方已完成</strong></li></ul></li></ul></blockquote><p><strong><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-c8953552c4bbe4ab31d570b31680726e_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><blockquote><ul><li><strong>阻塞非阻塞关注的是发出请求到调用完成之间调用方的状态</strong><ul><li><strong>等待数据返回时设置为挂起态则为阻塞，不是挂起态则非阻塞</strong></li></ul></li></ul></blockquote><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-6507ab3517814b1b84fbff9a3eb31842_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><blockquote><ul><li><strong>举个例子：</strong><ul><li><strong>老张把水壶放到火上，立等水开。（同步阻塞）</strong></li><li><strong>老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）</strong></li><li><strong>老张把响水壶放到火上，立等水开。（异步阻塞）</strong></li><li><strong>老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</strong></li></ul></li></ul></blockquote><hr><h2 id="1-2-2-并发和并行"><a href="#1-2-2-并发和并行" class="headerlink" title="1.2.2 并发和并行"></a>1.2.2 并发和并行</h2><ul><li><strong>并发指的是多个进程宏观上同时进行，微观上交替进行</strong></li><li><strong>并行是真的多个进程同时执行，只存在于多CPU的系统中，有几个CPU就能并行几个线程</strong></li></ul><hr><h2 id="1-2-3-临界区"><a href="#1-2-3-临界区" class="headerlink" title="1.2.3 临界区"></a>1.2.3 临界区</h2><ul><li><strong>临界区是访问临界资源的代码段，每一次只能一个线程使用，其他线程等待</strong></li></ul><hr><h2 id="1-2-5-死锁、饥饿、活锁"><a href="#1-2-5-死锁、饥饿、活锁" class="headerlink" title="1.2.5 死锁、饥饿、活锁"></a>1.2.5 死锁、饥饿、活锁</h2><ul><li><strong>死锁：至少两个进程/线程一起死锁，都处于阻塞态</strong></li><li><strong>饥饿：进程/线程一直无法获得资源，例如优先级太低一直排不到它</strong></li></ul><hr><h2 id="1-5-java内存模型（JMM）"><a href="#1-5-java内存模型（JMM）" class="headerlink" title="1.5 java内存模型（JMM）"></a>1.5 java内存模型（JMM）</h2><ul><li><strong>原子性：多线程执行时，每个线程执行完之前不能被其他线程干扰（例如在32位系统多线程写long数据）</strong></li><li><strong>可见性：一个线程修改了共享变量的值，其他线程能否立即知道这个修改</strong></li><li><strong>有序性：在并发时，指令重排导致程序的执行可能就会出现乱序</strong></li></ul><h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/179590/20/12542/217760/60e166d7E2012bb7e/572e1bf3a2494979.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>堆：运行时动态的分配内存大小，垃圾回收</strong></li><li><strong>栈：存在栈中的数据可以共享，主要存放基本数据类型</strong></li><li><strong>如图所示，如果两个线程同时调用了同一个对象Object3，都可以访问这个对象的成员变量，但是线程拥有的是对象的私有拷贝，保存在线程的本地内存中，然后再写回内存中，但是这样会出错，需要保证原子性可见性有序性，需要JMM</strong></li></ul><hr><h2 id="1-5-4-Happen-Before规则"><a href="#1-5-4-Happen-Before规则" class="headerlink" title="1.5.4 Happen-Before规则"></a>1.5.4 Happen-Before规则</h2><p><strong>参考文献：</strong>   <a href="https://zhuanlan.zhihu.com/p/126275344">知乎原文</a></p><ol><li><strong>程序顺序原则：一个线程内根据代码顺序执行</strong></li><li><strong>锁原则：解锁（unlock）要在加锁（lock）之前</strong></li></ol><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/178159/15/12705/185557/60e16f07Eb88abc9f/db76f74baff73153.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ol start="3"><li><strong>volatile规则：volatile变量的写要在读之前，结合第四条传递性一起看</strong></li><li><strong>传递性：A先于B，B先于C，则A必然先于C</strong></li></ol><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/190326/18/11645/76630/60e170b2E2dc2acb6/5a441ab952fe5a9b.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><br><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/185824/18/12742/225582/60e17159Ef4a811f4/eea05b6cd1ea0969.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ol start="5"><li><strong>start()原则：主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作</strong></li><li><strong>join()原则：线程 A 调用线程 B.join()让线程B插到A前面，那么线程B的任何操作都要先于A</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 《Java高并发程序设计》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章 确保Web安全的HTTPS</title>
      <link href="/posts/976065235.html"/>
      <url>/posts/976065235.html</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-HTTP的缺点："><a href="#7-1-HTTP的缺点：" class="headerlink" title="7.1 HTTP的缺点："></a>7.1 HTTP的缺点：</h2><blockquote><ul><li><strong>用明文通信（不加密），有可能会被窃听</strong></li><li><strong>不验证身份，可能伪装</strong></li><li><strong>无法保证报文的完整性，可能被篡改</strong></li></ul></blockquote><hr><h2 id="7-2-HTTP-加密-认证-完整性保护-HTTPS"><a href="#7-2-HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="7.2 HTTP+加密+认证+完整性保护=HTTPS"></a>7.2 HTTP+加密+认证+完整性保护=HTTPS</h2><h3 id="7-2-3-HTTPS是怎么加密的？"><a href="#7-2-3-HTTPS是怎么加密的？" class="headerlink" title="7.2.3 HTTPS是怎么加密的？"></a>7.2.3 HTTPS是怎么加密的？</h3><blockquote><ul><li><strong>对称加密：加密和解密使用同一密钥</strong><ul><li><strong>优点：运算速度快</strong></li><li><strong>缺点：无法安全地将密钥传输给通信方</strong></li></ul></li><li><strong>非对称加密：公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密</strong><ul><li><strong>优点：可以更安全地将公开密钥传输给通信发送方</strong></li><li><strong>缺点：运算速度慢</strong></li></ul></li><li><strong>HTTPS使用的是混合加密方式，有对称加密和非对称加密</strong><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/179946/21/12811/146203/60dfb051Ee0f63dc7/6602dc2628972ddf.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li></ul></blockquote><h2 id="7-2-4-认证"><a href="#7-2-4-认证" class="headerlink" title="7.2.4 认证"></a>7.2.4 认证</h2><h4 id="首先为什么要认证？"><a href="#首先为什么要认证？" class="headerlink" title="首先为什么要认证？"></a>首先为什么要认证？</h4><ul><li><strong>为了保证对称加密的公开密钥没有被攻击者替换，这就要用到认证</strong></li></ul><h4 id="如何认证？"><a href="#如何认证？" class="headerlink" title="如何认证？"></a>如何认证？</h4><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/173987/39/17987/253550/60dfb2abEcc926303/7afefaf1b5014ae7.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 《图解HTTP》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 返回结果的HTTP状态码</title>
      <link href="/posts/1773229755.html"/>
      <url>/posts/1773229755.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-状态码的分类"><a href="#4-1-状态码的分类" class="headerlink" title="4.1 状态码的分类"></a>4.1 状态码的分类</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/186965/26/11407/111567/60deaf6bE2a15aa4e/598cf017ef7700cc.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="4-2-2XX-成功"><a href="#4-2-2XX-成功" class="headerlink" title="4.2 2XX 成功"></a>4.2 <code>2XX</code> 成功</h2><ul><li><strong><code>200</code> ：表示从客户端发来的请求被正常处理，并返回数据</strong></li><li><strong><code>204</code> ：和<code>200</code>一样，但是不返回任何数据，只返回是否成功</strong></li><li><strong><code>206</code> ：表示客户端进行的范围请求被正常处理，并返回数据</strong></li></ul><hr><h2 id="4-3-3XX-重定向"><a href="#4-3-3XX-重定向" class="headerlink" title="4.3 3XX 重定向"></a>4.3 <code>3XX</code> 重定向</h2><ul><li><strong><code>301</code> ：永久性重定向，请求的资源被分配到新的URI，浏览器输入的网址会瞬间跳转到新URI，原先的网址不可用</strong></li><li><strong><code>302</code> ：临时性重定向，请求的资源被分配到新的URI，浏览器输入的网址会瞬间跳转到新URI，原先的网址仍可用</strong></li><li><strong><code>303</code> ：把POST提交重定向到GET，例如POST一份个人信息，服务器返回<code>303</code>，重定向到一个上传成功的页面</strong></li><li><strong><code>307</code> ：和<code>302</code>一摸一样，但是不允许POST到GET的重定向</strong></li></ul><hr><h2 id="4-4-4XX-客户端错误"><a href="#4-4-4XX-客户端错误" class="headerlink" title="4.4 4XX 客户端错误"></a>4.4 <code>4XX</code> 客户端错误</h2><ul><li><strong><code>400</code> ：表示HTTP请求报文中有语法错误</strong></li><li><strong><code>401</code> ：表示HTTP请求需要登陆认证，或者认证失败</strong></li><li><strong><code>403</code> ：表示需要的资源没有权限访问</strong></li><li><strong><code>404</code> ：表示需要访问的资源不存在</strong></li></ul><hr><h2 id="4-5-5XX-服务器错误"><a href="#4-5-5XX-服务器错误" class="headerlink" title="4.5 5XX 服务器错误"></a>4.5 <code>5XX</code> 服务器错误</h2><ul><li><strong><code>501</code> ：服务器执行请求时发生错误</strong></li><li><strong><code>503</code> ：服务器处于超负载或停机维护</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《图解HTTP》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 简单的HTTP协议</title>
      <link href="/posts/53019385.html"/>
      <url>/posts/53019385.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="2-2-HTTP请求和响应报文格式"><a href="#2-2-HTTP请求和响应报文格式" class="headerlink" title="2.2 HTTP请求和响应报文格式"></a>2.2 HTTP请求和响应报文格式</h2><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/180478/2/12183/160617/60de6ccaE6ddb17a3/758649c3c46df958.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="2-5-常用HTTP方法有哪些？"><a href="#2-5-常用HTTP方法有哪些？" class="headerlink" title="2.5 常用HTTP方法有哪些？"></a>2.5 常用HTTP方法有哪些？</h2><blockquote><ul><li><strong>GET：请求访问服务器某个资源</strong></li><li><strong>POST：和GET对应，传输某个资源</strong></li><li><strong>PUT：传输某个文件</strong></li><li><strong>HEAD：与GET相同，但只想获得报文首部，不返回数据，例如想要查询某个资源是否存在，不需要获取数据</strong></li><li><strong>DELETE：删除服务器某个资源</strong></li><li><strong>OPTIONS：查询URI某个资源支持的方法，例如返回GET、POST</strong></li></ul></blockquote><hr><h2 id="2-8-Cookie"><a href="#2-8-Cookie" class="headerlink" title="2.8 Cookie"></a>2.8 Cookie</h2><h3 id="为什么要cookie？"><a href="#为什么要cookie？" class="headerlink" title="为什么要cookie？"></a>为什么要cookie？</h3><p>要求登陆认证的web页面无法保存登陆状态，每次跳转页面都要再次登陆，为了避免这种频繁登陆，需要cookie保存登陆状态</p><h3 id="怎么使用cookie？"><a href="#怎么使用cookie？" class="headerlink" title="怎么使用cookie？"></a>怎么使用cookie？</h3><ul><li><strong>第一次登陆后，服务器返回响应，响应报文中添加一个cookie通知客户端保存cookie</strong></li><li><strong>以后每次请求，在报文中都添加一个cookie值，服务器检查cookie值的记录，有的话就不需要登陆了</strong></li></ul><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/190040/20/11105/187775/60de788dE6941cef1/6043b1e603cef490.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 《图解HTTP》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 了解Web及网络基础</title>
      <link href="/posts/3376318152.html"/>
      <url>/posts/3376318152.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-3-3-TCP-IP通信是怎么传输的？"><a href="#1-3-3-TCP-IP通信是怎么传输的？" class="headerlink" title="1.3.3 TCP/IP通信是怎么传输的？"></a>1.3.3 TCP/IP通信是怎么传输的？</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/175791/30/17454/177642/60dd6f1fE8814f6d1/ad21adf93aa8afe2.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><blockquote><ul><li><strong>从下到上以此是链路层、网络层、传输层、应用层</strong><ul><li><strong>第一个是链路层，解析的是以太网首部，包含源MAC地址和目标MAC地址</strong><ul><li><strong>在一个网络之内，也就是一”跳”之内进行MAC转发，具体看 <a href="https://mactql.github.io/posts/165302757.html#3-2-4-%E6%80%8E%E4%B9%88%E6%A0%B9%E6%8D%AEMAC%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8F%91%EF%BC%9F">怎么根据MAC地址转发</a></strong></li></ul></li><li><strong>第二个是网络层，解析的是IP首部，包含源IP地址和目标IP地址</strong><ul><li><strong>首先通过ARP查找下一”跳”对应的MAC地址，然后通过链路层实现在每一”跳”之间通信，最终和目标通信，具体看 <a href="https://mactql.github.io/posts/837272352.html#5-3-ARP">ARP是什么</a></strong></li></ul></li><li><strong>第三个是传输层，解析的是TCP首部，包含源进程端口号和目标进程端口号</strong><ul><li><strong>将大块数据分成多个报文段，并发起TCP三次握手，具体看 <a href="https://mactql.github.io/posts/3865951273.html#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%EF%BC%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%89">说一下三次握手</a></strong></li></ul></li><li><strong>最后是应用层，DNS解析以及发送HTTP请求</strong></li></ul></li></ul></blockquote><hr><h2 id="1-7-URI和URL"><a href="#1-7-URI和URL" class="headerlink" title="1.7 URI和URL"></a>1.7 URI和URL</h2><blockquote><ul><li><strong>首先URL是URI的子集</strong></li><li><strong>唯一标识网络中的资源就是URI，如果他是一条路径就是URL</strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 《图解HTTP》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第18章 java I/O</title>
      <link href="/posts/3136801953.html"/>
      <url>/posts/3136801953.html</url>
      
        <content type="html"><![CDATA[<h2 id="java的IO分为字符流和字节流："><a href="#java的IO分为字符流和字节流：" class="headerlink" title="java的IO分为字符流和字节流："></a>java的IO分为字符流和字节流：</h2><ul><li><strong>字节流一般处理图像数据或字节文件这类的二进制数据，其他数据一般是字符流</strong></li></ul><blockquote><p><strong>字符流：（以输入流为例）</strong></p><ul><li><strong>字符流中最基本的CharArrayReader和StringReader，从字符数组或字符串的数据元中读取字符</strong></li><li><strong>还有三个复杂功能的类：</strong><ul><li><strong>BufferedReader，对原始数据频繁的读会比较慢，可以采用用缓冲区读写，效率更高</strong></li><li><strong>FilterReader抽象类，创建时需要传入一个Reader对象叠加新的功能，可以跳跃字符流中特定字符等操作</strong></li><li><strong>InputStreamReader，把字节流转化为字符流。常用FileReader子类，从字节文件中转化为字符流读取</strong></li></ul></li></ul></blockquote><blockquote><p><strong>字节流：（以输入流为例）</strong></p><ul><li><strong>字符流中最基本的ByteArrayInputStream和FileInputStream，从字节数组或字节文件的数据元中读取字节</strong></li><li><strong>还有复杂功能的类：</strong><ul><li><strong>FilterInputStream抽象类，常用继承它的子类如下：</strong><ul><li><strong>BufferedInputStream，对原始数据读写频繁会很慢，采用从缓冲区不停的读写，效率更高</strong></li><li><strong>DataInputStream和DataOutputStream可以从字节流中读写数据并转换成基本数据类型</strong></li></ul></li></ul></li></ul></blockquote><h2 id="导图如下："><a href="#导图如下：" class="headerlink" title="导图如下："></a>导图如下：</h2><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/184379/15/11818/205478/60dbcff6E9fde4ddb/8a843a85dd6094a9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章 TCP与UDP</title>
      <link href="/posts/3865951273.html"/>
      <url>/posts/3865951273.html</url>
      
        <content type="html"><![CDATA[<p><strong>传输层有两个代表性的协议，TCP和UDP。TCP提供可靠的通信传输，而UDP用于让广播和细节控制交给应用的通信传输</strong></p><h2 id="6-1-1-传输层的定义"><a href="#6-1-1-传输层的定义" class="headerlink" title="6.1.1 传输层的定义"></a>6.1.1 传输层的定义</h2><p><strong>IP首部有一个协议字段，用来标识网络层的上一层所采用的是哪一种的传输层协议，判断数据是TCP内容还是UDP内容</strong></p><h3 id="6-1-2-TCP和UDP是干啥的呢？"><a href="#6-1-2-TCP和UDP是干啥的呢？" class="headerlink" title="6.1.2 TCP和UDP是干啥的呢？"></a>6.1.2 TCP和UDP是干啥的呢？</h3><p><strong>通过IP地址可以找到目标主机的位置，TCP和UDP是用来识别数据要发送给主机上的哪个应用程序，设定了一个端口号。端口号其实类似于程序地址，通过这个端口号可以确定给哪一个应用程序使用</strong></p><h3 id="6-1-4-TCP和UDP哪个好？"><a href="#6-1-4-TCP和UDP哪个好？" class="headerlink" title="6.1.4 TCP和UDP哪个好？"></a>6.1.4 TCP和UDP哪个好？</h3><p><strong>TCP是可靠的面向有连接的通信传输，UDP虽然不可靠，但是主要用于高速传输和实时性要求搞的通信或广播，例如打IP电话，所以TCP和UDP应该按需使用</strong></p><hr><h3 id="6-2-3-如何识别一个通信"><a href="#6-2-3-如何识别一个通信" class="headerlink" title="6.2.3 如何识别一个通信"></a>6.2.3 如何识别一个通信</h3><ul><li><strong>TCP/IP,UDP/IP通信中通过五个信息来识别一个通信：</strong><ul><li><strong>“源IP地址”，“目标IP地址”，“源端口号”，“目标端口号”，“传输协议(TCP/UDP)”。这五个只要有一个不同， 就可认为是两个不同的通信</strong></li></ul></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/196626/29/10182/246739/60d6dc11E792b84c1/cbbfa22ac0896912.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><hr><h2 id="6-3-UDP"><a href="#6-3-UDP" class="headerlink" title="6.3 UDP"></a>6.3 UDP</h2><ul><li><strong>UDP传输不提供复杂的控制机制，它利用IP提供面向无连接的通信服务</strong><ul><li><strong>优点：它的资源消耗小，传输速度快，通常音频，视频在传送时用UDP传输较多</strong></li><li><strong>缺点：UDP报文没有可靠性保证，顺序保证，和流量控制，可靠性比较差，传输过程中出现包丢失不会重发</strong></li></ul></li></ul><h2 id="6-4-TCP"><a href="#6-4-TCP" class="headerlink" title="6.4 TCP"></a>6.4 TCP</h2><ul><li><strong>TCP是一种面向有连接的传输协议</strong></li><li><strong>TCP充分实现数据传输过程中的各种控制，丢包可以重发，可以顺序控制</strong></li><li><strong>TCP首部格式如下：</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/112871/16/18291/156082/60d7da51E00164f2f/5a5ed30832180698.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h3 id="6-4-2-TCP怎么满足可靠性的？"><a href="#6-4-2-TCP怎么满足可靠性的？" class="headerlink" title="6.4.2 TCP怎么满足可靠性的？"></a>6.4.2 TCP怎么满足可靠性的？</h3><p><strong>发送数据后，接收端会返回确认应答的消息ACK。如果发送端没有收到ACK，则说明丢包了会重发</strong><br><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/191382/11/10403/62582/60d7d42fEb4682d07/74bec6fc7e9524fc.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><ul><li><strong>UDP是面向无连接，而TCP是面向有连接。</strong></li><li><strong>所以TCP在通信前，需要先建立两端的连接，即三次握手</strong></li><li><strong>通信后，需要断开连接，即四次挥手</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/177992/24/11421/88469/60d7e2edE463b6e41/da4baac2f7b299a7.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h2 id="说一下三次握手？（建立连接）"><a href="#说一下三次握手？（建立连接）" class="headerlink" title="说一下三次握手？（建立连接）"></a>说一下三次握手？（建立连接）</h2><ul><li><strong>第一次握手：客户端给服务端发送一个SYN包，假设syn=j，并进入SYN_SEND状态，等待服务端确认</strong></li><li><strong>第二次握手：服务端收到SYN包，发送ACK确认应答设置ack=j+1，同时自己也发送一个SYN包，假设syn=k，并进入SYN_RESV状态</strong></li><li><strong>第三次握手：客户端收到服务端的SYN+ACK包，向服务端发送ACK包确认应答ack=k+1，此包发送完毕双方连接完成</strong></li></ul><h2 id="说一下四次挥手？（终止连接）"><a href="#说一下四次挥手？（终止连接）" class="headerlink" title="说一下四次挥手？（终止连接）"></a>说一下四次挥手？（终止连接）</h2><ul><li><strong>第一次挥手：客户端发送一个FIN包给服务端，用来关闭客户端到服务端数据传送</strong></li><li><strong>第二次挥手：服务端收到这个FIN包，就发送一个ACK确认应答给客户端</strong></li><li><strong>第三次挥手：服务端关闭与客户端之间的连接，发送FIN包给客户端</strong></li><li><strong>第四次挥手：客户端收到后，发送一个ACK应答给服务端，此时连接断开</strong></li></ul><h3 id="为什么服务端的ACK和FIN包不能一起发？"><a href="#为什么服务端的ACK和FIN包不能一起发？" class="headerlink" title="为什么服务端的ACK和FIN包不能一起发？"></a>为什么服务端的ACK和FIN包不能一起发？</h3><ul><li><strong>服务器发送ACK后，可能还有数据没有处理完成，要等处理完成后才能发送FIN包</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《图解TCP/IP》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章 IP协议相关技术</title>
      <link href="/posts/837272352.html"/>
      <url>/posts/837272352.html</url>
      
        <content type="html"><![CDATA[<h2 id="5-2-DNS"><a href="#5-2-DNS" class="headerlink" title="5.2 DNS"></a>5.2 DNS</h2><p><strong>平时访问网站用IP地址很不方便，一般都是用主机名（域名）</strong><br><strong>为了实现用主机名（域名）替代IP地址的功能，主机会利用hosts数据文件，也就是DNS</strong></p><h3 id="DNS是怎么查询IP地址的？"><a href="#DNS是怎么查询IP地址的？" class="headerlink" title="DNS是怎么查询IP地址的？"></a>DNS是怎么查询IP地址的？</h3><ul><li><strong>首先向最近的DNS服务器查询IP地址，如果有就返回，没有就向根域名服务器查询</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/188784/3/10285/175846/60d5da27E70bb3d0c/788c7379b5553333.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><hr><h2 id="5-3-ARP"><a href="#5-3-ARP" class="headerlink" title="5.3 ARP"></a>5.3 ARP</h2><h3 id="5-3-1-ARP是什么？"><a href="#5-3-1-ARP是什么？" class="headerlink" title="5.3.1 ARP是什么？"></a>5.3.1 ARP是什么？</h3><ul><li><strong>在数据链路层中我们需要查找目标IP地址的MAC地址，可以通过广播发送一个ARP请求包，询问目标IP的MAC地址</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/182434/3/11078/83772/60d5dc4dE12cf50af/5306723c38908076.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li><li><strong>为了防止每发一次数据就要一次ARP请求，会将MAC地址和IP地址的映射关系缓存在主机中，即ARP缓存表</strong></li></ul><h3 id="5-3-3-IP地址和MAC地址为什么缺一不可？"><a href="#5-3-3-IP地址和MAC地址为什么缺一不可？" class="headerlink" title="5.3.3 IP地址和MAC地址为什么缺一不可？"></a>5.3.3 IP地址和MAC地址为什么缺一不可？</h3><ul><li><strong>首先在第4章 IP协议中的4.1.2说明了网络层和数据链路层为什么缺一不可</strong></li><li><strong>主机A和主机B如果不在同一个数据链路中，也就是不在同一个网段，主机A想要发送数据给主机B，必须要经过路由器。如果只知道主机A和主机B的MAC地址，主机A在自己的网段中找不到主机B的MAC，便会发送数据给路由器，但是这时候如果没有IP协议和ARP地址解析协议，是无法进行路由控制，获取路由器的MAC，这样主机A的数据就到达不了路由器，更到达不了主机B</strong></li></ul><h3 id="5-3-4-RARP"><a href="#5-3-4-RARP" class="headerlink" title="5.3.4 RARP"></a>5.3.4 RARP</h3><p><strong>和ARP相反，通过自己的MAC地址查询自己的IP地址</strong></p><hr><h2 id="5-4-ICMP"><a href="#5-4-ICMP" class="headerlink" title="5.4 ICMP"></a>5.4 ICMP</h2><h3 id="5-4-1-ICMP是什么？"><a href="#5-4-1-ICMP是什么？" class="headerlink" title="5.4.1 ICMP是什么？"></a>5.4.1 ICMP是什么？</h3><ul><li><strong>在IP通信中，如果因为某种原因没到目的地，那么目的地的路由器就会发一个ICMP包，包中有发生问题的原因</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/175355/24/16654/103299/60d6833bE555ce6c8/a123d6fbb4e5a9f4.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><hr><h2 id="5-5-DHCP"><a href="#5-5-DHCP" class="headerlink" title="5.5 DHCP"></a>5.5 DHCP</h2><p><strong>DHCP是用来自动分配IP地址的</strong></p><hr><h2 id="5-6-NAT"><a href="#5-6-NAT" class="headerlink" title="5.6 NAT"></a>5.6 NAT</h2><p><strong>NAT是用来对本地网络的私有IP地址和互联网的全局IP地址相互转换</strong></p>]]></content>
      
      
      <categories>
          
          <category> 《图解TCP/IP》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 IP协议</title>
      <link href="/posts/2555026619.html"/>
      <url>/posts/2555026619.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-1-IP相当于OSI模型的网络层"><a href="#4-1-1-IP相当于OSI模型的网络层" class="headerlink" title="4.1.1 IP相当于OSI模型的网络层"></a>4.1.1 IP相当于OSI模型的网络层</h2><p><strong>数据链路层中通过MAC地址来识别同一个链路中不同主机，而一旦跨越多种数据链路就要用到网络层，而IP地址就是用于网络层中区分不同的主机</strong></p><h2 id="4-1-2-网络层和数据链路层的关系"><a href="#4-1-2-网络层和数据链路层的关系" class="headerlink" title="4.1.2 网络层和数据链路层的关系"></a>4.1.2 网络层和数据链路层的关系</h2><ul><li><strong>比如用户A要去地点B旅行：</strong><ul><li><strong>数据链路层就相当于途中每一站的火车票，只能一个个区域移动</strong></li><li><strong>网络层相当于整个旅途的行程表，规划好从A要去B的路线</strong></li></ul></li><li><strong>所以数据链路层和网络层缺一不可，没有数据链路相当于没有车票就无法去往目的地，没有网络层就不知道每一站去哪</strong></li></ul><h2 id="4-2-2-路由控制"><a href="#4-2-2-路由控制" class="headerlink" title="4.2.2 路由控制"></a>4.2.2 路由控制</h2><ul><li><strong>首先是”跳”，指的是网络中的一个区间，即同一个数据链路</strong></li><li><strong>数据链路层负责一跳之间的传输，网络层中的路由控制即IP决定下一跳的路径，最终实现目标地址的通信</strong></li></ul><h3 id="路由控制表："><a href="#路由控制表：" class="headerlink" title="路由控制表："></a>路由控制表：</h3><p><strong>每个主机和路由器都维护一张路由控制表，记录各个网络和路由器的配对关系</strong></p><ul><li><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/174139/15/16121/138429/60d53bd3E1490cad1/223862e27edc29c9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul><h2 id="4-2-4-IP属于面向无连接，不需要建立连接即可发送"><a href="#4-2-4-IP属于面向无连接，不需要建立连接即可发送" class="headerlink" title="4.2.4 IP属于面向无连接，不需要建立连接即可发送"></a>4.2.4 IP属于面向无连接，不需要建立连接即可发送</h2><h2 id="4-3-IP地址的基础知识"><a href="#4-3-IP地址的基础知识" class="headerlink" title="4.3 IP地址的基础知识"></a>4.3 IP地址的基础知识</h2><h3 id="4-3-1-IP地址定义"><a href="#4-3-1-IP地址定义" class="headerlink" title="4.3.1 IP地址定义"></a>4.3.1 IP地址定义</h3><p><strong>IP地址是TCP/IP通信时候，用于识别主机和路由器的标识</strong><br><strong>IPV4由32位二进制组成，习惯表示为4个十进制的整数：192.168.1.1</strong></p><h3 id="4-3-2-IP地址由网络地址和主机地址组成"><a href="#4-3-2-IP地址由网络地址和主机地址组成" class="headerlink" title="4.3.2 IP地址由网络地址和主机地址组成"></a>4.3.2 IP地址由网络地址和主机地址组成</h3><p><strong>首先IP地址由网络地址和主机地址组成</strong><br><strong>为了判断网络地址，引入了子网掩码。将IP地址和子网掩码AND运算就可以得到网络地址</strong></p><h3 id="4-3-3-IP地址分类"><a href="#4-3-3-IP地址分类" class="headerlink" title="4.3.3 IP地址分类"></a>4.3.3 IP地址分类</h3><p><img "" class="lazyload placeholder" data-original="https://pic3.zhimg.com/v2-7438cb1ba454ffe278f5c2310e69f3aa_b.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="4-3-6-子网掩码"><a href="#4-3-6-子网掩码" class="headerlink" title="4.3.6 子网掩码"></a>4.3.6 子网掩码</h3><p><strong>子网掩码也是32位的二进制表示，他用1表示IP的网络地址位置，用0表示IP地址主机地址位置，比如C类IP地址子网掩码：11111111 11111111 11111111 00000000</strong></p><h2 id="4-4-路由控制"><a href="#4-4-路由控制" class="headerlink" title="4.4 路由控制"></a>4.4 路由控制</h2><ul><li><strong>每个路由器和主机都有一张路由控制表，记录网络地址和对应的路由器地址</strong></li><li><strong>发送IP数据包时，首先确定包首部的目标IP地址，从路由控制表中查找对应的路由器地址并发送给下一个路由器</strong><ul><li><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/196104/38/10116/123501/60d582ebEaf339829/f1689f2f210b8e8d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><h2 id="4-5-IP分片"><a href="#4-5-IP分片" class="headerlink" title="4.5 IP分片"></a>4.5 IP分片</h2><p><strong>不同数据链路则MTU就不同。MTU即最大传输单元</strong><br><strong>当IP数据报太大，MTU小，无法在一帧内传输，路由器就会将它分片，传输到主机后，再根据IP首部识别码重组</strong></p>]]></content>
      
      
      <categories>
          
          <category> 《图解TCP/IP》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 数据链路</title>
      <link href="/posts/165302757.html"/>
      <url>/posts/165302757.html</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-数据链路有什么用？"><a href="#3-1-数据链路有什么用？" class="headerlink" title="3.1 数据链路有什么用？"></a>3.1 数据链路有什么用？</h2><ul><li><strong>首先传输数据时，物理层和链路层必不可少</strong></li><li><strong>物理层是将电压、电波和二进制0、1进行转换，而数据链路层则把这些二进制集合为一个”帧”的数据块，再传输</strong></li></ul><h2 id="3-2-MAC地址"><a href="#3-2-MAC地址" class="headerlink" title="3.2 MAC地址"></a>3.2 MAC地址</h2><p><strong>每个网卡的MAC地址都是唯一的，用于识别数据链路中互连的节点</strong></p><h2 id="3-2-4-怎么根据MAC地址转发？"><a href="#3-2-4-怎么根据MAC地址转发？" class="headerlink" title="3.2.4 怎么根据MAC地址转发？"></a>3.2.4 怎么根据MAC地址转发？</h2><ul><li><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/192683/17/9895/275450/60d48d88E07e3eceb/d130143a31957709.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p></li><li><p><strong>交换机会记住MAC地址和对应的交换机上的端口号，即MAC地址表和ARP缓存表是不一样的</strong></p><h2 id="3-3-以太网"><a href="#3-3-以太网" class="headerlink" title="3.3 以太网"></a>3.3 以太网</h2><h3 id="以太网帧格式？"><a href="#以太网帧格式？" class="headerlink" title="以太网帧格式？"></a>以太网帧格式？</h3></li><li><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/176740/10/16716/51432/60d48f0cE509259e1/2fad6921e646f5dd.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>类型指的是协议的类型，FCS是用来检测帧是否损坏</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《图解TCP/IP》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 TCP/IP基础知识</title>
      <link href="/posts/4267583022.html"/>
      <url>/posts/4267583022.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-TCP-IP协议具体含义是什么？"><a href="#2-1-TCP-IP协议具体含义是什么？" class="headerlink" title="2.1 TCP/IP协议具体含义是什么？"></a>2.1 TCP/IP协议具体含义是什么？</h2><ul><li><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/179434/14/10976/69551/60d3d3ffE2223d64f/334cac42e28c9f85.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="2-4-TCP-IP分层模型？"><a href="#2-4-TCP-IP分层模型？" class="headerlink" title="2.4 TCP/IP分层模型？"></a>2.4 TCP/IP分层模型？</h2></li><li><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/130799/23/16984/172129/60d3dfe4E30425cc7/89d002a00de3ef48.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="2-5-TCP-IP模型通信实例"><a href="#2-5-TCP-IP模型通信实例" class="headerlink" title="2.5 TCP/IP模型通信实例"></a>2.5 TCP/IP模型通信实例</h2></li><li><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/169177/23/9325/394530/60d3e047Ef27e831c/eb22f13e3ecee896.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《图解TCP/IP》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 网络基础知识</title>
      <link href="/posts/3097388358.html"/>
      <url>/posts/3097388358.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-协议是什么？"><a href="#1-1-协议是什么？" class="headerlink" title="1.1 协议是什么？"></a>1.1 协议是什么？</h2><ul><li><strong>首先互联网代表协议TCP/IP，包括HTTP、TCP、IP等协议</strong></li><li><strong>两台计算机之间必须支持相同的协议，否则无法通信</strong></li></ul><h2 id="1-3-什么是分组通信（分组交换协议）？"><a href="#1-3-什么是分组通信（分组交换协议）？" class="headerlink" title="1.3 什么是分组通信（分组交换协议）？"></a>1.3 什么是分组通信（分组交换协议）？</h2><p><strong>将大数据分割为一个个叫包的较小单位进行传播，其中通信协议用于规定报文首部应该写入哪些信息、应该如何处理这些信息</strong></p><h2 id="1-4-协议由谁规定？"><a href="#1-4-协议由谁规定？" class="headerlink" title="1.4 协议由谁规定？"></a>1.4 协议由谁规定？</h2><p><strong>OSI模型由ISO定义，而TCP/IP模型由IETF规定</strong></p><h2 id="1-5-OSI参考模型"><a href="#1-5-OSI参考模型" class="headerlink" title="1.5 OSI参考模型"></a>1.5 OSI参考模型</h2><h3 id="OSI参考模型每一层的作用？"><a href="#OSI参考模型每一层的作用？" class="headerlink" title="OSI参考模型每一层的作用？"></a>OSI参考模型每一层的作用？</h3><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/177615/12/10754/88478/60d32fd1E7fc173f0/45e530292054a0a5.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="7层通信处理举例："><a href="#7层通信处理举例：" class="headerlink" title="7层通信处理举例："></a>7层通信处理举例：</h3><blockquote><p><strong>用户A给用户B发送”早上好”：</strong></p><ul><li><strong>第1步，输入完发送内容后点击发送那一刻，即进入应用层</strong><ul><li><strong>应用层将发送数据的前端添加一个首部，标明内容与收件人</strong></li></ul></li><li><strong>第2步，表示层：将”某个计算机特定的数据格式”转化为”统一的标准网络格式”</strong></li><li><strong>第3步，会话层：决定采用何种连接发送数据，例如发一封邮件就建立一次连接还是连发五封邮件，甚至建立五个连接</strong></li><li><strong>第4步，传输层：建立连接或断开连接或重发，例如用户B没有收到完整的”早上好”，告知用户A，则会重发未收到的内容，并再次确认</strong></li><li><strong>第5步，网络层与数据链路层：数据链路层负责每个区间的通信，网络层将数据发送给最终目标（端对端）</strong><ul><li><strong>数据链路层将数据0、1转化为电压和脉冲光传输给物理介质，通过物理介质实现通信传输</strong></li><li><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/192330/34/9724/101153/60d2e8d6E196f29f0/545697238fd8fd15.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li><li><strong>第6步，用户B接收，与用户A相反，从物理层开始往上逐层处理</strong><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/182094/37/10771/156623/60d2e983E2d6aeaa3/dfe43cdcdfb0afd5.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></li></ul></li></ul></blockquote><hr><h2 id="1-7-传输方式分类"><a href="#1-7-传输方式分类" class="headerlink" title="1.7 传输方式分类"></a>1.7 传输方式分类</h2><h3 id="1-7-1-面向有连接与面向无连接"><a href="#1-7-1-面向有连接与面向无连接" class="headerlink" title="1.7.1 面向有连接与面向无连接"></a>1.7.1 面向有连接与面向无连接</h3><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/180716/23/10735/168022/60d2eafbEb229cd7c/03036bb435a13b3b.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>面向有连接型：在发送数据之前，需要在收发主机之间建立一条通信线路。在通信传输前后，专门进行建立和断开连接的处理，可以避免发送无谓的数据</strong></li><li><strong>面向无连接型：发送数据时候不需要建立连接，发送端可以在任何时候自由发送数据，即使接收端不存在，发送端也可以将数据发送出去</strong></li></ul><h3 id="1-7-2-电路交换与分组交换"><a href="#1-7-2-电路交换与分组交换" class="headerlink" title="1.7.2 电路交换与分组交换"></a>1.7.2 电路交换与分组交换</h3><ul><li><strong>电路交换：两台计算机通过独占电路完成信息交换，一次最多只能两个用户同时通信</strong></li><li><strong>分组交换：路由器之间通过一条/多条共享线路相连，发送端计算机将数据分组发送给路由器，路由器收到这些分组数据以后，缓存到自己的缓冲区，然后再以先进先出的顺序转发给目标计算机（TCP/IP用的分组交换）</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/171999/3/16497/156446/60d326baE0caeb759/cfd772a646dfb68f.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h4 id="分组交换和电路交换的特点："><a href="#分组交换和电路交换的特点：" class="headerlink" title="分组交换和电路交换的特点："></a>分组交换和电路交换的特点：</h4><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/174188/39/16437/235381/60d3272bE3054b37c/a07c189c70f7d6d7.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="1-9-网络构成要素"><a href="#1-9-网络构成要素" class="headerlink" title="1.9 网络构成要素"></a>1.9 网络构成要素</h2><h3 id="1-9-2-网卡"><a href="#1-9-2-网卡" class="headerlink" title="1.9.2 网卡"></a>1.9.2 网卡</h3><ul><li><strong>将电脑的数据封装为帧，并通过网线（无线网络是电磁波）将数据发送到网络上</strong></li><li><strong>接收网络其他设备发送的帧，将帧重新组合成数据，发送到所在的电脑中</strong></li></ul><h3 id="1-9-3-中继器"><a href="#1-9-3-中继器" class="headerlink" title="1.9.3 中继器"></a>1.9.3 中继器</h3><p><strong>OSI模型的物理层，延长网络距离的设备，将电缆传过来的衰减的信号放大传给另一个电缆，延长网络长度</strong></p><h3 id="1-9-4-网桥-2层交换机"><a href="#1-9-4-网桥-2层交换机" class="headerlink" title="1.9.4 网桥/2层交换机"></a>1.9.4 网桥/2层交换机</h3><p><strong>OSI模型的数据链路层，能识别数据包中的MAC地址，根据MAC地址转发</strong></p><h3 id="1-9-5-路由器-3层交换机"><a href="#1-9-5-路由器-3层交换机" class="headerlink" title="1.9.5 路由器/3层交换机"></a>1.9.5 路由器/3层交换机</h3><p><strong>OSI模型的网络层，根据IP地址处理数据</strong></p><h3 id="1-9-7-网关"><a href="#1-9-7-网关" class="headerlink" title="1.9.7 网关"></a>1.9.7 网关</h3><p><strong>负责协议的转换和数据的转发</strong><br><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/172527/11/16785/89243/60d32e77Eaf128ea1/ec74714d1ab1421b.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p>]]></content>
      
      
      <categories>
          
          <category> 《图解TCP/IP》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器是怎样通信的</title>
      <link href="/posts/2853482812.html"/>
      <url>/posts/2853482812.html</url>
      
        <content type="html"><![CDATA[<h2 id="第1步，从在浏览器中输入网址开始："><a href="#第1步，从在浏览器中输入网址开始：" class="headerlink" title="第1步，从在浏览器中输入网址开始："></a>第1步，从在浏览器中输入网址开始：</h2><ul><li><strong>首先网址就是URL，通常是访问web服务器，用”http:”，即HTTP协议</strong></li><li><strong>URL的格式会随着协议的不同而不同</strong></li><li><strong>URL的各种格式如下：</strong><ul><li><strong>访问Web服务器或FTP服务器时，URL包括域名和文件路径名，有时还会包含用户名和密码和服务器端口号</strong></li></ul></li></ul><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/192120/18/9188/187284/60cd994bE12331888/5d15ca108f2daa5f.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="第2步，浏览器对URL进行解析"><a href="#第2步，浏览器对URL进行解析" class="headerlink" title="第2步，浏览器对URL进行解析"></a>第2步，浏览器对URL进行解析</h2><p><strong>对URL解析也就是对URL进行拆分，拆分结果如下：</strong><br><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/25315/31/13123/231182/60cd9d42E76517b5c/4415e5064467809d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>还有URL中省略文件名的特殊情况，甚至最后不以/结尾，将会直接访问服务器中设置的默认文件</strong></li></ul><h2 id="第3步，根据解析信息来生成HTTP请求消息"><a href="#第3步，根据解析信息来生成HTTP请求消息" class="headerlink" title="第3步，根据解析信息来生成HTTP请求消息"></a>第3步，根据解析信息来生成HTTP请求消息</h2><p><strong>HTTP方法最常用的就是GET和POST：</strong></p><ul><li><strong>在地址栏中输入网址并显示网页，因此这里应该使用 GET 方法</strong></li><li><strong>点击超级链接的场景中也是使用 GET 方法</strong></li><li><strong>如果是表单，在 HTML 源代码中会在表单的属性中指定使用哪种方法来发送请求，可能是 GET也可能是POST</strong></li></ul><h3 id="生成HTTP请求消息的格式："><a href="#生成HTTP请求消息的格式：" class="headerlink" title="生成HTTP请求消息的格式："></a>生成HTTP请求消息的格式：</h3><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/194117/1/9057/110909/60cdad3dEb4f176eb/1baee7cd88773d39.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="怎么生成HTTP请求消息："><a href="#怎么生成HTTP请求消息：" class="headerlink" title="怎么生成HTTP请求消息："></a>怎么生成HTTP请求消息：</h3><ul><li><strong>第1步，写好方法，是GET还是POST，加一个空格</strong></li><li><strong>第2步，写URI，即文件和程序的路径名，直接从URL中提取出来即可，再加一个空格，写HTTP版本</strong></li><li><strong>第3步，第二行开始写消息头，存放请求的额外信息，如日期，客户端支持的数据类型，软件名称和版本等等</strong></li><li><strong>第4步，空一行，写消息体。GET方法不需要写消息体，POST方法把表单中的信息写上</strong></li></ul><h3 id="生成结果如下："><a href="#生成结果如下：" class="headerlink" title="生成结果如下："></a>生成结果如下：</h3><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/177642/23/10196/223242/60cdafceEe9e56c53/4d1133388c4b3978.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="第4步，生成请求消息后，向DNS服务器查询Web服务器的IP地址"><a href="#第4步，生成请求消息后，向DNS服务器查询Web服务器的IP地址" class="headerlink" title="第4步，生成请求消息后，向DNS服务器查询Web服务器的IP地址"></a>第4步，生成请求消息后，向DNS服务器查询Web服务器的IP地址</h2><p><strong>虽然浏览器能生成解析地址生成HTTP请求消息，但是浏览器不能发送消息到网络，需要委托操作系统来做</strong></p><h3 id="IP地址原理"><a href="#IP地址原理" class="headerlink" title="IP地址原理"></a>IP地址原理</h3><h4 id="子网："><a href="#子网：" class="headerlink" title="子网："></a>子网：</h4><p><strong>由集线器连接起来几台计算机，看成一个单位</strong></p><h4 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h4><p><strong>把子网用路由器连起来形成网络</strong></p><h4 id="IP地址："><a href="#IP地址：" class="headerlink" title="IP地址："></a>IP地址：</h4><ul><li><strong>网络中所有的设备都被分配一个地址，由网络号、主机号组成</strong></li><li><strong>通过IP地址可以判断出访问服务器的位置，从而发送消息</strong></li></ul><h4 id="消息发送过程："><a href="#消息发送过程：" class="headerlink" title="消息发送过程："></a>消息发送过程：</h4><p><strong>发送者的消息先通过子网的集线器发送到最近的路由器上，路由器根据目的地判断并发送到下一个路由器，然后再经过子网的集线器发到下一个路由器，直到发送到目的地</strong></p><h3 id="为什么要查询IP地址？"><a href="#为什么要查询IP地址？" class="headerlink" title="为什么要查询IP地址？"></a>为什么要查询IP地址？</h3><p><strong>因为发送消息需要的不是域名，而是域名对应的IP地址</strong></p><h3 id="怎么向DNS服务器查询IP地址？"><a href="#怎么向DNS服务器查询IP地址？" class="headerlink" title="怎么向DNS服务器查询IP地址？"></a>怎么向DNS服务器查询IP地址？</h3><ul><li><strong>首先操作系统上有DNS客户端，客户端里有Socket库的DNS解析器</strong></li><li><strong>需要查询IP地址时</strong><ul><li><strong>第1步，浏览器会调用操作系统的解析器，解析器委托操作系统的协议栈通过网卡向DNS服务器发送查询消息，然后DNS会返回响应消息</strong></li><li><strong>第2步，响应消息通过协议栈传递给解析器，解析器会取出响应消息中的IP地址，并写入浏览器指定的内存地址中</strong></li></ul></li><li><strong>解析器程序如下：</strong></li></ul><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/180986/16/10049/89745/60cde338Ef32162ea/4a45757e8b9b22c9.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="第5步，委托操作系统的协议栈向目标IP服务器收发HTTP消息"><a href="#第5步，委托操作系统的协议栈向目标IP服务器收发HTTP消息" class="headerlink" title="第5步，委托操作系统的协议栈向目标IP服务器收发HTTP消息"></a>第5步，委托操作系统的协议栈向目标IP服务器收发HTTP消息</h2><h3 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h3><ul><li><strong>首先收发消息操作之前，先要建立一条管道连接双方。管道两端的数据出入口叫套接字，所以先创建套接字</strong></li><li><strong>然后通过套接字连接起来形成管道</strong></li><li><strong>这些步骤都是委托协议栈完成的</strong></li></ul><h3 id="第1步，收发消息的准备工作："><a href="#第1步，收发消息的准备工作：" class="headerlink" title="第1步，收发消息的准备工作："></a>第1步，收发消息的准备工作：</h3><ul><li><strong>首先服务器创建套接字，等待客户端创建套接字并返回描述符</strong></li><li><strong>协议栈根据描述符、IP地址、端口号判断哪个套接字和哪个服务器的哪个套接字进行连接管道，连接后就完成了准备工作</strong><ul><li><strong>原理：描述符是用来在一台计算机内部识别套接字的，端口号就是用来识别服务器的套接字的</strong></li></ul></li><li><strong>传输完成后任何一方断开管道，通信就结束，套接字将删除</strong></li></ul><h3 id="第2步，收发HTTP消息"><a href="#第2步，收发HTTP消息" class="headerlink" title="第2步，收发HTTP消息"></a>第2步，收发HTTP消息</h3><ul><li><strong>发送消息：调用write程序组件并指定套接字和HTTP消息（需要发送的数据），协议栈就会发送数据到服务器</strong></li><li><strong>服务器响应消息：</strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/185016/29/10128/91496/60ce01bdEb0e8d8d3/624e0fc6f36db344.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li><li><strong>接收消息：调用read程序组件并指定消息存放内存地址，协议栈就会接收数据到接收缓冲区</strong></li></ul><h3 id="第3步，断开连接"><a href="#第3步，断开连接" class="headerlink" title="第3步，断开连接"></a>第3步，断开连接</h3><p><strong>服务器首先断开连接，传达到客户端后，客户端套接字也会断开，浏览器调用read后会得知通信结束，浏览器也会断开</strong></p>]]></content>
      
      
      <categories>
          
          <category> 《网络是怎样连接的》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第17章 集合深入研究</title>
      <link href="/posts/1634000993.html"/>
      <url>/posts/1634000993.html</url>
      
        <content type="html"><![CDATA[<h2 id="17-1-完整的集合分类"><a href="#17-1-完整的集合分类" class="headerlink" title="17.1 完整的集合分类"></a>17.1 完整的集合分类</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/185403/25/9715/152618/60cc4962E674c638f/44f842c2660115cc.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h2><blockquote><ul><li><strong>ArrayList是一种集合类，其底层基于数组实现，所以查找操作可在O(1)的时间范围内实现</strong></li><li><strong>ArrayList允许空值和重复元素</strong></li><li><strong>当向ArrayList中添加的元素数量大于其底层数组容量时，其会通过扩容机制生成一个新的数组</strong></li></ul></blockquote><h3 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">        <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">        <span class="comment">//创建空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">    *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器总结："><a href="#构造器总结：" class="headerlink" title="构造器总结："></a>构造器总结：</h4><blockquote><ul><li><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></li><li><strong>JDK7 new无参构造的ArrayList对象时，直接创建了长度是10的Object[]数组elementData 。jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式。</strong></li></ul></blockquote><h3 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a><strong>ArrayList扩容机制</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩充机制总结："><a href="#扩充机制总结：" class="headerlink" title="扩充机制总结："></a>扩充机制总结：</h4><p><strong><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>，所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</strong></p><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在元素序列尾部插入 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检测是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2. 将新元素插入序列尾部</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 在元素序列 index 位置处插入 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检测是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 2. 将 index 及其之后的所有元素都向后移一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 3. 将新元素插入至 index 处</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入元素总结："><a href="#插入元素总结：" class="headerlink" title="插入元素总结："></a>插入元素总结：</h4><blockquote><p><strong>对于在元素序列尾部插入，这种情况比较简单，只需两个步骤即可：</strong></p><ul><li><strong>检测数组是否有足够的空间插入</strong></li><li><strong>将新元素插入至序列尾部</strong></li></ul></blockquote><p><strong>如果是在元素序列指定位置（假设该位置合理）插入，则情况稍微复杂一点，需要三个步骤：</strong></p><blockquote><ul><li><strong>检测数组是否有足够的空间</strong></li><li><strong>将 index 及其之后的所有元素向后移一位</strong></li><li><strong>将新元素插入至 index 处</strong></li></ul></blockquote><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 删除指定位置的元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 返回被删除的元素值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将 index + 1 及之后的元素向前移动一位，覆盖被删除值</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 将最后一个元素置空，并将 size 值减1                </span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 删除指定元素，若元素重复，则只删除下标最小的元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历数组，查找要删除元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 快速删除，不做边界检查，也不返回删除的元素值 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素总结："><a href="#删除元素总结：" class="headerlink" title="删除元素总结："></a>删除元素总结：</h4><blockquote><p><strong>以第一个删除方法为例，删除一个元素步骤如下：</strong></p><ul><li><strong>获取指定位置 index 处的元素值</strong></li><li><strong>将 index + 1 及之后的元素向前移动一位</strong></li><li><strong>将最后一个元素置空，并将 size 值减 1</strong></li><li><strong>返回被删除值，完成删除操作</strong></li></ul></blockquote><hr><h2 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h2><blockquote><ul><li><strong>LinkedList是一个实现了List接口和Deque接口的双端链表</strong></li><li><strong>LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性; LinkedList不是线程安全的。和 ArrayList 一样，LinkedList 也支持空值和重复值。</strong></li><li><strong>由于 LinkedList 基于链表实现，存储元素过程中，无需像 ArrayList 那样进行扩容。但有得必有失，LinkedList 存储元素的节点需要额外的空间存储前驱和后继的引用。</strong></li></ul></blockquote><h3 id="查找元素："><a href="#查找元素：" class="headerlink" title="查找元素："></a>查找元素：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 则从头节点开始查找，否则从尾节点查找</span></span><br><span class="line"><span class="comment">     * 查找位置 index 如果小于节点数量的一半，</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">// 循环向后查找，直至 i == index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找元素总结："><a href="#查找元素总结：" class="headerlink" title="查找元素总结："></a>查找元素总结：</h4><blockquote><ul><li><strong>如果查找位置小于节点数的一半，则从头节点开始找</strong></li><li><strong>如果查找位置大于等于节点数一半，则从尾节点向前找</strong></li></ul></blockquote><h3 id="插入元素："><a href="#插入元素：" class="headerlink" title="插入元素："></a>插入元素：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在链表尾部插入元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 在链表指定位置插入元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 判断 index 是不是链表尾部位置，如果是，直接将元素节点插入链表尾部即可</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将元素节点插入到链表尾部 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 将 last 引用指向新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空，为空表示当前链表还没有节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;    <span class="comment">// 让原尾节点后继引用 next 指向新的尾节点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将元素节点插入到 succ 之前的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 1. 初始化节点，并指明前驱和后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// 2. 将 succ 节点前驱引用 prev 指向新节点</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空，为空表示当前链表还没有节点    </span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;   <span class="comment">// 3. succ 节点前驱的后继引用指向新节点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入元素总结：-1"><a href="#插入元素总结：-1" class="headerlink" title="插入元素总结："></a>插入元素总结：</h4><blockquote><ul><li><strong>LinkedList分别有两个指针指向两端，两端均可插入元素</strong></li><li><strong>一开始创建链表时前后指针指向都是空的。只有插入第一个元素后，前后指针才有指向</strong></li></ul></blockquote><h3 id="删除元素："><a href="#删除元素：" class="headerlink" title="删除元素："></a>删除元素：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历链表，找到要删除的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);    <span class="comment">// 将节点从链表中移除</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 通过 node 方法定位节点，并调用 unlink 将节点从链表中移除</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 将某个节点从链表中移除 */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prev 为空，表明删除的是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将 x 的前驱的后继指向 x 的后继</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 将 x 的前驱引用置空，断开与前驱的链接</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next 为空，表明删除的是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将 x 的后继的前驱指向 x 的前驱</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 将 x 的后继引用置空，断开与后继的链接</span></span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 item 置空，方便 GC 回收</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除元素总结：-1"><a href="#删除元素总结：-1" class="headerlink" title="删除元素总结："></a>删除元素总结：</h4><blockquote><p><strong>删除元素步骤如下：</strong></p><ol><li><strong>将待删除节点 x 的前驱的后继指向 x 的后继</strong></li><li><strong>将待删除节点 x 的前驱引用置空，断开与前驱的链接</strong></li><li><strong>将待删除节点 x 的后继的前驱指向 x 的前驱</strong></li><li><strong>将待删除节点 x 的后继引用置空，断开与后继的链接</strong></li></ol></blockquote><hr><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote><p><strong>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</strong><br><strong>JDK1.8 之后 HashMap 的组成多了红黑树，在满足下面两个条件之后，会执行链表转红黑树操作，用来加快搜索速度</strong></p></blockquote><blockquote><ul><li><strong>链表长度大于阈值（默认为 8）</strong></li><li><strong>HashMap 数组长度超过 64</strong></li></ul></blockquote><ul><li><strong>源码分析还需后期深入研究…</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第15章 泛型</title>
      <link href="/posts/1779638846.html"/>
      <url>/posts/1779638846.html</url>
      
        <content type="html"><![CDATA[<h2 id="15-2-简单泛型"><a href="#15-2-简单泛型" class="headerlink" title="15.2 简单泛型"></a>15.2 简单泛型</h2><p><strong>在没有泛型之前，采用的是继承机制来实现泛型，但是需要强制类型转换，会有风险</strong></p><h3 id="创建泛型类："><a href="#创建泛型类：" class="headerlink" title="创建泛型类："></a>创建泛型类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">T ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建泛型对象</span></span><br><span class="line">A&lt;..&gt; a = <span class="keyword">new</span> A&lt;&gt;();</span><br></pre></td></tr></table></figure><hr><h3 id="15-2-1-使用泛型创建多维元祖，实现一次调用返回多个对象"><a href="#15-2-1-使用泛型创建多维元祖，实现一次调用返回多个对象" class="headerlink" title="15.2.1 使用泛型创建多维元祖，实现一次调用返回多个对象"></a>15.2.1 使用泛型创建多维元祖，实现一次调用返回多个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>,...&gt;</span>&#123;<span class="comment">//A,B,C是泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> A first;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B second; <span class="comment">// 使用final使得客户端程序员无法修改，相当于private+getset方法</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(A a,B b)</span></span>&#123;first = a;second = b;&#125; <span class="comment">//构造器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="15-3-泛型接口"><a href="#15-3-泛型接口" class="headerlink" title="15.3 泛型接口"></a>15.3 泛型接口</h2><p><strong><code>public interface Generator&lt;T&gt; &#123;T next();&#125;</code></strong></p><h3 id="实现接口："><a href="#实现接口：" class="headerlink" title="实现接口："></a>实现接口：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Integer</span>&gt;</span>&#123; <span class="comment">//指定泛型T具体类型，可以是包装类数据类型也可以是自定义类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span></span>&#123; <span class="comment">// 重写接口中的方法</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-4-泛型方法"><a href="#15-4-泛型方法" class="headerlink" title="15.4 泛型方法"></a>15.4 泛型方法</h2><h3 id="为什么要用泛型方法？"><a href="#为什么要用泛型方法？" class="headerlink" title="为什么要用泛型方法？"></a>为什么要用泛型方法？</h3><ul><li><strong>因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活</strong></li><li><strong>使用泛型类，创建对象时必须指定泛型具体类型；而使用泛型方法，则不必指定，编译器会根据参数自动判断</strong></li></ul><h3 id="泛型方法定义"><a href="#泛型方法定义" class="headerlink" title="泛型方法定义"></a>泛型方法定义</h3><p><strong>泛型参数列表必须置于返回值之前前，泛型方法的类可以是泛型类也可以不是</strong></p><blockquote><ul><li><strong><code>public &lt;T&gt; void f(T x)&#123;...&#125;</code></strong></li><li><strong><code>public &lt;T,E&gt; E f(T a, E b) &#123;...&#125;</code></strong></li><li><strong><code>public  static &lt;T&gt; T f(T a)&#123;&#125;</code>  //泛型静态方法定义</strong></li></ul></blockquote><p><strong>显式指定类型调用泛型方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T x)</span></span>&#123;<span class="comment">//泛型方法</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">staticfun</span><span class="params">(T x)</span></span>&#123; <span class="comment">//静态泛型方法</span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> main&#123;</span><br><span class="line">    A&lt;Integer&gt; a = <span class="keyword">new</span> A&lt;&gt;();</span><br><span class="line">        a.&lt;String&gt;fun(<span class="string">&quot;abc&quot;</span>); <span class="comment">//指定泛型具体类型调用泛型方法</span></span><br><span class="line">        A.&lt;String&gt;staticfun(<span class="string">&quot;abc&quot;</span>); <span class="comment">//指定泛型具体类型调用静态泛型方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="15-7-擦除"><a href="#15-7-擦除" class="headerlink" title="15.7 擦除"></a>15.7 擦除</h2><h3 id="什么是擦除："><a href="#什么是擦除：" class="headerlink" title="什么是擦除："></a>什么是擦除：</h3><ul><li><p><strong>泛型具体类型不同擦除后会变成原生类 如List<String> 和List<Integer>是一种类型，最后都会擦除成List</strong></p></li><li><p><strong>泛型只是用来检查类型正确性，一旦运行就会被擦除</strong></p><h3 id="擦除的结果："><a href="#擦除的结果：" class="headerlink" title="擦除的结果："></a>擦除的结果：</h3></li><li><p><strong><code>List&lt;T&gt;</code>被擦除为<code>List</code>  、  <code>List&lt;String&gt;</code>被擦除为<code>List&lt;Object&gt;</code></strong></p></li><li><p><strong><code>&lt;T extends  A&gt;</code>擦除为<code>&lt;A&gt;</code></strong></p></li></ul><h3 id="什么是边界："><a href="#什么是边界：" class="headerlink" title="什么是边界："></a>什么是边界：</h3><ul><li><strong>运行后泛型会被擦除到上边界</strong></li><li><strong><code>class A&lt;T extends B&gt;</code>擦除到<code>&lt;B&gt;</code></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第14章 反射</title>
      <link href="/posts/2803025449.html"/>
      <url>/posts/2803025449.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p><strong>反射是在运行时动态访问类和对象的技术</strong></p><h2 id="为什么要用反射？"><a href="#为什么要用反射？" class="headerlink" title="为什么要用反射？"></a>为什么要用反射？</h2><blockquote><ul><li><strong>实例化对象用new关键字，但是这样就把实例化的工作固定在程序中，不灵活会出现各种问题。</strong></li><li><strong>反射可以将创建对象的时机从编译时延迟到程序运行时</strong></li><li><strong>当添加新的功能时，如果不用反射将需要修改代码，修改完需要重新上线非常麻烦，而用反射则没有这个问题</strong></li></ul></blockquote><h2 id="14-2-Class对象"><a href="#14-2-Class对象" class="headerlink" title="14.2 Class对象"></a>14.2 Class对象</h2><blockquote><p><strong>在程序运行时，Class对象保存了类和对象的具体信息。</strong><br><strong>每个类都有一个Class对象，每当编译一个类，即.java编译成.class文件，就会产生一个Class对象保存在.class文件中</strong></p></blockquote><h2 id="类加载器："><a href="#类加载器：" class="headerlink" title="类加载器："></a>类加载器：</h2><blockquote><p><strong>java程序在运行之前并非完全加载：</strong></p><ul><li><strong>第一次使用这个类，就动态加载到JVM中。当创建第一个对类的静态成员的引用或者构造器时就会加载这个类</strong></li></ul></blockquote><blockquote><p><strong>类加载器工作步骤：</strong></p><ol><li><strong>首先检查一个类的Class对象（或理解.class文件）是否已被加载</strong></li><li><strong>如果尚未加载，默认的类加载器就会根据类名查找.class文件</strong></li><li><strong>一旦Class对象（.class文件）被加载了（载入jvm），它就被用来创建这个类的所有对象</strong></li></ol></blockquote><h3 id="获取Class对象的引用"><a href="#获取Class对象的引用" class="headerlink" title="获取Class对象的引用"></a>获取Class对象的引用</h3><blockquote><p><code>**Class对象 = Class.forName(&quot;...&quot; )**</code><strong>可以返回指定Class对象的引用，并且若指定的类没有被加载，就加载它</strong><br><strong>如果没有Class对象，可以用forName获取。如果已经有一个Class对象，则可以用<code>getClass（)</code> 方法获取Class引用</strong></p></blockquote><hr><h2 id="Class常用方法"><a href="#Class常用方法" class="headerlink" title="Class常用方法"></a>Class常用方法</h2><blockquote><ul><li><strong>Class.forName(“Class path”)           获取指定Class对象</strong></li><li>**Class对象.newInstance()                  使用默认构造器构造对象 **</li><li><strong>Class对象.getConstructor()              获取指定的 public修饰构造方法 Constructor对象</strong></li><li><strong>Class对象.getMethod()                    获取指定的 public修饰方法 Method对象</strong></li><li><strong>Class对象.getField()                        获取指定的 public修饰成员变量 Field对象</strong></li></ul></blockquote><h2 id="使用带参构造方法创建对象（反射）"><a href="#使用带参构造方法创建对象（反射）" class="headerlink" title="使用带参构造方法创建对象（反射）"></a>使用带参构造方法创建对象（反射）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="class"><span class="keyword">class</span>对象 </span>= Class.forName(<span class="string">&quot; Class路径 &quot;</span>);</span><br><span class="line">Constructor constructor = <span class="class"><span class="keyword">class</span>对象.<span class="title">getConstructor</span>(<span class="title">new</span> <span class="title">Class</span>[]</span>&#123; <span class="comment">//通过构造器的参数获取构造器对象</span></span><br><span class="line"><span class="comment">//带参构造器的参数</span></span><br><span class="line">    String.class , Float.class,...</span><br><span class="line">&#125;);</span><br><span class="line">E 类的对象 = (E) constructor.newInstance(<span class="keyword">new</span> Object[]&#123; <span class="comment">//通过构造器对象</span></span><br><span class="line">    <span class="comment">//传递参数给带参构造器</span></span><br><span class="line">    <span class="string">&quot;...&quot;</span>,...,<span class="string">&quot;...&quot;</span>,...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="使用反射调用方法"><a href="#使用反射调用方法" class="headerlink" title="使用反射调用方法"></a>使用反射调用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="class"><span class="keyword">class</span>对象 </span>= Class.forName(<span class="string">&quot; Class路径 &quot;</span>);</span><br><span class="line">Method method = <span class="class"><span class="keyword">class</span>对象.<span class="title">getMethod</span>(&quot;方法名&quot;,<span class="title">new</span> <span class="title">Class</span>[]</span>&#123;</span><br><span class="line"><span class="comment">//构造器的参数</span></span><br><span class="line">    String.class , Float.class,...</span><br><span class="line">&#125;); <span class="comment">//通过方法名和方法的参数获取方法并返回方法对象</span></span><br><span class="line">method.invoke(类的对象,参数...);<span class="comment">//通过哪个类的对象调用这个方法以及方法参数来执行方法</span></span><br></pre></td></tr></table></figure><h2 id="使用反射获取成员对象"><a href="#使用反射获取成员对象" class="headerlink" title="使用反射获取成员对象"></a>使用反射获取成员对象</h2><p><strong>获取到成员对象后可以通过get或者set获取数据或修改数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="class"><span class="keyword">class</span>对象 </span>= Class.forName(<span class="string">&quot; Class路径 &quot;</span>);</span><br><span class="line">Field field = <span class="class"><span class="keyword">class</span>对象.<span class="title">getField</span>(&quot;成员对象名&quot;)</span>; <span class="comment">// 通过变量名获取成员对象</span></span><br><span class="line">print(field.get(类的对象)); <span class="comment">// 通过哪个类的对象获取变量</span></span><br><span class="line">field.set(类的对象,需要修改的值); <span class="comment">//修改变量</span></span><br></pre></td></tr></table></figure><p><strong>如果要获取非public则都采用getDeclaredXXX</strong></p>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第13章 字符串</title>
      <link href="/posts/4270824288.html"/>
      <url>/posts/4270824288.html</url>
      
        <content type="html"><![CDATA[<h2 id="13-1-不可变String"><a href="#13-1-不可变String" class="headerlink" title="13.1 不可变String"></a>13.1 不可变String</h2><p><strong>String类中修改String的方法都是创建新的String，最初的String不变</strong></p><h2 id="13-2-String中’-’-和StringBuilder"><a href="#13-2-String中’-’-和StringBuilder" class="headerlink" title="13.2 String中’+’ 和StringBuilder"></a>13.2 String中’+’ 和StringBuilder</h2><p><strong>String中的 ‘+’ 每次编译器会自动优化创建一个StringBuilder对象，使用其append（）方法。</strong></p><blockquote><p><strong>‘+’ 和StringBuilder使用场景：</strong></p><ul><li><strong>若对字符串操作比较简单，可以用 ‘+’ ，信赖编译器自动优化</strong></li><li><strong>若需要用循环对字符串进行操作，最好自己创建StringBuilder对象</strong></li></ul></blockquote><h3 id="StringBuilder常用方法"><a href="#StringBuilder常用方法" class="headerlink" title="StringBuilder常用方法"></a>StringBuilder常用方法</h3><blockquote><ul><li><strong>Stringbuilder insert(int offset , String s/char c)          在位置之前插入String或char</strong></li><li><strong>Stringbuilder append(String s)                                  字符串拼接</strong></li><li><strong>Stringbuilder replace(int start , int end , String s)       替换[ , ) 字符串</strong></li><li><strong>Stringbuilder delete(int start , int end)                       删除[ , ) 字符串</strong></li><li><strong>String toString()                                                      返回字符串</strong></li></ul></blockquote><h2 id="13-4-String常用方法"><a href="#13-4-String常用方法" class="headerlink" title="13.4 String常用方法"></a>13.4 String常用方法</h2><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/181445/2/9464/261049/60c94bfdE276da18f/707e4518ef45b22c.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第12章 异常</title>
      <link href="/posts/385034469.html"/>
      <url>/posts/385034469.html</url>
      
        <content type="html"><![CDATA[<h2 id="异常类型："><a href="#异常类型：" class="headerlink" title="异常类型："></a>异常类型：</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/193416/23/8345/103204/60c85e4cEf4c28547/920bb04309c42c67.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="12-4-创建自定义异常"><a href="#12-4-创建自定义异常" class="headerlink" title="12.4 创建自定义异常"></a>12.4 创建自定义异常</h2><blockquote><p><strong>创建自定义异常类并继承Throwable类或其子类</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">newException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">newException</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//无参构造器 会自动产生最方便</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">newException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-6-printStackTrace-："><a href="#12-6-printStackTrace-：" class="headerlink" title="12.6 printStackTrace()："></a>12.6 printStackTrace()：</h2><blockquote><p><strong>将打印“从方法调用处直到异常抛出处”的方法调用序列</strong><br><strong>printStackTrace（）信息可由getStackTrace（）直接访问</strong></p><ul><li><strong>返回一个栈数组，栈顶是最后一个调用的方法，栈底是第一个调用的方法</strong></li></ul></blockquote><h3 id="12-6-3-异常链"><a href="#12-6-3-异常链" class="headerlink" title="12.6.3 异常链"></a>12.6.3 异常链</h3><blockquote><p><strong>在捕获一个异常后抛出另一个异常，把原始异常信息保存起来，为异常链</strong><br><strong>异常链写法：</strong></p><ol><li><strong>将catch到的异常对象作为cause参数放入构造器传递给下一个异常</strong></li><li><strong>创建异常对象实例化后用initCause（原始异常对象）</strong></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testOne</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;第一个异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">testOne();</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;第二个异常&quot;</span>,e);</span><br><span class="line">        <span class="comment">/*    写法二：</span></span><br><span class="line"><span class="comment">        Exception e1 = new IOException(&quot;第二个异常&quot;);</span></span><br><span class="line"><span class="comment">        e1.initCause(e);</span></span><br><span class="line"><span class="comment">        throw e1;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">testTwo();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="12-8-finally"><a href="#12-8-finally" class="headerlink" title="12.8 finally"></a>12.8 finally</h2><p><strong>除了System.exit(1)以外，其他任何情况都会执行finally，甚至跳过break，continue，return等语句。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第11章 集合</title>
      <link href="/posts/2144629978.html"/>
      <url>/posts/2144629978.html</url>
      
        <content type="html"><![CDATA[<h2 id="11-2-基本概念"><a href="#11-2-基本概念" class="headerlink" title="11.2 基本概念"></a>11.2 基本概念</h2><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/194804/21/8107/119987/60c80d9eE646309f6/14b69fd5d3d42e6d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><blockquote><p><strong>Collection接口：</strong></p><ul><li><strong>List接口：</strong><ul><li><strong>LinkedList：链表，没有同步，线程不安全</strong></li><li><strong>ArrayList：数组，没有同步，线程不安全</strong></li><li><strong>Vector：数组，同步，线程安全</strong><ul><li><strong>Stack：继承Vector，线程安全</strong></li></ul></li></ul></li><li><strong>Set接口：不可重复，内部排序</strong><ul><li><strong>HashSet：散列函数</strong><ul><li><strong>LinkedHashSet：链表维护元素的插入次序</strong></li></ul></li><li><strong>TreeSet：底层为红黑树，自动升序排序保存</strong></li></ul></li></ul></blockquote><blockquote><p><strong>Map接口：</strong></p><ul><li><strong>HashMap：查找最快，无顺序 ，没有同步， 线程不安全</strong><ul><li><strong>LinkedHashMap：保留HashMap的速度，按照插入顺序保存</strong></li></ul></li><li><strong>TreeMap：红黑树，自动升序排序保存</strong></li><li><strong>Hashtable：接口实现类， 同步， 线程安全</strong></li></ul></blockquote><h2 id="11-3-Collection接口方法"><a href="#11-3-Collection接口方法" class="headerlink" title="11.3 Collection接口方法"></a>11.3 Collection接口方法</h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/179128/17/9179/165707/60c74ba0E32f5b85a/9a68e43c3f21496a.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="11-5-List接口"><a href="#11-5-List接口" class="headerlink" title="11.5 List接口"></a>11.5 List接口</h2><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/177265/15/8483/192890/60c80984Ec5274ff2/a5c5d7852650e1ad.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="11-6-迭代器Iterator"><a href="#11-6-迭代器Iterator" class="headerlink" title="11.6 迭代器Iterator"></a>11.6 迭代器Iterator</h2><blockquote><p><strong>Iterator：</strong></p><ul><li><strong>iterator（） 返回一个iterator，将准备好返回序列第一个元素</strong></li><li><strong>next（） 获得序列下一个元素</strong></li><li><strong>hasNext（） 判断序列是否还有元素</strong></li><li><strong>remove（）将迭代器返回的元素删除</strong></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;...&gt; it = a.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">print(it.next());</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果只想遍历List，不想修改，应该用foreach</strong></p><h3 id="11-6-1-ListIterator"><a href="#11-6-1-ListIterator" class="headerlink" title="11.6.1 ListIterator"></a>11.6.1 ListIterator</h3><p><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/174547/24/14667/332001/60c81452E423a1227/7973fcdf1a3097f0.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="11-9-Set"><a href="#11-9-Set" class="headerlink" title="11.9 Set"></a>11.9 Set</h2><blockquote><p><strong>Set和List的区别：</strong></p><ul><li><strong>List元素可以重复，Set不能重复</strong></li><li><strong>List可以根据索引操作元素，Set不能</strong></li><li><strong>List按照插入顺序保存，Set不一定</strong></li></ul></blockquote><hr><h2 id="11-10-Map"><a href="#11-10-Map" class="headerlink" title="11.10 Map"></a>11.10 Map</h2><p><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/195266/31/8254/290736/60c84667E2b4c4f75/101c49f5fe6ff436.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><hr><h2 id="11-11-Queue"><a href="#11-11-Queue" class="headerlink" title="11.11 Queue"></a>11.11 Queue</h2><p><strong>Collection-》Queue-》LinkedList</strong><br><strong>创建一个队列：<code>Queue&lt;...&gt; queue = new LinkedList&lt;...&gt;()</code></strong></p><h3 id="Queue方法"><a href="#Queue方法" class="headerlink" title="Queue方法"></a>Queue方法</h3><blockquote><ul><li><strong>继承自Collection，特殊方法如下：</strong><ul><li><strong>boolean offer（） 将元素插入队尾，或返回false</strong></li><li><strong>E peek（） 返回队头，若队列为空则返回null</strong></li><li><strong>E poll（） 删除队头并返回，若队列为空返回null</strong></li></ul></li></ul></blockquote><h3 id="11-11-1-PriorityQueue"><a href="#11-11-1-PriorityQueue" class="headerlink" title="11.11.1 PriorityQueue"></a>11.11.1 PriorityQueue</h3><ul><li><strong>自定义优先级比较器，作为优先队列构造器的参数。</strong></li><li><strong>优先队列继承自Queue，有同样的方法。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义比较器，降序排列</span></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Integer&gt; cmp = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer e1, Integer e2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e2 - e1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不用比较器，默认升序排列</span></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        q.add(<span class="number">3</span>);</span><br><span class="line">        q.add(<span class="number">2</span>);</span><br><span class="line">        q.add(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(q.poll()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果</span></span><br><span class="line"><span class="comment">         * 2 3 4</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//使用自定义比较器，降序排列</span></span><br><span class="line">        Queue&lt;Integer&gt; qq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(cmp);</span><br><span class="line">        qq.add(<span class="number">3</span>);</span><br><span class="line">        qq.add(<span class="number">2</span>);</span><br><span class="line">        qq.add(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">while</span>(!qq.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(qq.poll()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第10章 内部类</title>
      <link href="/posts/3853475454.html"/>
      <url>/posts/3853475454.html</url>
      
        <content type="html"><![CDATA[<h2 id="内部类的好处："><a href="#内部类的好处：" class="headerlink" title="内部类的好处："></a>内部类的好处：</h2><ul><li><strong>将类的代码隐藏在其他类内部。</strong></li><li><strong>内部类对象可以访问外部类的所有元素</strong> <strong>。</strong></li><li><strong>解决多继承的问题。</strong></li><li><strong>内部类可以有多个实例，与外部类独立。</strong></li><li><strong>单个外部类可以让多个内部类实现同一个接口或继承同一个类。</strong></li></ul><h2 id="一、成员内部类"><a href="#一、成员内部类" class="headerlink" title="一、成员内部类:"></a>一、成员内部类:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取内部类对象实例的方式"><a href="#获取内部类对象实例的方式" class="headerlink" title="获取内部类对象实例的方式"></a>获取内部类对象实例的方式</h3><ul><li><strong>普通内部类对象隐式的保存了一个指向外部类对象的引用。</strong></li><li><strong>new 外部类 . new 内部类。</strong></li><li><strong>外部类对象 . new 内部类。</strong></li><li><strong>外部类对象 . get方法。</strong></li></ul><h3 id="10-3-使用-this和-new"><a href="#10-3-使用-this和-new" class="headerlink" title="10.3 使用.this和.new"></a>10.3 使用.this和.new</h3><ul><li><strong>内部类中获取外部类对象的引用：外部类.this 。</strong></li><li><strong>外部类中访问内部类对象的引用：new 内部类()。</strong></li><li><strong>外部类中创建内部类对象必须使用外部类对象来创建内部类对象。</strong><ul><li><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/186931/40/8122/34987/60c75aa2Ec2f56c51/0e6a607f34a6dd50.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"></strong></li></ul></li></ul><h3 id="10-4-内部类和向上转型"><a href="#10-4-内部类和向上转型" class="headerlink" title="10.4 内部类和向上转型"></a>10.4 内部类和向上转型</h3><p><strong>内部类也可以和普通类一样拥有向上转型的特性。将内部类向上转型为基类型，尤其是接口时，内部类就有了用武之地。如果内部类是private的，只可以被它的外部类问，从而完全隐藏实现的细节。</strong></p><hr><h2 id="二、10-5-方法内部类"><a href="#二、10-5-方法内部类" class="headerlink" title="二、10.5 方法内部类"></a>二、10.5 方法内部类</h2><ul><li><strong>方法中创建类。</strong></li><li><strong>类前不能加访问说明符，类中不能有静态成员。</strong></li><li><strong>可以访问代码块内的常量和外部类的所有成员。</strong></li></ul><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li><strong>实现了某接口，创建并返回对其的引用。</strong></li><li><strong>需要创建一个类辅助解决问题，但不希望这个类公共可用。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object getInner&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="三、10-6-匿名内部类"><a href="#三、10-6-匿名内部类" class="headerlink" title="三、10.6 匿名内部类"></a>三、10.6 匿名内部类</h2><h3 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li><strong>只用到类的一个实例，因为不会有对象名称，无法再次调用。</strong></li><li><strong>实例化的同时重写方法，等同于创建子类继承父类并重写方法或实现接口。</strong></li><li><strong>没有静态成员</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.getRead(<span class="keyword">new</span> Person()&#123; <span class="comment">//实例化的同时重写方法，等同于创建子类继承父类并重写方法。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="四、10-7-静态内部类（嵌套类）"><a href="#四、10-7-静态内部类（嵌套类）" class="headerlink" title="四、10.7 静态内部类（嵌套类）"></a>四、10.7 静态内部类（嵌套类）</h2><h3 id="使用场景：-2"><a href="#使用场景：-2" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li><strong>不需要内部类对象与外部类有联系。</strong></li></ul><h3 id="与普通内部类的区别："><a href="#与普通内部类的区别：" class="headerlink" title="与普通内部类的区别："></a>与普通内部类的区别：</h3><ul><li><p><strong>普通内部类对象隐式的保存了一个指向外部类对象的引用，而静态内部类没有。</strong></p></li><li><p><strong>静态内部类创建对象不需要外部类对象。</strong></p></li><li><p><strong>普通内部类不能有static成员，而静态内部类可以。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态内部类中，不能通过对象访问非静态的外部类对象。</strong></p></li><li><p><strong>创建静态内部类对象：外部类.内部类 类名 = new 外部类.内部类();</strong></p></li></ul><h3 id="10-7-1-接口内部可以放静态内部类"><a href="#10-7-1-接口内部可以放静态内部类" class="headerlink" title="10.7.1 接口内部可以放静态内部类"></a>10.7.1 接口内部可以放静态内部类</h3><p><strong>正常情况接口内部不能放代码，但是静态内部类可以放，自动的public和static。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="10-9-内部类的继承"><a href="#10-9-内部类的继承" class="headerlink" title="10.9 内部类的继承"></a>10.9 内部类的继承</h3><p><strong>内部类对象隐式的包含对外部类对象的引用，所以在继承内部类的同时，构造器需要通过特殊语法初始化这个引用。</strong></p><ul><li><strong>外部类对象 . super()</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Outer</span>,<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="comment">// A()&#123;&#125;不能通过编译。 必须通过外部类对象.super初始化内部类对象对外部类对象的引用。</span></span><br><span class="line">A(Outer o)&#123;</span><br><span class="line">    o.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章 接口</title>
      <link href="/posts/570509114.html"/>
      <url>/posts/570509114.html</url>
      
        <content type="html"><![CDATA[<h2 id="9-1-抽象类和抽象方法"><a href="#9-1-抽象类和抽象方法" class="headerlink" title="9.1 抽象类和抽象方法"></a>9.1 抽象类和抽象方法</h2><p><strong>含有抽象方法的类叫做抽象类</strong><br><strong><code>abstract class name&#123;...&#125;</code></strong></p><h3 id="抽象方法的特征"><a href="#抽象方法的特征" class="headerlink" title="抽象方法的特征"></a>抽象方法的特征</h3><ul><li><strong>抽象方法不允许有方法体，只能以分号“;”结尾</strong> </li><li><strong>抽象方法只能声明在抽象类中</strong></li><li><strong>抽象类中可以包含0个或多个抽象方法。</strong></li><li><strong>抽象方法必须被子类实现</strong> </li><li><strong>如果子类不能实现父类中的抽象方法，那么子类也必须是抽象类</strong></li></ul><h3 id="什么情况下使用抽象方法和抽象类"><a href="#什么情况下使用抽象方法和抽象类" class="headerlink" title="什么情况下使用抽象方法和抽象类"></a>什么情况下使用抽象方法和抽象类</h3><p><strong>父类的名称比较抽象，创建对象无意义</strong></p><h2 id="9-2-接口"><a href="#9-2-接口" class="headerlink" title="9.2 接口"></a>9.2 接口</h2><p><strong>比抽象类更抽象。</strong><br><strong><code>interface A&#123;...&#125;</code></strong><br><strong><code>class B implements A&#123;...&#125;</code></strong><br><strong>接口中的变量隐式的指定为static和final，没有方法体 。</strong></p><h3 id="抽象类和接口的区别："><a href="#抽象类和接口的区别：" class="headerlink" title="抽象类和接口的区别："></a>抽象类和接口的区别：</h3><ul><li><strong>抽象类只能单继承,接口能多实现</strong> 。</li><li><strong>抽象类是一个类,可以被任意权限修饰符修饰,静态和非静态属性，final和非final属性，可以有抽象方法和非抽象方法</strong></li><li><strong>接口只能被public,final修饰,只能有静态方法,即使没有显示的声明，而且是不可修改的；</strong></li><li><strong>抽象类是对类的抽象，接口是对行为的抽象。</strong></li><li><strong>设计抽象类是自下而上的过程,我子类需要,所以我定义抽象类；而设计接口是自上而下的过程,我接口规范某一行为,我某类需要这个行为,我实现某接口；</strong></li></ul><p><strong>核心区别:</strong><br><strong>调用者使用动机不同,实现接口是为了使用他规范的某一个行为；</strong><br><strong>继承抽象类是为了使用这个类属性和行为.</strong></p><p><strong>再简单点说:</strong><br><strong>我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的规则而已。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第8章 多态</title>
      <link href="/posts/379377268.html"/>
      <url>/posts/379377268.html</url>
      
        <content type="html"><![CDATA[<h2 id="8-2-绑定"><a href="#8-2-绑定" class="headerlink" title="8.2 绑定"></a>8.2 绑定</h2><p><strong>静态绑定和动态绑定</strong></p><ul><li><strong>绑定：一个方法的调用与方法所在的类关联起来。</strong></li><li><strong>静态绑定：在编译过程中就已经知道这个方法到底是哪个类中的方法。</strong></li><li><strong>动态绑定：运行时根据对象的类进行绑定。</strong></li></ul><p><strong>java中除了static和final方法（包括private），其他方法都是动态绑定</strong> <strong>。</strong></p><h3 id="8-2-1-向上转型"><a href="#8-2-1-向上转型" class="headerlink" title="8.2.1 向上转型"></a>8.2.1 向上转型</h3><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/185948/12/9082/119939/60c7597dE1e65c954/7e73954f040131b6.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"> <br>  <strong>s.draw()调用的是circle的draw()</strong></p><ul><li><strong>多态 = 向上转型 = 动态绑定 。</strong><ul><li><strong>静态方法不具有多态性</strong> 。<img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/137541/24/19032/220254/60c759bbE03940af0/571a93e46206a98c.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><h2 id="8-3-带main方法的类构造器继承调用顺序"><a href="#8-3-带main方法的类构造器继承调用顺序" class="headerlink" title="8.3 带main方法的类构造器继承调用顺序"></a>8.3 带main方法的类构造器继承调用顺序</h2><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/189817/35/8121/74886/60c75a10E93f2cc8c/dc80047544e3a2fb.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"><br><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/180763/28/9192/151689/60c75a29E195d704b/2c878cc1a1720461.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章 复用类</title>
      <link href="/posts/4165567299.html"/>
      <url>/posts/4165567299.html</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-当需要String时，编译器会自动调用toString"><a href="#7-1-当需要String时，编译器会自动调用toString" class="headerlink" title="7.1 当需要String时，编译器会自动调用toString()"></a>7.1 <strong>当需要String时，编译器会自动调用toString()</strong></h2><p><img "" class="lazyload placeholder" data-original="https://img12.360buyimg.com/ddimg/jfs/t1/187768/8/8156/173809/60c758caE0235709d/c47a625b496f5f12.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="7-2-导出类构造器和基类构造器"><a href="#7-2-导出类构造器和基类构造器" class="headerlink" title="7.2 导出类构造器和基类构造器"></a>7.2 导出类构造器和基类构造器</h2><p><strong>所有的类都可以含有main方法，无需删除，方便单元测试。</strong></p><ul><li><strong>创建从基类继承的类的对象会先执行基类构造器，然后再执行继承类的构造器<strong><strong>，所以导出类构造器中必须带有基类构造器</strong></strong>。</strong><ul><li><strong>若想要在继承类中调用基类的带参数的构造器，需要使用super关键字****。</strong></li><li><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/193139/8/8169/55490/60c758e4E6a6e76af/a9bf8344bb31fa8d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></li></ul></li></ul><h2 id="7-6-protected-关键字"><a href="#7-6-protected-关键字" class="headerlink" title="7.6 protected 关键字"></a>7.6 protected 关键字</h2><p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/187016/1/8186/58893/60c7591bEee00236c/a0654b60d7f66a72.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="7-7-向上转型"><a href="#7-7-向上转型" class="headerlink" title="7.7 向上转型"></a>7.7 向上转型</h2><p><strong>导出类对象自动提升到基类对象，向上转型是安全的，只会丢失方法</strong><br><strong><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/184299/24/9164/118703/60c75937E35962a8e/609ac1042d2790ce.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h3 id="7-7-2-再论继承与组合"><a href="#7-7-2-再论继承与组合" class="headerlink" title="7.7.2 再论继承与组合"></a>7.7.2 再论继承与组合</h3><p><strong>使用继承还是组合最清晰的办法就是要不要向上转型。如果要向上转型，那继承是必要的。如果不需要，再好好考虑</strong></p><h2 id="7-8-final关键字"><a href="#7-8-final关键字" class="headerlink" title="7.8 final关键字"></a>7.8 final关键字</h2><h3 id="7-8-1-final-数据"><a href="#7-8-1-final-数据" class="headerlink" title="7.8.1 final 数据"></a>7.8.1 final 数据</h3><ul><li><strong>若是基本数据类型则值不变</strong> 。</li><li><strong>若是对象引用则引用不变，一旦被初始化，则无法再指向另一个对象，对象自身可以修改</strong> <strong>。</strong></li><li><strong>既是static又是final的变量用大写表示。</strong></li></ul><h3 id="final-参数"><a href="#final-参数" class="headerlink" title="final 参数"></a>final 参数</h3><ul><li><strong>方法的参数列表指定为final。基本数据类型值不能修改，引用对象不能更换指向。</strong></li></ul><h3 id="7-8-2-final-方法"><a href="#7-8-2-final-方法" class="headerlink" title="7.8.2 final 方法"></a>7.8.2 final 方法</h3><ul><li><strong>final方法不能重写</strong></li><li><strong>private方法已经隐式的指定为final，不能重写</strong></li><li><strong>final方法可以关闭动态绑定</strong></li></ul><h3 id="7-8-3-final-类"><a href="#7-8-3-final-类" class="headerlink" title="7.8.3 final 类"></a>7.8.3 final 类</h3><ul><li><strong>final类不能继承</strong></li><li><strong>final类中的变量可以选择final或者不final，但是方法不能重写</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章 访问权限控制</title>
      <link href="/posts/2899887770.html"/>
      <url>/posts/2899887770.html</url>
      
        <content type="html"><![CDATA[<p><img "" class="lazyload placeholder" data-original="https://img11.360buyimg.com/ddimg/jfs/t1/181179/18/9114/48938/60c7583eE281939e9/7e2ddeae94364274.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><ul><li><strong>public：可以被所有其他类所访问。</strong></li><li><strong>private：只能被自己访问和修改。</strong></li><li><strong>protected：自身、子类及同一个包中类可以访问。</strong></li><li><strong>default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。</strong></li><li><strong>为了继承，通常把数据指定为private，方法为public</strong> <strong>。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章 初始化与清理</title>
      <link href="/posts/3655551301.html"/>
      <url>/posts/3655551301.html</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-构造器"><a href="#5-1-构造器" class="headerlink" title="5.1 构造器"></a>5.1 构造器</h2><p><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/186178/13/9202/31200/60c757f8E20e3c80e/ae27efe8cf40900e.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h2 id="5-2-重载"><a href="#5-2-重载" class="headerlink" title="5.2 重载"></a>5.2 重载</h2><ul><li><strong>重载方法必须拥有独一无二的参数列表，返回值不同不能作为区分重载的标志。</strong></li><li><strong>传入数据类型小于方法中的参数类型，会自动提升。如果没有char类型，会自动提升到int型。</strong></li><li><strong>传入数据类型大于方法中的参数类型，必须强制转换。</strong></li></ul><blockquote><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><ul><li><strong>重载：在同一个类中相同名字的方法，参数列表不同。</strong></li><li><strong>重写：子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了。</strong></li></ul></blockquote><h2 id="5-3-默认构造器"><a href="#5-3-默认构造器" class="headerlink" title="5.3 默认构造器"></a>5.3 默认构造器</h2><ul><li><strong>没有写构造器会自动创建无参构造器。</strong></li><li><strong>写了构造器，就不会自动创建构造器。</strong></li></ul><h2 id="5-4-this关键字"><a href="#5-4-this关键字" class="headerlink" title="5.4 this关键字"></a>5.4 this关键字</h2><ul><li><strong>在方法内部使用，表示调用该方法的那个对象的引用。</strong></li><li><strong>在方法中调用同一个类的另一个方法不需要用this，只有当需要明确指出对当前对象的引用时才用this。</strong><ul><li><strong>例如return this 或者作为参数传递给外部函数。</strong></li></ul></li><li><strong>在构造器中使用this调用另一个构造器。</strong></li></ul><h2 id="5-7-初始化顺序"><a href="#5-7-初始化顺序" class="headerlink" title="5.7 初始化顺序"></a>5.7 初始化顺序</h2><ul><li><strong>静态变量（只初始化一次）-》非静态变量-》构造器</strong></li></ul><h2 id="5-8-数组初始化"><a href="#5-8-数组初始化" class="headerlink" title="5.8 数组初始化"></a>5.8 数组初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组初始化三种形式</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-8-1-可变参数列表"><a href="#5-8-1-可变参数列表" class="headerlink" title="5.8.1 可变参数列表"></a>5.8.1 可变参数列表</h3><ul><li><strong>用Object数组或Object… args作为参数即可。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 控制执行流程</title>
      <link href="/posts/1549253474.html"/>
      <url>/posts/1549253474.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-4-foreach与for循环"><a href="#4-4-foreach与for循环" class="headerlink" title="4.4 foreach与for循环"></a>4.4 foreach与for循环</h2><ul><li><strong>foreach和for循环在数组遍历上，速度相当，for循环稍快。</strong></li><li><strong>在链表遍历上，foreach比for循环快很多。</strong></li><li><strong>foreach不能插入和删除操作。</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 操作符</title>
      <link href="/posts/4261820945.html"/>
      <url>/posts/4261820945.html</url>
      
        <content type="html"><![CDATA[<h2 id="3-2-和equals"><a href="#3-2-和equals" class="headerlink" title="3.2 ==和equals"></a>3.2 ==和equals</h2><ul><li><p><strong>==的含义：</strong></p><ul><li><strong>比较基本数据类型的值是否相同。</strong></li><li><strong>比较引用数据类型的地址是否相同。</strong></li></ul></li><li><p><strong>equals的含义：</strong></p><ul><li><strong>Object中的equals和==一样，都是比较对象的地址。</strong></li><li><strong>String在Object的基础上重写了equals，比较的是字符串的内容。</strong></li></ul></li><li><p><strong>String的equals源码</strong><br><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/182134/35/9178/113522/60c757a1Ed15aa1e2/f61d1016c4fe6fcb.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"> </p><h2 id="3-15-类型转换"><a href="#3-15-类型转换" class="headerlink" title="3.15 类型转换"></a>3.15 类型转换</h2></li><li><p><strong>编译器会在必要的时候自动将int转换到long。</strong></p></li><li><p><strong>小数据类型会自动转换为大数据类型。</strong></p><ul><li><strong>如：char、byte、short在运算时会自动转换为int。</strong></li></ul></li><li><p><strong>大数据类型到小数据类型需要强制转换。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 对象</title>
      <link href="/posts/3335107905.html"/>
      <url>/posts/3335107905.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-2-基本数据类型"><a href="#2-2-基本数据类型" class="headerlink" title="2.2 基本数据类型"></a>2.2 基本数据类型</h2><p><strong>string不是基本数据类型。</strong><img "" class="lazyload placeholder" data-original="https://img13.360buyimg.com/ddimg/jfs/t1/195661/8/8079/206780/60c755f6E54758dcd/ffdb69980ac7b6c1.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></p><h3 id="2-2-2-高精度数字"><a href="#2-2-2-高精度数字" class="headerlink" title="2.2.2 高精度数字"></a>2.2.2 高精度数字</h3><ul><li><strong>高精度数字：BigInteger、BigDecimal</strong><ul><li><strong>BigInteger：支持任意精度的整数。</strong></li><li><strong>BigDecimal：支持任意精度的定点数。</strong></li></ul></li></ul><h3 id="2-2-3-创建数组对象就是创建一个引用数组。"><a href="#2-2-3-创建数组对象就是创建一个引用数组。" class="headerlink" title="2.2.3 创建数组对象就是创建一个引用数组。"></a>2.2.3 创建数组对象就是创建一个引用数组。</h3><h2 id="2-3-生命周期"><a href="#2-3-生命周期" class="headerlink" title="2.3 生命周期"></a>2.3 生命周期</h2><p><strong>java对象生命周期和基本类型不一样。用new创建的对象可以存活于作用域之外。</strong><br><strong>java垃圾回收器会监视new的对象，辨别不会再被引用的对象并释放内存空间。</strong></p><h2 id="2-4-初始值"><a href="#2-4-初始值" class="headerlink" title="2.4 初始值"></a>2.4 初始值</h2><p><strong>变量作为类的成员或全局变量会有初始默认值，局部变量没有初始值。</strong><br><strong><img "" class="lazyload placeholder" data-original="https://img10.360buyimg.com/ddimg/jfs/t1/182601/20/9214/90450/60c756c2E31138148/e3d464be6e09303d.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><h2 id="2-5-java函数可以返回数组，c-c-不能"><a href="#2-5-java函数可以返回数组，c-c-不能" class="headerlink" title="2.5 java函数可以返回数组，c/c++不能"></a>2.5 java函数可以返回数组，c/c++不能</h2><h2 id="2-6-java库函数-java-util"><a href="#2-6-java库函数-java-util" class="headerlink" title="2.6 java库函数 java.util.*"></a>2.6 java库函数 <code>java.util.*</code></h2><h3 id="2-6-3-static-关键字"><a href="#2-6-3-static-关键字" class="headerlink" title="2.6.3 static 关键字"></a>2.6.3 static 关键字</h3><ul><li><strong>static适用于两种情况</strong><ul><li><strong>分配单一存储空间，不考虑创建多少对象或者不创建对象。</strong></li><li><strong>创建的方法不与包含它的类的对象关联起来</strong></li></ul></li><li><strong>创建static事物后，即使没有创建对象也可以调用static方法或static域。</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://img14.360buyimg.com/ddimg/jfs/t1/185967/29/9177/76016/60c756eeE4ec4eae5/e3b719fb7e5add2e.jpg" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif"></strong></p><ul><li><strong>static变量或static方法可以通过类名直接引用，而且是首选方式</strong> <strong>。</strong></li><li><strong>static方法内部不能调用非static方法，非static方法可以调用static方法</strong> 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 导论</title>
      <link href="/posts/801825792.html"/>
      <url>/posts/801825792.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><p><strong>每一个对象在内存中都有一个唯一的地址，new的对象在堆中。</strong></p><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h2><p><strong>高内聚、低耦合：模块之间紧密联系，并且保持独立性。</strong></p><h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><ul><li><strong>public、private、protected</strong><ul><li><strong>private: 除类型创建者和类型的内部方法之外的任何人都不能访问。</strong></li><li><strong>protected：与 private作用相当，差别仅在于继承的类可以访问 protected成员，但是不能访问private成员。</strong></li></ul></li></ul><h2 id="1-5-组合"><a href="#1-5-组合" class="headerlink" title="1.5 组合"></a>1.5 组合</h2><ul><li><strong>组合：由类的对象组合成新类</strong>。<ul><li><strong>has-a（拥有）关系的时候用组合</strong> <strong>。</strong></li><li><strong>新类的成员对象通常都被声明为 private，使得可以在不干扰现有客户端代码的情况下，修改这些成员，也可以在运行时修改这些成员对象，以实现动态修改程序的行为。</strong></li><li><strong>通常用于在新类中使用现有类的功能而非接口的情况，即在新类中嵌入现有类的private对象</strong></li></ul></li></ul><h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6 继承"></a>1.6 继承</h2><p><strong>is-a（是一个）或者like-a（像是一个）的时候用继承</strong><br><strong>有两种方法可以使基类与导出类产生差异：extends关键字、覆盖基类的方法。</strong><br><strong>判断用组合还是继承，先看看要不要向上转型</strong> 。</p><h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p><strong>所有类继承于Object。</strong><br><strong>所有对象都在堆上创建（new）。</strong></p><h2 id="1-10-生命周期"><a href="#1-10-生命周期" class="headerlink" title="1.10 生命周期"></a>1.10 生命周期</h2><ul><li><strong>java完全采用动态内存分配方式。</strong><ul><li><strong>在堆栈上创建对象，编译器可以确定对象存活时间，自动销毁。但是在堆上创建对象，编译器对其生命周期一无所知</strong>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 《Java编程思想》读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
